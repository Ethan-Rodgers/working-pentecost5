{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,IEsOiB,E,E,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,a,C,M,C,C,G,E,W,C,E,Y,C,E,M,C,E,wB,C,E,qB,C,E,mB,C,E,mB,C,E,e,C,E,c,C,E,a,C,E,a,C,E,iB,C,E,yB,C,E,kB,C,E,Q,C,E,W,C,E,M,C,K,EApOjB,IAAA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UAEA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,SAoFA,OAAa,UAAe,EAAK,SAAS,CAsBxC,YAAY,CACV,QAAA,EAAU,EAAK,OAAO,CAAC,kBAAkB,CACzC,OAAA,EAAS,EAAK,OAAO,CAAC,iBAAiB,CACvC,aAAA,EAAe,EAAK,OAAO,CAAC,kBAAoB,IAAI,CACpD,QAAA,EAAU,EAAK,OAAO,CAAC,sBAAwB,IAAI,CACnD,GAAG,EAAI,CACU,CAAA,CAAE,CANrB,CAOE,GAAI,A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M,A,M,E,E,I,C,E,G,E,E,K,C,E,E,G,C,E,G,C,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,E,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,4E,M,A,M,E,E,A,M,E,E,I,C,G,E,E,K,C,E,G,C,E,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,K,C,E,O,C,Q,C,E,O,C,S,C,E,O,C,iB,C,E,O,C,iB,C,E,O,C,kB,C,E,O,C,K,C,E,O,C,M,C,E,O,C,U,C,E,O,C,kB,C,E,O,C,gB,C,E,O,C,kB,C,E,O,C,a,C,E,O,C,W,C,E,O,C,a,C,E,O,C,O,C,E,O,C,a,C,E,O,C,W,C,E,O,C,K,C,E,O,C,Q,C,E,O,C,gB,C,E,O,C,qB,C,E,O,C,W,C,E,O,C,Y,C,E,O,C,S,C,E,O,C,U,C,E,O,C,U,C,E,O,C,2B,C,E,O,C,gC,C,K,E,I,E,E,S,E,E,S,E,E,S,E,E,S,G,E,S,E,UAr8BJ,eAAe,EAAwB,CAAuB,EAC5D,GAAM,CAAA,SAAE,CAAQ,CAAE,CAAG,EACrB,GAAI,EAAM,OAAO,CAAC,MAAM,OAMtB,CALA,EAAM,WAAY,EAAS,MAAM,CAAE,EAAS,GAAG,CAAE,EAAS,OAAO,CAAE,EAAS,IAAI,EAK5E,EAAM,OAAO,CAAC,aAAa,EACtB,EAAM,OAAO,CAAC,aAAa,CAAC,eAAe,CAAC,EAAU,EAAM,UAAU,EAGxE,EAAA,MAAA,CAAO,eAAe,CAAC,EAAU,EAAM,UAAU,EAI1D,GAAI,AAAoB,MAApB,EAAS,MAAM,CACjB,OAAO,KAGT,GAAI,EAAM,OAAO,CAAC,gBAAgB,CAChC,OAAO,EAGT,IAAM,EAAc,EAAS,OAAO,CAAC,GAAG,CAAC,gBAGzC,GADE,GAAa,SAAS,qBAAuB,GAAa,SAAS,4BACzD,CACV,IAAM,EAAO,MAAM,EAAS,IAAI,GAIhC,OAFA,EAAM,WAAY,EAAS,MAAM,CAAE,EAAS,GAAG,CAAE,EAAS,OAAO,CAAE,GAE5D,EAAc,EAAM,EAC5B,CAED,IAAM,EAAO,MAAM,EAAS,IAAI,GAIhC,OAHA,EAAM,WAAY,EAAS,MAAM,CAAE,EAAS,GAAG,CAAE,EAAS,OAAO,CAAE,GAG5D,CACT,CAOA,SAAS,EAAiB,CAAQ,CAAE,CAAkB,QACpD,AAAI,CAAC,GAAS,AAAiB,UAAjB,OAAO,GAAsB,MAAM,OAAO,CAAC,GAChD,EAGF,OAAO,cAAc,CAAC,EAAO,cAAe,CACjD,MAAO,EAAS,OAAO,CAAC,GAAG,CAAC,gBAC5B,WAAY,CAAA,CACb,EACH,CAxEE,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,mCAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,gCAAA,AAAgC,CAAA,GAChC,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,8BAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,2BAAA,AAA2B,CAAA,GAC3B,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,aAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,UAAA,AAAU,CAAA,EA4EZ,OAAa,UAAsB,QAGjC,YACU,CAA0C,CAC1C,EAEgC,CAAoB,CAJ9D,CAME,KAAK,CAAC,AAAC,IAIL,EAAQ,KACV,GAVQ,IAAA,CAAA,eAAe,CAAf,EACA,IAAA,CAAA,aAAa,CAAb,CAUV,CAEA,YAAe,CAAyB,CAAxC,CACE,OAAO,IAAI,EAAW,IAAI,CAAC,eAAe,CAAE,MAAO,GACjD,EAAc,EAAU,MAAM,IAAI,CAAC,aAAa,CAAC,IAAS,EAAM,QAAQ,EAE5E,CAeA,YAAA,CACE,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,AAAC,GAAM,EAAE,QAAQ,CACpD,CAiBA,MAAM,cAAN,CACE,GAAM,CAAC,EAAM,EAAS,CAAG,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,GAAI,IAAI,CAAC,UAAU,GAAG,EAC5E,MAAO,CAAE,KAAA,EAAM,SAAA,EAAU,WAAY,EAAS,OAAO,CAAC,GAAG,CAAC,eAAe,CAC3E,CAEQ,OAAA,CAIN,OAHK,IAAI,CAAC,aAAa,EACrB,CAAA,IAAI,CAAC,aAAa,CAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAA,EAE5D,IAAI,CAAC,aAAa,AAC3B,CAES,KACP,CAAgG,CAChG,CAAmF,CAF5E,CAIP,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,EAAa,EACxC,CAES,MACP,CAAiF,CAD1E,CAGP,OAAO,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,EAC5B,CAES,QAAQ,CAA2C,CAAnD,CACP,OAAO,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,EAC9B,CACD,CAnFD,EAAA,OAAA,CAAA,UAAA,CAAA,EAqFA,EAAA,OAAA,CAAA,SAAA,CAAA,MASE,YAAY,CAAA,QACV,CAAO,CAAA,WACP,EAAa,CAAA,CAAA,QACb,EAAU,GAAA,CAAA,UACV,CAAS,CACT,MAAO,CAAc,CAOtB,CARC,CASA,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,UAAU,CAAG,EAAwB,aAAc,GACxD,IAAI,CAAC,OAAO,CAAG,EAAwB,UAAW,GAClD,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,KAAK,CAAG,GAAkB,EAA/B,KAAA,AACF,CAEU,YAAY,CAAyB,CAArC,CACR,MAAO,CAAA,CACT,CAUU,eAAe,CAAyB,CAAxC,CACR,MAAO,CACL,OAAQ,mBACR,eAAgB,mBAChB,aAAc,IAAI,CAAC,YAAY,GAC/B,GAAG,GAAoB,CACvB,GAAG,IAAI,CAAC,WAAW,CAAC,EAAK,AAC1B,CACH,CAOU,gBAAgB,CAAgB,CAAE,CAAsB,CAAA,CAAG,CAE3D,uBAAA,CACR,MAAO,CAAA,qBAAA,EAAwB,IAAO,CAAE,AAC1C,CAEA,IAAc,CAAY,CAAE,CAA0C,CAAtE,CACE,OAAO,IAAI,CAAC,aAAa,CAAC,MAAO,EAAM,EACzC,CAEA,KAAe,CAAY,CAAE,CAA0C,CAAvE,CACE,OAAO,IAAI,CAAC,aAAa,CAAC,OAAQ,EAAM,EAC1C,CAEA,MAAgB,CAAY,CAAE,CAA0C,CAAxE,CACE,OAAO,IAAI,CAAC,aAAa,CAAC,QAAS,EAAM,EAC3C,CAEA,IAAc,CAAY,CAAE,CAA0C,CAAtE,CACE,OAAO,IAAI,CAAC,aAAa,CAAC,MAAO,EAAM,EACzC,CAEA,OAAiB,CAAY,CAAE,CAA0C,CAAzE,CACE,OAAO,IAAI,CAAC,aAAa,CAAC,SAAU,EAAM,EAC5C,CAEQ,cACN,CAAkB,CAClB,CAAY,CACZ,CAA0C,CAHpC,CAKN,OAAO,IAAI,CAAC,OAAO,CACjB,QAAQ,OAAO,CAAC,GAAM,IAAI,CAAC,MAAO,IAChC,IAAM,EACJ,GAAQ,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,GAAM,MAAQ,IAAI,SAAS,MAAM,EAAK,IAAI,CAAC,WAAW,IACvE,GAAM,gBAAgB,SAAW,EAAK,IAAI,CAC1C,GAAM,gBAAgB,YAAc,IAAI,SAAS,EAAK,IAAI,EAC1D,GAAQ,YAAY,MAAM,CAAC,GAAM,MAAQ,IAAI,SAAS,EAAK,IAAI,CAAC,MAAM,EACtE,GAAM,KACV,MAAO,CAAE,OAAA,EAAQ,KAAA,EAAM,GAAG,CAAI,CAAE,KAAA,CAAI,CACtC,GAEJ,CAEA,WACE,CAAY,CACZ,CAAuC,CACvC,CAA0B,CAH5B,CAKE,OAAO,IAAI,CAAC,cAAc,CAAC,EAAM,CAAE,OAAQ,MAAO,KAAA,EAAM,GAAG,CAAI,AAAA,EACjE,CAEQ,uBAAuB,CAAa,CAApC,CACN,GAAI,AAAgB,UAAhB,OAAO,EAAmB,CAC5B,GAAI,AAAkB,KAAA,IAAlB,EACF,OAAO,EAAO,UAAU,CAAC,EAAM,QAAQ,QAAQ,GAGjD,GAAI,AAAuB,aAAvB,OAAO,YAGT,OAAO,AADS,AADA,IAAI,cACI,MAAM,CAAC,GAChB,MAAM,CAAC,QAAQ,EAEjC,MAAM,GAAI,YAAY,MAAM,CAAC,GAC5B,OAAO,EAAK,UAAU,CAAC,QAAQ,GAGjC,OAAO,IACT,CAEA,aACE,CAAiC,CACjC,CAAA,WAAE,EAAa,CAAA,CAAC,CAA8B,CAAA,CAAE,CAFlD,CAIE,GAAM,CAAA,OAAE,CAAM,CAAA,KAAE,CAAI,CAAA,MAAE,CAAK,CAAE,QAAS,EAAU,CAAA,CAAE,CAAE,CAAG,EAEjD,EACJ,YAAY,MAAM,CAAC,EAAQ,IAAI,GAAM,EAAQ,eAAe,EAAI,AAAwB,UAAxB,OAAO,EAAQ,IAAI,CACjF,EAAQ,IAAI,CACZ,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,EAAQ,IAAI,EAAI,EAAQ,IAAI,CAAC,IAAI,CACjD,EAAQ,IAAI,CAAG,KAAK,SAAS,CAAC,EAAQ,IAAI,CAAE,KAAM,GAClD,KACE,EAAgB,IAAI,CAAC,sBAAsB,CAAC,GAE5C,EAAM,IAAI,CAAC,QAAQ,CAAC,EAAO,EAC7B,CAAA,YAAa,GAAS,EAAwB,UAAW,EAAQ,OAAO,EAC5E,IAAM,EAAU,EAAQ,OAAO,EAAI,IAAI,CAAC,OAAO,CACzC,EAAY,EAAQ,SAAS,EAAI,IAAI,CAAC,SAAS,EAAI,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,GACnE,EAAkB,EAAU,GAEgB,CAAA,UAAhD,OAAQ,GAAmB,SAAS,SACpC,EAAoB,CAAA,EAAkB,OAAO,CAAC,OAAO,EAAI,CAAA,GAMxD,CAAA,EAAkB,OAAO,CAAC,OAAO,CAAG,CAApC,EAGC,IAAI,CAAC,iBAAiB,EAAI,AAAW,QAAX,IACvB,EAAQ,cAAc,EAAE,CAAA,EAAQ,cAAc,CAAG,IAAI,CAAC,qBAAqB,EAAhF,EACA,CAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAG,EAAQ,cAAc,EAG1D,IAAM,EAAa,IAAI,CAAC,YAAY,CAAC,CAAE,QAAA,EAAS,QAAA,EAAS,cAAA,EAAe,WAAA,CAAU,GAYlF,MAAO,CAAE,IAVgB,CACvB,OAAA,EACA,GAAI,GAAQ,CAAE,KAAM,CAAW,CAAE,CACjC,QAAS,EACT,GAAI,GAAa,CAAE,MAAO,CAAS,CAAE,CAGrC,OAAQ,EAAQ,MAAM,EAAI,IAC3B,EAEa,IAAA,EAAK,QAAA,CAAO,CAC5B,CAEQ,aAAa,CAAA,QACnB,CAAO,CAAA,QACP,CAAO,CAAA,cACP,CAAa,CAAA,WACb,CAAU,CAMX,CAVO,CAWN,IAAM,EAAqC,CAAA,EAsB3C,OArBI,GACF,CAAA,CAAU,CAAC,iBAAiB,CAAG,CADjC,EAKA,EAAgB,EADO,IAAI,CAAC,cAAc,CAAC,IAE3C,EAAgB,EAAY,GAGxB,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,EAAQ,IAAI,GAAK,AAAc,SAAd,EAAA,IAAA,EACnC,OAAO,CAAU,CAAC,eAAe,CAKmB,KAAA,IAAlD,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,SAAS,AAAT,EAAU,EAAS,4BACrB,CAAA,CAAU,CAAC,0BAA0B,CAAG,OAAO,EADjD,EAIA,IAAI,CAAC,eAAe,CAAC,EAAY,GAE1B,CACT,CAKU,MAAM,eAAe,CAA4B,CAAA,CAAkB,CAQnE,MAAM,eACd,CAAoB,CACpB,CAAA,IAAE,CAAG,CAAA,QAAE,CAAO,CAAiD,CAAA,CAC/C,CAER,aAAa,CAAuC,CAApD,CACR,OACE,AAAC,EACC,OAAO,QAAQ,IAAI,EACnB,OAAO,WAAW,CAAC,MAAM,IAAI,CAAC,GAA+B,GAAG,CAAC,AAAC,GAAW,IAAI,EAAO,GACxF,CAAE,GAAG,CAAO,AAAA,EAHH,CAAA,CAKf,CAEU,gBACR,CAA0B,CAC1B,CAAyB,CACzB,CAA2B,CAC3B,CAA4B,CAJpB,CAMR,OAAO,EAAA,QAAA,CAAS,QAAQ,CAAC,EAAQ,EAAO,EAAS,EACnD,CAEA,QACE,CAAiD,CACjD,EAAkC,IAAI,CAFxC,CAIE,OAAO,IAAI,EAAW,IAAI,CAAC,WAAW,CAAC,EAAS,GAClD,CAEQ,MAAM,YACZ,CAAsD,CACtD,CAA+B,CAFzB,CAIN,IAAM,EAAU,MAAM,EAChB,EAAa,EAAQ,UAAU,EAAI,IAAI,CAAC,UAAU,AAChC,OAApB,GACF,CAAA,EAAmB,CADrB,EAIA,MAAM,IAAI,CAAC,cAAc,CAAC,GAE1B,GAAM,CAAA,IAAE,CAAG,CAAA,IAAE,CAAG,CAAA,QAAE,CAAO,CAAE,CAAG,IAAI,CAAC,YAAY,CAAC,EAAS,CAAE,WAAY,EAAa,CAAgB,GAMpG,GAJA,MAAM,IAAI,CAAC,cAAc,CAAC,EAAK,CAAE,IAAA,EAAK,QAAA,CAAO,GAE7C,EAAM,UAAW,EAAK,EAAS,EAAI,OAAO,EAEtC,EAAQ,MAAM,EAAE,QAClB,MAAM,IAAI,EADZ,iBAAA,CAIA,IAAM,EAAa,IAAI,gBACjB,EAAW,MAAM,IAAI,CAAC,gBAAgB,CAAC,EAAK,EAAK,EAAS,GAAY,KAAK,CAAC,EAAA,OAAA,CAAA,WAAW,EAE7F,GAAI,aAAoB,MAAO,CAC7B,GAAI,EAAQ,MAAM,EAAE,QAClB,MAAM,IAAI,EADZ,iBAAA,CAGA,GAAI,EACF,OAAO,IAAI,CAAC,YAAY,CAAC,EAAS,GAEpC,GAAI,AAAkB,eAAlB,EAAS,IAAI,CACf,MAAM,IAAI,EADZ,yBAAA,AAGA,OAAM,IAAI,EAAA,kBAAA,CAAmB,CAAE,MAAO,CAAQ,EAC/C,CAED,IAAM,EAAkB,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,qBAAA,AAAA,EAAsB,EAAS,OAAO,EAE9D,GAAI,CAAC,EAAS,EAAE,CAAE,CAChB,GAAI,GAAoB,IAAI,CAAC,WAAW,CAAC,GAAW,CAClD,IAAM,EAAe,CAAA,UAAA,EAAa,EAAgB,mBAAA,CAAqB,CAEvE,OADA,EAAM,CAAA,iBAAA,EAAoB,EAAY,CAAA,CAAG,CAAE,EAAS,MAAM,CAAE,EAAK,GAC1D,IAAI,CAAC,YAAY,CAAC,EAAS,EAAkB,EACrD,CAED,IAAM,EAAU,MAAM,EAAS,IAAI,GAAG,KAAK,CAAC,AAAC,GAAM,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,WAAW,AAAX,EAAY,GAAG,OAAO,EACnE,EAAU,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,QAAA,AAAA,EAAS,GACnB,EAAa,EAAU,KAAA,EAAY,EACnC,EAAe,EAAmB,gCAAkC,wBAK1E,OAHA,EAAM,CAAA,iBAAA,EAAoB,EAAY,CAAA,CAAG,CAAE,EAAS,MAAM,CAAE,EAAK,EAAiB,GAEtE,IAAI,CAAC,eAAe,CAAC,EAAS,MAAM,CAAE,EAAS,EAAY,EAExE,CAED,MAAO,CAAE,SAAA,EAAU,QAAA,EAAS,WAAA,CAAU,CACxC,CAEA,eACE,CAA4E,CAC5E,CAA4B,CAF9B,CAKE,OAAO,IAAI,EAA6B,IAAI,CAD5B,IAAI,CAAC,WAAW,CAAC,EAAS,MACa,EACzD,CAEA,SAAc,CAAY,CAAE,CAA6B,CAAzD,CACE,IAAM,MAEE,IADN,EAAc,GACJ,EACA,IAAI,CAAC,OAAO,CAAI,CAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAQ,EAAK,UAAU,CAAC,KAAO,EAAK,KAAK,CAAC,GAAK,CAAA,GAE3F,EAAe,IAAI,CAAC,YAAY,GAStC,OARK,EAAW,IACd,CAAA,EAAQ,CAAE,GAAG,CAAY,CAAE,GAAG,CAAK,AAAA,CAAA,EAGhB,UAAjB,OAAO,GAAsB,GAAS,CAAC,MAAM,OAAO,CAAC,IACvD,CAAA,EAAI,MAAM,CAAG,IAAI,CAAC,cAAc,CAAC,EADnC,EAIO,EAAI,QAAQ,EACrB,CAEU,eAAe,CAA8B,CAA7C,CACR,OAAO,OAAO,OAAO,CAAC,GACnB,MAAM,CAAC,CAAC,CAAC,EAAG,EAAM,GAAK,AAAiB,KAAA,IAAV,GAC9B,GAAG,CAAC,CAAC,CAAC,EAAK,EAAM,IAChB,GAAI,AAAiB,UAAjB,OAAO,GAAsB,AAAiB,UAAjB,OAAO,GAAsB,AAAiB,WAAjB,OAAO,EACnE,MAAO,CAAA,EAAG,mBAAmB,GAAI,CAAA,EAAI,mBAAmB,GAAM,CAAE,CAElE,GAAI,AAAU,OAAV,EACF,MAAO,CAAA,EAAG,mBAAmB,GAAI,CAAA,CAAG,AAEtC,OAAM,IAAI,EAAA,WAAA,CACR,CAAA,sBAAA,EAAyB,OAAO,EAAK,iQAAA,CAAmQ,CAE5S,GACC,IAAI,CAAC,IACV,CAEA,MAAM,iBACJ,CAAgB,CAChB,CAA6B,CAC7B,CAAU,CACV,CAA2B,CAJ7B,CAME,GAAM,CAAA,OAAE,CAAM,CAAE,GAAG,EAAS,CAAG,GAAQ,CAAA,EACnC,GAAQ,EAAO,gBAAgB,CAAC,QAAS,IAAM,EAAW,KAAK,IAEnE,IAAM,EAAU,WAAW,IAAM,EAAW,KAAK,GAAI,GAErD,OACE,IAAI,CAAC,gBAAgB,GAElB,KAAK,CAAC,IAAI,CAAC,KAAA,EAAW,EAAK,CAAE,OAAQ,EAAW,MAAa,CAAE,GAAG,CAAO,AAAA,GACzE,OAAO,CAAC,KACP,aAAa,EACf,EAEN,CAEU,kBAAA,CACR,MAAO,CAAE,MAAO,IAAI,CAAC,KAAK,AAAA,CAC5B,CAEQ,YAAY,CAAkB,CAA9B,CAEN,IAAM,EAAoB,EAAS,OAAO,CAAC,GAAG,CAAC,wBAG/C,AAA0B,SAAtB,GACsB,UAAtB,IAGoB,MAApB,EAAS,MAAM,EAGf,AAAoB,MAApB,EAAS,MAAM,EAGf,AAAoB,MAApB,EAAS,MAAM,EAGf,EAAS,MAAM,EAAI,IAGzB,CAEQ,MAAM,aACZ,CAA4B,CAC5B,CAAwB,CACxB,CAAqC,CAH/B,KAKF,EAGJ,IAAM,EAAyB,GAAiB,CAAC,iBAAiB,CAClE,GAAI,EAAwB,CAC1B,IAAM,EAAY,WAAW,GACxB,OAAO,KAAK,CAAC,IAChB,CAAA,EAAgB,CADlB,CAGD,CAGD,IAAM,EAAmB,GAAiB,CAAC,cAAc,CACzD,GAAI,GAAoB,CAAC,EAAe,CACtC,IAAM,EAAiB,WAAW,GAIhC,EAHG,OAAO,KAAK,CAAC,GAGA,KAAK,KAAK,CAAC,GAAoB,KAAK,GAAG,GAFvC,AAAiB,IAAjB,CAInB,CAID,GAAI,CAAE,CAAA,GAAiB,GAAK,GAAiB,EAAgB,GAAA,EAAY,CACvE,IAAM,EAAa,EAAQ,UAAU,EAAI,IAAI,CAAC,UAAU,CACxD,EAAgB,IAAI,CAAC,kCAAkC,CAAC,EAAkB,EAC3E,CAGD,OAFA,MAAM,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,KAAA,AAAA,EAAM,GAEL,IAAI,CAAC,WAAW,CAAC,EAAS,EAAmB,EACtD,CAEQ,mCAAmC,CAAwB,CAAE,CAAkB,CAA/E,CAYN,OAAO,AALc,KAAK,GAAG,CAAC,AANJ,GAMwB,KAAK,GAAG,CAAC,EAHxC,EAAa,GAFV,GAQP,CAAA,EAAI,AAAgB,IAAhB,KAAK,MAAM,EAA9B,EAE+B,GACjC,CAEQ,cAAA,CACN,MAAO,CAAA,EAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAA,IAAA,EAAO,EAAA,OAAA,CAAO,CAAE,AACjD,CACD,CAID,OAAsB,EAOpB,YAAY,CAAiB,CAAE,CAAkB,CAAE,CAAa,CAAE,CAA4B,CAA9F,CANA,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GAOE,EAAA,IAAI,CAAA,EAAW,EAAM,KACrB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,IAAI,CAAG,CACd,CAUA,aAAA,OAEE,EAAK,AADS,IAAI,CAAC,iBAAiB,GACzB,MAAM,EACV,AAAuB,MAAvB,IAAI,CAAC,YAAY,EAC1B,CAEA,MAAM,aAAN,CACE,IAAM,EAAW,IAAI,CAAC,YAAY,GAClC,GAAI,CAAC,EACH,MAAM,IAAI,EAAA,WAAA,CACR,yFAGJ,IAAM,EAAc,CAAE,GAAG,IAAI,CAAC,OAAO,AAAA,EACrC,GAAI,WAAY,GAAY,AAA6B,UAA7B,OAAO,EAAY,KAAK,CAClD,EAAY,KAAK,CAAG,CAAE,GAAG,EAAY,KAAK,CAAE,GAAG,EAAS,MAAM,AAAA,OACzD,GAAI,QAAS,EAAU,CAE5B,IAAK,GAAM,CAAC,EAAK,EAAM,EADR,IAAI,OAAO,OAAO,CAAC,EAAY,KAAK,EAAI,CAAA,MAAQ,EAAS,GAAG,CAAC,YAAY,CAAC,OAAO,GAAG,CAEjG,EAAS,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,EAAK,EAErC,CAAA,EAAY,KAAK,CAAG,KAAA,EACpB,EAAY,IAAI,CAAG,EAAS,GAAG,CAAC,QAAQ,EACzC,CACD,OAAO,MAAM,EAAA,IAAI,CAAA,EAAA,KAAS,cAAc,CAAC,IAAI,CAAC,WAAkB,CAAE,EACpE,CAEA,OAAO,WAAP,CAEE,IAAI,EAA2B,IAAI,CAEnC,IADA,MAAM,EACC,EAAK,WAAW,IACrB,EAAO,MAAM,EAAK,WAAW,GAC7B,MAAM,CAEV,CAEA,OAAO,CAAA,CAAA,EAAA,IAAA,QAAC,OAAO,aAAA,AAAA,EAAc,EAA7B,CACE,UAAW,IAAM,KAAQ,IAAI,CAAC,SAAS,GACrC,IAAK,IAAM,KAAQ,EAAK,iBAAiB,GACvC,MAAM,CAGZ,CACD,CAlED,EAAA,OAAA,CAAA,YAAA,CAAA,CA6EA,OAAa,UAIH,EAGR,YACE,CAAiB,CACjB,CAAkC,CAClC,CAA4E,CAH9E,CAKE,KAAK,CACH,EACA,MAAO,GACL,IAAI,EACF,EACA,EAAM,QAAQ,CACd,MAAM,EAAqB,GAC3B,EAAM,OAAO,EAGrB,CASA,OAAO,CAAC,OAAO,aAAa,CAAC,EAA7B,CAEE,UAAW,IAAM,IADJ,CAAA,MAAM,IAAI,AAAJ,EAEjB,MAAM,CAEV,CACD,CArCD,EAAA,OAAA,CAAA,WAAA,CAAA,EAuCa,EAAA,OAAA,CAAA,qBAAqB,CAAG,AACnC,GAEO,IAAI,MACT,OAAO,WAAW,CAEhB,EAAQ,OAAO,IAEjB,CACE,IAAI,CAAM,CAAE,CAAI,EACd,IAAM,EAAM,EAAK,QAAQ,GACzB,OAAO,CAAM,CAAC,EAAI,WAAW,GAAG,EAAI,CAAM,CAAC,EAAI,AACjD,CACD,GAmCL,IAAM,EAA+C,CACnD,OAAQ,CAAA,EACR,KAAM,CAAA,EACN,MAAO,CAAA,EACP,KAAM,CAAA,EACN,QAAS,CAAA,EAET,WAAY,CAAA,EACZ,OAAQ,CAAA,EACR,QAAS,CAAA,EACT,UAAW,CAAA,EACX,OAAQ,CAAA,EACR,eAAgB,CAAA,EAEhB,gBAAiB,CAAA,EACjB,iBAAkB,CAAA,EAClB,cAAe,CAAA,CAChB,CAEY,CAAA,EAAA,OAAA,CAAA,gBAAgB,CAAG,AAAC,GAE7B,AAAe,UAAf,OAAO,GACP,AAAQ,OAAR,GACA,CAAC,EAAW,IACZ,OAAO,IAAI,CAAC,GAAK,KAAK,CAAC,AAAC,GAAM,EAAO,EAAoB,IAgC7D,IAAM,EAAwB,KAC5B,GAAI,AAAgB,aAAhB,OAAO,MAAwB,AAAc,MAAd,KAAK,KAAK,CAC3C,MAAO,CACL,mBAAoB,KACpB,8BAA+B,EAA/B,OAAA,CACA,iBAAkB,EAAkB,KAAK,KAAK,CAAC,EAAE,EACjD,mBAAoB,EAAc,KAAK,KAAK,CAAC,IAAI,EACjD,sBAAuB,OACvB,8BACE,AAAwB,UAAxB,OAAO,KAAK,OAAO,CAAgB,KAAK,OAAO,CAAG,KAAK,OAAO,EAAE,MAAQ,SAC3E,EAEH,GAAI,AAAuB,aAAvB,OAAO,YACT,MAAO,CACL,mBAAoB,KACpB,8BAA+B,EAA/B,OAAA,CACA,iBAAkB,UAClB,mBAAoB,CAAA,MAAA,EAAS,YAAW,CAAE,CAC1C,sBAAuB,OACvB,8BAA+B,EAAQ,OAAO,AAC/C,EAGH,GAAI,AAAiF,qBAAjF,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,AAAmB,KAAA,IAAZ,EAA0B,EAAU,GAC5E,MAAO,CACL,mBAAoB,KACpB,8BAA+B,EAA/B,OAAA,CACA,iBAAkB,EAAkB,EAAQ,QAAQ,EACpD,mBAAoB,EAAc,EAAQ,IAAI,EAC9C,sBAAuB,OACvB,8BAA+B,EAAQ,OAAO,AAC/C,EAGH,IAAM,EAAc,AA+BtB,WACE,GAAI,AAAqB,aAArB,OAAO,WAA6B,CAAC,UACvC,OAAO,KAcT,IAAK,GAAM,CAAA,IAAE,CAAG,CAAA,QAAE,CAAO,CAAE,EAVH,CACtB,CAAE,IAAK,OAAiB,QAAS,sCAAsC,EACvE,CAAE,IAAK,KAAe,QAAS,sCAAsC,EACrE,CAAE,IAAK,KAAe,QAAS,4CAA4C,EAC3E,CAAE,IAAK,SAAmB,QAAS,wCAAwC,EAC3E,CAAE,IAAK,UAAoB,QAAS,yCAAyC,EAC7E,CAAE,IAAK,SAAmB,QAAS,mEAAmE,EACvG,CAG+C,CAC9C,IAAM,EAAQ,EAAQ,IAAI,CAAC,UAAU,SAAS,EAC9C,GAAI,EAAO,CACT,IAAM,EAAQ,CAAK,CAAC,EAAE,EAAI,EACpB,EAAQ,CAAK,CAAC,EAAE,EAAI,EACpB,EAAQ,CAAK,CAAC,EAAE,EAAI,EAE1B,MAAO,CAAE,QAAS,EAAK,QAAS,CAAA,EAAG,EAAK,CAAA,EAAI,EAAK,CAAA,EAAI,EAAK,CAAE,AAAA,CAC7D,CACF,CAED,OAAO,IACT,WA1DE,AAAI,EACK,CACL,mBAAoB,KACpB,8BAA+B,EAA/B,OAAA,CACA,iBAAkB,UAClB,mBAAoB,UACpB,sBAAuB,CAAA,QAAA,EAAW,EAAY,OAAO,CAAA,CAAE,CACvD,8BAA+B,EAAY,OAAO,AACnD,EAII,CACL,mBAAoB,KACpB,8BAA+B,EAA/B,OAAA,CACA,iBAAkB,UAClB,mBAAoB,UACpB,sBAAuB,UACvB,8BAA+B,SAChC,CACH,EAwCM,EAAgB,AAAC,GAKrB,AAAI,AAAS,QAAT,EAAuB,MACvB,AAAS,WAAT,GAAqB,AAAS,QAAT,EAAuB,MAC5C,AAAS,QAAT,EAAuB,MACvB,AAAS,YAAT,GAAsB,AAAS,UAAT,EAAyB,QAC/C,EAAa,CAAA,MAAA,EAAS,EAAI,CAAE,CACzB,UAGH,EAAoB,AAAC,GAazB,AAAI,AANJ,CAAA,EAAW,EAAS,WAAW,EAA/B,EAMa,QAAQ,CAAC,OAAe,MACjC,AAAa,YAAb,EAA+B,UAC/B,AAAa,WAAb,EAA8B,QAC9B,AAAa,UAAb,EAA6B,UAC7B,AAAa,YAAb,EAA+B,UAC/B,AAAa,YAAb,EAA+B,UAC/B,AAAa,UAAb,EAA6B,QAC7B,EAAiB,CAAA,MAAA,EAAS,EAAQ,CAAE,CACjC,UAIH,EAAqB,IACjB,GAAA,CAAA,EAAqB,GAAA,CAGlB,CAAA,EAAA,OAAA,CAAA,QAAQ,CAAG,AAAC,IACvB,GAAI,CACF,OAAO,KAAK,KAAK,CAAC,EACnB,CAAC,MAAO,EAAK,CACZ,MACD,CACH,EAGA,IAAM,EAAyB,AAAI,OAAO,kBAAmB,KACvD,EAAgB,AAAC,GACd,EAAuB,IAAI,CAAC,EAGxB,CAAA,EAAA,OAAA,CAAA,KAAK,CAAG,AAAC,GAAe,IAAI,QAAQ,AAAC,GAAY,WAAW,EAAS,IAElF,IAAM,EAA0B,CAAC,EAAc,KAC7C,GAAI,AAAa,UAAb,OAAO,GAAkB,CAAC,OAAO,SAAS,CAAC,GAC7C,MAAM,IAAI,EAAA,WAAA,CAAY,CAAA,EAAG,EAAI,mBAAA,CAAqB,EAEpD,GAAI,EAAI,EACN,MAAM,IAAI,EAAA,WAAA,CAAY,CAAA,EAAG,EAAI,2BAAA,CAA6B,EAE5D,OAAO,CACT,EA4EA,SAAgB,EAAW,CAA8B,EACvD,GAAI,CAAC,EAAK,MAAO,CAAA,EACjB,IAAK,IAAM,KAAM,EAAK,MAAO,CAAA,EAC7B,MAAO,CAAA,CACT,CAGA,SAAgB,EAAO,CAAW,CAAE,CAAW,EAC7C,OAAO,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAK,EACnD,CAQA,SAAS,EAAgB,CAAsB,CAAE,CAAmB,EAClE,IAAK,IAAM,KAAK,EAAY,CAC1B,GAAI,CAAC,EAAO,EAAY,GAAI,SAC5B,IAAM,EAAW,EAAE,WAAW,GAC9B,GAAI,CAAC,EAAU,SAEf,IAAM,EAAM,CAAU,CAAC,EAAE,AAErB,AAAQ,QAAR,EACF,OAAO,CAAa,CAAC,EAAS,CACb,KAAA,IAAR,GACT,CAAA,CAAa,CAAC,EAAS,CAAG,CADrB,CAGR,CACH,CAEA,SAAgB,EAAM,CAAc,CAAE,GAAG,CAAW,EAC3B,KAAA,IAAZ,GAA2B,GAAS,KAAM,QAAa,QAChE,QAAQ,GAAG,CAAC,CAAA,aAAA,EAAgB,EAAM,CAAE,IAAK,EAE7C,CA/Ga,EAAA,OAAA,CAAA,WAAW,CAAG,AAAC,IAC1B,GAAI,aAAe,MAAO,OAAO,EACjC,GAAI,AAAe,UAAf,OAAO,GAAoB,AAAQ,OAAR,EAC7B,GAAI,CACF,OAAO,AAAI,MAAM,KAAK,SAAS,CAAC,GACjC,CAAC,KAAM,CAAA,CAEV,OAAO,AAAI,MAAM,EACnB,EAEa,EAAA,OAAA,CAAA,aAAa,CAAG,AAAI,IAC/B,GAAI,AAAS,MAAT,EAAe,MAAM,IAAI,EAAA,WAAA,CAAY,CAAA,0CAAA,EAA6C,EAAK,SAAA,CAAW,EACtG,OAAO,CACT,EASa,EAAA,OAAA,CAAA,OAAO,CAAG,AAAC,GACtB,AAAI,AAAmB,KAAA,IAAZ,EACF,EAAQ,GAAG,EAAE,CAAC,EAAI,EAAE,QAAU,KAAA,EAEnC,AAAgB,aAAhB,OAAO,KACF,KAAK,GAAG,EAAE,MAAM,IAAM,cAKpB,EAAA,OAAA,CAAA,aAAa,CAAG,AAAC,IAC5B,GAAI,AAAiB,UAAjB,OAAO,EAAoB,OAAO,KAAK,KAAK,CAAC,GACjD,GAAI,AAAiB,UAAjB,OAAO,EAAoB,OAAO,SAAS,EAAO,GAEtD,OAAM,IAAI,EAAA,WAAA,CAAY,CAAA,iBAAA,EAAoB,EAAK,QAAA,EAAW,OAAO,EAAK,eAAA,CAAiB,CACzF,EAEa,EAAA,OAAA,CAAA,WAAW,CAAG,AAAC,IAC1B,GAAI,AAAiB,UAAjB,OAAO,EAAoB,OAAO,EACtC,GAAI,AAAiB,UAAjB,OAAO,EAAoB,OAAO,WAAW,EAEjD,OAAM,IAAI,EAAA,WAAA,CAAY,CAAA,iBAAA,EAAoB,EAAK,QAAA,EAAW,OAAO,EAAK,eAAA,CAAiB,CACzF,EAEa,EAAA,OAAA,CAAA,aAAa,CAAG,AAAC,GAC5B,AAAI,AAAiB,WAAjB,OAAO,EAA4B,EACnC,AAAiB,UAAjB,OAAO,EAA2B,AAAU,SAAV,EAC/B,CAAA,CAAQ,EAGJ,EAAA,OAAA,CAAA,kBAAkB,CAAG,AAAC,IACjC,GAAI,AAAU,KAAA,IAAV,EAGJ,MAAO,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,aAAA,AAAA,EAAc,EACvB,EAEa,EAAA,OAAA,CAAA,gBAAgB,CAAG,AAAC,IAC/B,GAAI,AAAU,KAAA,IAAV,EAGJ,MAAO,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,WAAA,AAAA,EAAY,EACrB,EAEa,EAAA,OAAA,CAAA,kBAAkB,CAAG,AAAC,IACjC,GAAI,AAAU,KAAA,IAAV,EAGJ,MAAO,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,aAAA,AAAA,EAAc,EACvB,EAGA,EAAA,OAAA,CAAA,UAAA,CAAA,EAOA,EAAA,OAAA,CAAA,MAAA,CAAA,EA0BA,EAAA,OAAA,CAAA,KAAA,CAAA,EASA,IAAM,EAAQ,IACL,uCAAuC,OAAO,CAAC,QAAS,AAAC,IAC9D,IAAM,EAAI,AAAiB,GAAjB,KAAM,MAAM,GAAW,EAEjC,MAAO,AADG,CAAA,AAAM,MAAN,EAAY,EAAK,AAAI,EAAJ,EAAW,CAAtC,EACS,QAAQ,CAAC,GACpB,EAGW,CAAA,EAAA,OAAA,CAAA,kBAAkB,CAAG,IAG9B,AAAkB,aAAlB,OAAO,QAEP,AAA2B,KAAA,IAApB,OAAO,QAAQ,EAEtB,AAAqB,aAArB,OAAO,UASE,EAAA,OAAA,CAAA,iBAAiB,CAAG,AAAC,GACzB,AAAwB,YAAxB,OAAO,GAAS,IAGZ,EAAA,OAAA,CAAA,iBAAiB,CAAG,CAAC,EAAgC,KAChE,IAAM,EAAc,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,SAAA,AAAA,EAAU,EAAS,GACvC,GAAI,AAAgB,KAAA,IAAhB,EACF,MAAM,AAAI,MAAM,CAAA,eAAA,EAAkB,EAAM,OAAA,CAAS,EAEnD,OAAO,CACT,EAEa,EAAA,OAAA,CAAA,SAAS,CAAG,CAAC,EAAgC,KACxD,IAAM,EAAmB,EAAO,WAAW,GAC3C,GAAI,AAAA,CAAA,EAAA,EAAA,OAAA,CAAA,iBAAA,AAAA,EAAkB,GAAU,CAE9B,IAAM,EACJ,CAAM,CAAC,EAAE,EAAE,cACX,EAAO,SAAS,CAAC,GAAG,OAAO,CAAC,eAAgB,CAAC,EAAI,EAAI,IAAO,EAAK,EAAG,WAAW,IACjF,IAAK,IAAM,IAAO,CAAC,EAAQ,EAAkB,EAAO,WAAW,GAAI,EAAgB,CAAE,CACnF,IAAM,EAAQ,EAAQ,GAAG,CAAC,GAC1B,GAAI,EACF,OAAO,CAEV,CACF,CAED,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GACxC,GAAI,EAAI,WAAW,KAAO,EAAkB,CAC1C,GAAI,MAAM,OAAO,CAAC,GAAQ,CACxB,GAAI,EAAM,MAAM,EAAI,EAAG,OAAO,CAAK,CAAC,EAAE,CAEtC,OADA,QAAQ,IAAI,CAAC,CAAA,SAAA,EAAY,EAAM,MAAM,CAAA,iBAAA,EAAoB,EAAM,+BAAA,CAAiC,EACzF,CAAK,CAAC,EAAE,AAChB,CACD,OAAO,CACR,CAIL,EAKa,EAAA,OAAA,CAAA,QAAQ,CAAG,AAAC,IACvB,GAAI,CAAC,EAAK,MAAO,GACjB,GAAI,AAAkB,KAAA,IAAlB,EACF,OAAO,EAAO,IAAI,CAAC,GAAK,QAAQ,CAAC,UAGnC,GAAI,AAAgB,aAAhB,OAAO,KACT,OAAO,KAAK,EAGd,OAAM,IAAI,EAAA,WAAA,CAAY,wEACxB,EAEA,EAAA,OAAA,CAAA,KAAA,CAAA,SAAsB,CAAY,EAChC,OAAO,AAAO,MAAP,GAAe,AAAe,UAAf,OAAO,GAAoB,CAAC,MAAM,OAAO,CAAC,EAClE,C,G,E,Q,S,C,C,C,E,E,E,O,C,S,I,E,A,G,E,G,E,E,O,C,oB,I,E,A,G,E,G,ICjsCA,EAEA,E,E,E,S,E,E,SAPA,IAAM,EACH,AAAkB,YAAlB,OAAO,QAAyB,AAAyB,YAAzB,OAAO,OAAO,GAAM,CACjD,OAAO,GAAM,CAAC,8BACd,KA8DN,SAAS,EAAc,CAAM,EAC3B,GAAI,EAzDe,WA0DjB,MAAM,AAAI,WAAW,cAAgB,EAAS,kCAGhD,IAAM,EAAM,IAAI,WAAW,GAE3B,OADA,OAAO,cAAc,CAAC,EAAK,EAAO,SAAS,EACpC,CACT,CAYA,SAAS,EAAQ,CAAG,CAAE,CAAgB,CAAE,CAAM,EAE5C,GAAI,AAAe,UAAf,OAAO,EAAkB,CAC3B,GAAI,AAA4B,UAA5B,OAAO,EACT,MAAM,AAAI,UACR,sEAGJ,OAAO,EAAY,EACrB,CACA,OAAO,EAAK,EAAK,EAAkB,EACrC,CAIA,SAAS,EAAM,CAAK,CAAE,CAAgB,CAAE,CAAM,EAC5C,GAAI,AAAiB,UAAjB,OAAO,EACT,OAAO,AAqHX,SAAqB,CAAM,CAAE,CAAQ,EAKnC,GAJI,CAAA,AAAoB,UAApB,OAAO,GAAyB,AAAa,KAAb,CAAa,GAC/C,CAAA,EAAW,MADb,EAII,CAAC,EAAO,UAAU,CAAC,GACrB,MAAM,AAAI,UAAU,qBAAuB,GAG7C,IAAM,EAAS,AAA+B,EAA/B,EAAW,EAAQ,GAC9B,EAAM,EAAa,GAEjB,EAAS,EAAI,KAAK,CAAC,EAAQ,GASjC,OAPI,IAAW,GAIb,CAAA,EAAM,EAAI,KAAK,CAAC,EAAG,EAAnB,EAGK,CACT,EA3IsB,EAAO,GAG3B,GAAI,YAAY,MAAM,CAAC,GACrB,OAAO,AAkJX,SAAwB,CAAS,EAC/B,GAAI,EAAW,EAAW,YAAa,CACrC,IAAM,EAAO,IAAI,WAAW,GAC5B,OAAO,EAAgB,EAAK,MAAM,CAAE,EAAK,UAAU,CAAE,EAAK,UAAU,CACtE,CACA,OAAO,EAAc,EACvB,EAxJyB,GAGvB,GAAI,AAAS,MAAT,EACF,MAAM,AAAI,UACR,kHAC0C,OAAO,GAIrD,GAAI,EAAW,EAAO,cACjB,GAAS,EAAW,EAAM,MAAM,CAAE,cAInC,AAA6B,aAA7B,OAAO,mBACN,CAAA,EAAW,EAAO,oBAClB,GAAS,EAAW,EAAM,MAAM,CAAE,kBAAA,EALrC,OAAO,EAAgB,EAAO,EAAkB,GASlD,GAAI,AAAiB,UAAjB,OAAO,EACT,MAAM,AAAI,UACR,yEAIJ,IAAM,EAAU,EAAM,OAAO,EAAI,EAAM,OAAO,GAC9C,GAAI,AAAW,MAAX,GAAmB,IAAY,EACjC,OAAO,EAAO,IAAI,CAAC,EAAS,EAAkB,GAGhD,IAAM,EAAI,AAkJZ,SAAqB,CAAG,MAuvDF,EAtvDpB,GAAI,EAAO,QAAQ,CAAC,GAAM,CACxB,IAAM,EAAM,AAAsB,EAAtB,EAAQ,EAAI,MAAM,EACxB,EAAM,EAAa,UAEN,IAAf,EAAI,MAAM,EAId,EAAI,IAAI,CAAC,EAAK,EAAG,EAAG,GAHX,CAKX,QAEA,AAAI,AAAe,KAAA,IAAf,EAAI,MAAM,CACZ,AAAI,AAAsB,UAAtB,OAAO,EAAI,MAAM,EA2uDhB,CAFa,EAzuDgC,EAAI,MAAM,GA2uD/C,EA1uDJ,EAAa,GAEf,EAAc,GAGnB,AAAa,WAAb,EAAI,IAAI,EAAiB,MAAM,OAAO,CAAC,EAAI,IAAI,EAC1C,EAAc,EAAI,IAAI,QAEjC,EAzKuB,GACrB,GAAI,EAAG,OAAO,EAEd,GAAI,AAAkB,aAAlB,OAAO,QAA0B,AAAsB,MAAtB,OAAO,WAAW,EACnD,AAAqC,YAArC,OAAO,CAAK,CAAC,OAAO,WAAW,CAAC,CAClC,OAAO,EAAO,IAAI,CAAC,CAAK,CAAC,OAAO,WAAW,CAAC,CAAC,UAAW,EAAkB,EAG5E,OAAM,AAAI,UACR,kHAC0C,OAAO,EAErD,CAmBA,SAAS,EAAY,CAAI,EACvB,GAAI,AAAgB,UAAhB,OAAO,EACT,MAAM,AAAI,UAAU,0CACf,GAAI,EAAO,EAChB,MAAM,AAAI,WAAW,cAAgB,EAAO,iCAEhD,CA0BA,SAAS,EAAa,CAAI,EAExB,OADA,EAAW,GACJ,EAAa,EAAO,EAAI,EAAI,AAAgB,EAAhB,EAAQ,GAC7C,CAuCA,SAAS,EAAe,CAAK,EAC3B,IAAM,EAAS,EAAM,MAAM,CAAG,EAAI,EAAI,AAAwB,EAAxB,EAAQ,EAAM,MAAM,EACpD,EAAM,EAAa,GACzB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,GAAK,EAC/B,CAAG,CAAC,EAAE,CAAG,AAAW,IAAX,CAAK,CAAC,EAAE,CAEnB,OAAO,CACT,CAUA,SAAS,EAAiB,CAAK,CAAE,CAAU,CAAE,CAAM,MAS7C,EARJ,GAAI,EAAa,GAAK,EAAM,UAAU,CAAG,EACvC,MAAM,AAAI,WAAW,wCAGvB,GAAI,EAAM,UAAU,CAAG,EAAc,CAAA,GAAU,CAAA,EAC7C,MAAM,AAAI,WAAW,wCAevB,OAFA,OAAO,cAAc,CARnB,EADE,AAAe,KAAA,IAAf,GAA4B,AAAW,KAAA,IAAX,EACxB,IAAI,WAAW,GACZ,AAAW,KAAA,IAAX,EACH,IAAI,WAAW,EAAO,GAEtB,IAAI,WAAW,EAAO,EAAY,GAIf,EAAO,SAAS,EAEpC,CACT,CA2BA,SAAS,EAAS,CAAM,EAGtB,GAAI,GA/Se,WAgTjB,MAAM,AAAI,WAAW,yEAGvB,OAAO,AAAS,EAAT,CACT,CAsGA,SAAS,EAAY,CAAM,CAAE,CAAQ,EACnC,GAAI,EAAO,QAAQ,CAAC,GAClB,OAAO,EAAO,MAAM,CAEtB,GAAI,YAAY,MAAM,CAAC,IAAW,EAAW,EAAQ,aACnD,OAAO,EAAO,UAAU,CAE1B,GAAI,AAAkB,UAAlB,OAAO,EACT,MAAM,AAAI,UACR,2FACmB,OAAO,GAI9B,IAAM,EAAM,EAAO,MAAM,CACnB,EAAa,UAAU,MAAM,CAAG,GAAK,AAAiB,CAAA,IAAjB,SAAS,CAAC,EAAE,CACvD,GAAI,CAAC,GAAa,AAAQ,IAAR,EAAW,OAAO,EAGpC,IAAI,EAAc,CAAA,EAClB,OACE,OAAQ,GACN,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAO,CACT,KAAK,OACL,IAAK,QACH,OAAO,EAAY,GAAQ,MAAM,AACnC,KAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAO,AAAM,EAAN,CACT,KAAK,MACH,OAAO,IAAQ,CACjB,KAAK,SACH,OAAO,EAAc,GAAQ,MAAM,AACrC,SACE,GAAI,EACF,OAAO,EAAY,GAAK,EAAY,GAAQ,MAAM,CAEpD,EAAY,AAAA,CAAA,GAAK,CAAA,EAAU,WAAW,GACtC,EAAc,CAAA,CAClB,CAEJ,CAGA,SAAS,EAAc,CAAQ,CAAE,CAAK,CAAE,CAAG,EACzC,IAAI,EAAc,CAAA,EAclB,GALI,CAAA,AAAU,KAAA,IAAV,GAAuB,EAAQ,CAAA,GACjC,CAAA,EAAQ,CAAA,EAIN,EAAQ,IAAI,CAAC,MAAM,GAInB,CAAA,AAAQ,KAAA,IAAR,GAAqB,EAAM,IAAI,CAAC,MAAM,AAAN,GAClC,CAAA,EAAM,IAAI,CAAC,MAAM,AAAN,EAGT,GAAO,GAQP,AAHJ,CAAA,KAAS,CAAA,GACT,CAAA,KAAW,CAAA,GAbT,MAAO,GAqBT,IAFK,GAAU,CAAA,EAAW,MAA1B,IAGE,OAAQ,GACN,IAAK,MACH,OAAO,AAsiBf,SAAmB,CAAG,CAAE,CAAK,CAAE,CAAG,EAChC,IAAM,EAAM,EAAI,MAAM,CAElB,CAAA,CAAC,GAAS,EAAQ,CAAA,GAAG,CAAA,EAAQ,CAAA,EAC7B,CAAA,CAAC,GAAO,EAAM,GAAK,EAAM,CAAA,GAAK,CAAA,EAAM,CAAxC,EAEA,IAAI,EAAM,GACV,IAAK,IAAI,EAAI,EAAO,EAAI,EAAK,EAAE,EAC7B,GAAO,CAAmB,CAAC,CAAG,CAAC,EAAE,CAAC,CAEpC,OAAO,CACT,EAjjBwB,IAAI,CAAE,EAAO,EAE/B,KAAK,OACL,IAAK,QACH,OAAO,EAAU,IAAI,CAAE,EAAO,EAEhC,KAAK,QACH,OAAO,AA2gBf,SAAqB,CAAG,CAAE,CAAK,CAAE,CAAG,EAClC,IAAI,EAAM,GACV,EAAM,KAAK,GAAG,CAAC,EAAI,MAAM,CAAE,GAE3B,IAAK,IAAI,EAAI,EAAO,EAAI,EAAK,EAAE,EAC7B,GAAO,OAAO,YAAY,CAAC,AAAS,IAAT,CAAG,CAAC,EAAE,EAEnC,OAAO,CACT,EAnhB0B,IAAI,CAAE,EAAO,EAEjC,KAAK,SACL,IAAK,SACH,OAAO,AAihBf,SAAsB,CAAG,CAAE,CAAK,CAAE,CAAG,EACnC,IAAI,EAAM,GACV,EAAM,KAAK,GAAG,CAAC,EAAI,MAAM,CAAE,GAE3B,IAAK,IAAI,EAAI,EAAO,EAAI,EAAK,EAAE,EAC7B,GAAO,OAAO,YAAY,CAAC,CAAG,CAAC,EAAE,EAEnC,OAAO,CACT,EAzhB2B,IAAI,CAAE,EAAO,EAElC,KAAK,aA0ZgB,EAAO,EAzZ1B,OAyZmB,EAzZM,EAyZC,EAzZM,EA0ZtC,AAAI,AAAU,IAAV,GAAe,IAAQ,AA1ZF,IAAI,CA0ZE,MAAM,CAC5B,EAAA,aAAA,CA3ZgB,IAAI,EA6ZpB,EAAA,aAAA,CAAqB,AA7ZL,IAAI,CA6ZK,KAAK,CAAC,EAAO,GA3Z3C,KAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAO,AA+hBf,SAAuB,CAAG,CAAE,CAAK,CAAE,CAAG,EACpC,IAAM,EAAQ,EAAI,KAAK,CAAC,EAAO,GAC3B,EAAM,GAEV,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAG,EAAG,GAAK,EACzC,GAAO,OAAO,YAAY,CAAC,CAAK,CAAC,EAAE,CAAI,AAAe,IAAf,CAAK,CAAC,EAAI,EAAE,EAErD,OAAO,CACT,EAviB4B,IAAI,CAAE,EAAO,EAEnC,SACE,GAAI,EAAa,MAAM,AAAI,UAAU,qBAAuB,GAC5D,EAAY,AAAA,CAAA,EAAW,EAAA,EAAI,WAAW,GACtC,EAAc,CAAA,CAClB,CAEJ,CAUA,SAAS,EAAM,CAAC,CAAE,CAAC,CAAE,CAAC,EACpB,IAAM,EAAI,CAAC,CAAC,EAAE,AACd,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,CACX,CAAC,CAAC,EAAE,CAAG,CACT,CA2IA,SAAS,EAAsB,CAAM,CAAE,CAAG,CAAE,CAAU,CAAE,CAAQ,CAAE,CAAG,MAk2C/C,EAh2CpB,GAAI,AAAkB,IAAlB,EAAO,MAAM,CAAQ,OAAO,GAmBhC,GAhBI,AAAsB,UAAtB,OAAO,GACT,EAAW,EACX,EAAa,GACJ,EAAa,WACtB,EAAa,WACJ,EAAa,aACtB,CAAA,EAAa,WADR,GAw1Ca,EAr1CpB,EAAa,CAAC,IAu1CC,GAp1Cb,CAAA,EAAa,EAAM,EAAK,EAAO,MAAM,CAAG,CAAA,EAItC,EAAa,GAAG,CAAA,EAAa,EAAO,MAAM,CAAG,CAAjD,EACI,GAAc,EAAO,MAAM,CAAE,CAC/B,GAAI,EAAK,OAAO,GACX,EAAa,EAAO,MAAM,CAAG,CACpC,MAAO,GAAI,EAAa,EAAG,CACzB,IAAI,EACC,OAAO,GADH,EAAa,CAExB,CAQA,GALmB,UAAf,OAAO,GACT,CAAA,EAAM,EAAO,IAAI,CAAC,EAAK,EADzB,EAKI,EAAO,QAAQ,CAAC,UAElB,AAAI,AAAe,IAAf,EAAI,MAAM,CACL,GAEF,EAAa,EAAQ,EAAK,EAAY,EAAU,GAClD,GAAI,AAAe,UAAf,OAAO,QAEhB,CADA,GAAY,IACR,AAAwC,YAAxC,OAAO,WAAW,SAAS,CAAC,OAAO,EACrC,AAAI,EACK,WAAW,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,EAAQ,EAAK,GAE/C,WAAW,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,EAAQ,EAAK,GAGvD,EAAa,EAAQ,CAAC,EAAI,CAAE,EAAY,EAAU,EAG3D,OAAM,AAAI,UAAU,uCACtB,CAEA,SAAS,EAAc,CAAG,CAAE,CAAG,CAAE,CAAU,CAAE,CAAQ,CAAE,CAAG,EACxD,IA0BI,EA1BA,EAAY,EACZ,EAAY,EAAI,MAAM,CACtB,EAAY,EAAI,MAAM,CAE1B,GAAI,AAAa,KAAA,IAAb,GAEE,CAAA,AAAa,SADjB,CAAA,EAAW,OAAO,GAAU,WAAW,EAAvC,GAC2B,AAAa,UAAb,GACvB,AAAa,YAAb,GAA0B,AAAa,aAAb,CAAa,EAAY,CACrD,GAAI,EAAI,MAAM,CAAG,GAAK,EAAI,MAAM,CAAG,EACjC,OAAO,GAET,EAAY,EACZ,GAAa,EACb,GAAa,EACb,GAAc,CAChB,CAGF,SAAS,EAAM,CAAG,CAAE,CAAC,SACnB,AAAI,AAAc,IAAd,EACK,CAAG,CAAC,EAAE,CAEN,EAAI,YAAY,CAAC,EAAI,EAEhC,CAGA,GAAI,EAAK,CACP,IAAI,EAAa,GACjB,IAAK,EAAI,EAAY,EAAI,EAAW,IAClC,GAAI,EAAK,EAAK,KAAO,EAAK,EAAK,AAAe,KAAf,EAAoB,EAAI,EAAI,GAEzD,CAAA,GADmB,KAAf,GAAmB,CAAA,EAAa,CAAA,EAChC,EAAI,EAAa,IAAM,EAAW,OAAO,EAAa,CAA1D,MAEmB,KAAf,GAAmB,CAAA,GAAK,EAAI,CAAhC,EACA,EAAa,EAGnB,MAEE,IADI,EAAa,EAAY,GAAW,CAAA,EAAa,EAAY,CAAjE,EACK,EAAI,EAAY,GAAK,EAAG,IAAK,CAChC,IAAI,EAAQ,CAAA,EACZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAW,IAC7B,GAAI,EAAK,EAAK,EAAI,KAAO,EAAK,EAAK,GAAI,CACrC,EAAQ,CAAA,EACR,KACF,CAEF,GAAI,EAAO,OAAO,CACpB,CAGF,OAAO,EACT,CA4IA,SAAS,EAAW,CAAG,CAAE,CAAK,CAAE,CAAG,EACjC,EAAM,KAAK,GAAG,CAAC,EAAI,MAAM,CAAE,GAC3B,IAAM,EAAM,EAAE,CAEV,EAAI,EACR,KAAO,EAAI,GAAK,CACd,IAAM,EAAY,CAAG,CAAC,EAAE,CACpB,EAAY,KACZ,EAAoB,EAAY,IAChC,EACC,EAAY,IACT,EACC,EAAY,IACT,EACA,EAEZ,GAAI,EAAI,GAAoB,EAAK,CAC/B,IAAI,EAAY,EAAW,EAAY,EAEvC,OAAQ,GACN,KAAK,EACC,EAAY,KACd,CAAA,EAAY,CADd,EAGA,KACF,MAAK,EAEE,CAAA,AAAa,IADlB,CAAA,EAAa,CAAG,CAAC,EAAI,EAAE,AAAF,CACH,GAAU,KAEtB,AADJ,CAAA,EAAiB,AAAA,CAAA,AAAY,GAAZ,CAAY,GAAS,EAAO,AAAa,GAAb,CAA7C,EACoB,KAClB,CAAA,EAAY,CADd,EAIF,KACF,MAAK,EACH,EAAa,CAAG,CAAC,EAAI,EAAE,CACvB,EAAY,CAAG,CAAC,EAAI,EAAE,CACjB,CAAA,AAAa,IAAb,CAAa,GAAU,KAAQ,AAAC,CAAA,AAAY,IAAZ,CAAY,GAAU,KAErD,AADJ,CAAA,EAAgB,AAAC,CAAA,AAAY,GAAZ,CAAY,GAAQ,GAAM,AAAC,CAAA,AAAa,GAAb,CAAa,GAAS,EAAO,AAAY,GAAZ,CAAzE,EACoB,MAAU,CAAA,EAAgB,OAAU,EAAgB,KAAA,GACtE,CAAA,EAAY,CADd,EAIF,KACF,MAAK,EACH,EAAa,CAAG,CAAC,EAAI,EAAE,CACvB,EAAY,CAAG,CAAC,EAAI,EAAE,CACtB,EAAa,CAAG,CAAC,EAAI,EAAE,CAClB,CAAA,AAAa,IAAb,CAAa,GAAU,KAAS,AAAA,CAAA,AAAY,IAAZ,CAAY,GAAU,KAAQ,AAAC,CAAA,AAAa,IAAb,CAAa,GAAU,KAErF,AADJ,CAAA,EAAiB,AAAA,CAAA,AAAY,GAAZ,CAAY,GAAQ,GAAQ,AAAA,CAAA,AAAa,GAAb,CAAa,GAAS,GAAM,AAAC,CAAA,AAAY,GAAZ,CAAY,GAAS,EAAO,AAAa,GAAb,CAAtG,EACoB,OAAU,EAAgB,SAC5C,CAAA,EAAY,CADd,CAIN,CACF,CAEI,AAAc,OAAd,GAGF,EAAY,MACZ,EAAmB,GACV,EAAY,QAErB,GAAa,MACb,EAAI,IAAI,CAAC,IAAc,GAAK,KAAQ,OACpC,EAAY,MAAS,AAAY,KAAZ,GAGvB,EAAI,IAAI,CAAC,GACT,GAAK,CACP,CAEA,OAAO,AAQT,SAAgC,CAAU,EACxC,IAAM,EAAM,EAAW,MAAM,CAC7B,GAAI,GAJuB,KAKzB,OAAO,OAAO,YAAY,CAAC,KAAK,CAAC,OAAQ,GAI3C,IAAI,EAAM,GACN,EAAI,EACR,KAAO,EAAI,GACT,GAAO,OAAO,YAAY,CAAC,KAAK,CAC9B,OACA,EAAW,KAAK,CAAC,EAAG,GAdG,OAiB3B,OAAO,CACT,EAxB+B,EAC/B,CAmGA,SAAS,EAAa,CAAM,CAAE,CAAG,CAAE,CAAM,EACvC,GAAK,EAAS,GAAO,GAAK,EAAS,EAAG,MAAM,AAAI,WAAW,sBAC3D,GAAI,EAAS,EAAM,EAAQ,MAAM,AAAI,WAAW,wCAClD,CAyQA,SAAS,EAAU,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAG,CAAE,CAAG,EAClD,GAAI,CAAC,EAAO,QAAQ,CAAC,GAAM,MAAM,AAAI,UAAU,+CAC/C,GAAI,EAAQ,GAAO,EAAQ,EAAK,MAAM,AAAI,WAAW,qCACrD,GAAI,EAAS,EAAM,EAAI,MAAM,CAAE,MAAM,AAAI,WAAW,qBACtD,CA+FA,SAAS,EAAgB,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAG,EACnD,EAAW,EAAO,EAAK,EAAK,EAAK,EAAQ,GAEzC,IAAI,EAAK,OAAO,EAAQ,OAAO,YAC/B,CAAA,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EAChB,IAAI,EAAK,OAAO,GAAS,OAAO,IAAM,OAAO,aAQ7C,OAPA,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EAChB,IAAW,EACX,CAAG,CAAC,IAAS,CAAG,EACT,CACT,CAEA,SAAS,EAAgB,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAG,EACnD,EAAW,EAAO,EAAK,EAAK,EAAK,EAAQ,GAEzC,IAAI,EAAK,OAAO,EAAQ,OAAO,YAC/B,CAAA,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAI,EAAK,OAAO,GAAS,OAAO,IAAM,OAAO,aAQ7C,OAPA,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAS,EAAE,CAAG,EAClB,IAAW,EACX,CAAG,CAAC,EAAO,CAAG,EACP,EAAS,CAClB,CAkHA,SAAS,EAAc,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAG,CAAE,CAAG,EACtD,GAAI,EAAS,EAAM,EAAI,MAAM,EACzB,EAAS,EADkB,MAAM,AAAI,WAAW,qBAEtD,CAEA,SAAS,EAAY,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAY,CAAE,CAAQ,EAO7D,OANA,EAAQ,CAAC,EACT,KAAoB,EACf,GACH,EAAa,EAAK,EAAO,EAAQ,EAAG,qBAAwB,uBAE9D,EAAA,KAAA,CAAc,EAAK,EAAO,EAAQ,EAAc,GAAI,GAC7C,EAAS,CAClB,CAUA,SAAS,EAAa,CAAG,CAAE,CAAK,CAAE,CAAM,CAAE,CAAY,CAAE,CAAQ,EAO9D,OANA,EAAQ,CAAC,EACT,KAAoB,EACf,GACH,EAAa,EAAK,EAAO,EAAQ,EAAG,sBAAyB,wBAE/D,EAAA,KAAA,CAAc,EAAK,EAAO,EAAQ,EAAc,GAAI,GAC7C,EAAS,CAClB,CA7nDA,EAAiB,EAEjB,EAA4B,GAmB5B,EAAO,mBAAmB,CAAG,AAU7B,WAEE,GAAI,CACF,IAAM,EAAM,IAAI,WAAW,GACrB,EAAQ,CAAE,IAAK,WAAc,OAAO,EAAG,CAAE,EAG/C,OAFA,OAAO,cAAc,CAAC,EAAO,WAAW,SAAS,EACjD,OAAO,cAAc,CAAC,EAAK,GACpB,AAAc,KAAd,EAAI,GAAG,EAChB,CAAE,MAAO,EAAG,CACV,MAAO,CAAA,CACT,CACF,IAnBK,EAAO,mBAAmB,EAAI,AAAmB,aAAnB,OAAO,SACtC,AAAyB,YAAzB,OAAO,QAAQ,KAAK,EACtB,QAAQ,KAAK,CACX,iJAkBJ,OAAO,cAAc,CAAC,EAAO,SAAS,CAAE,SAAU,CAChD,WAAY,CAAA,EACZ,IAAK,WACH,GAAK,EAAO,QAAQ,CAAC,IAAI,EACzB,OAAO,IAAI,CAAC,MAAM,AACpB,CACF,GAEA,OAAO,cAAc,CAAC,EAAO,SAAS,CAAE,SAAU,CAChD,WAAY,CAAA,EACZ,IAAK,WACH,GAAK,EAAO,QAAQ,CAAC,IAAI,EACzB,OAAO,IAAI,CAAC,UAAU,AACxB,CACF,GAmCA,EAAO,QAAQ,CAAG,KA8DlB,EAAO,IAAI,CAAG,SAAU,CAAK,CAAE,CAAgB,CAAE,CAAM,EACrD,OAAO,EAAK,EAAO,EAAkB,EACvC,EAIA,OAAO,cAAc,CAAC,EAAO,SAAS,CAAE,WAAW,SAAS,EAC5D,OAAO,cAAc,CAAC,EAAQ,YA8B9B,EAAO,KAAK,CAAG,SAAU,CAAI,CAAE,CAAI,CAAE,CAAQ,EAC3C,OApBA,EAoBa,GAnBT,AAmBS,GAnBD,GACH,EAkBI,GAhBT,AAAS,KAAA,IAgBM,EAZV,AAAoB,UAApB,OAYgB,EAXnB,EAWO,GAXY,IAAI,CAWV,EAAM,GAVnB,EAUO,GAVY,IAAI,CAUV,GARZ,EAQM,EACf,EAUA,EAAO,WAAW,CAAG,SAAU,CAAI,EACjC,OAAO,EAAY,EACrB,EAIA,EAAO,eAAe,CAAG,SAAU,CAAI,EACrC,OAAO,EAAY,EACrB,EA6GA,EAAO,QAAQ,CAAG,SAAmB,CAAC,EACpC,OAAO,AAAK,MAAL,GAAa,AAAgB,CAAA,IAAhB,EAAE,SAAS,EAC7B,IAAM,EAAO,SAAS,AAC1B,EAEA,EAAO,OAAO,CAAG,SAAkB,CAAC,CAAE,CAAC,EAGrC,GAFI,EAAW,EAAG,aAAa,CAAA,EAAI,EAAO,IAAI,CAAC,EAAG,EAAE,MAAM,CAAE,EAAE,UAAU,CAAA,EACpE,EAAW,EAAG,aAAa,CAAA,EAAI,EAAO,IAAI,CAAC,EAAG,EAAE,MAAM,CAAE,EAAE,UAAU,CAAA,EACpE,CAAC,EAAO,QAAQ,CAAC,IAAM,CAAC,EAAO,QAAQ,CAAC,GAC1C,MAAM,AAAI,UACR,yEAIJ,GAAI,IAAM,EAAG,OAAO,EAEpB,IAAI,EAAI,EAAE,MAAM,CACZ,EAAI,EAAE,MAAM,CAEhB,IAAK,IAAI,EAAI,EAAG,EAAM,KAAK,GAAG,CAAC,EAAG,GAAI,EAAI,EAAK,EAAE,EAC/C,GAAI,CAAC,CAAC,EAAE,GAAK,CAAC,CAAC,EAAE,CAAE,CACjB,EAAI,CAAC,CAAC,EAAE,CACR,EAAI,CAAC,CAAC,EAAE,CACR,KACF,QAGF,AAAI,EAAI,EAAU,GACd,EAAI,EAAU,EACX,CACT,EAEA,EAAO,UAAU,CAAG,SAAqB,CAAQ,EAC/C,OAAQ,OAAO,GAAU,WAAW,IAClC,IAAK,MACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,MAAO,CAAA,CACT,SACE,MAAO,CAAA,CACX,CACF,EAEA,EAAO,MAAM,CAAG,SAAiB,CAAI,CAAE,CAAM,MASvC,EARJ,GAAI,CAAC,MAAM,OAAO,CAAC,GACjB,MAAM,AAAI,UAAU,+CAGtB,GAAI,AAAgB,IAAhB,EAAK,MAAM,CACb,OAAO,EAAO,KAAK,CAAC,GAItB,GAAI,AAAW,KAAA,IAAX,EAEF,IAAK,EAAI,EADT,EAAS,EACG,EAAI,EAAK,MAAM,CAAE,EAAE,EAC7B,GAAU,CAAI,CAAC,EAAE,CAAC,MAAM,CAI5B,IAAM,EAAS,EAAO,WAAW,CAAC,GAC9B,EAAM,EACV,IAAK,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,EAAE,EAAG,CAChC,IAAI,EAAM,CAAI,CAAC,EAAE,CACjB,GAAI,EAAW,EAAK,YACd,EAAM,EAAI,MAAM,CAAG,EAAO,MAAM,EAC7B,EAAO,QAAQ,CAAC,IAAM,CAAA,EAAM,EAAO,IAAI,CAAC,EAA7C,EACA,EAAI,IAAI,CAAC,EAAQ,IAEjB,WAAW,SAAS,CAAC,GAAG,CAAC,IAAI,CAC3B,EACA,EACA,QAGC,GAAK,EAAO,QAAQ,CAAC,GAG1B,EAAI,IAAI,CAAC,EAAQ,QAFjB,MAAM,AAAI,UAAU,+CAItB,GAAO,EAAI,MAAM,AACnB,CACA,OAAO,CACT,EAiDA,EAAO,UAAU,CAAG,EA8EpB,EAAO,SAAS,CAAC,SAAS,CAAG,CAAA,EAQ7B,EAAO,SAAS,CAAC,MAAM,CAAG,WACxB,IAAM,EAAM,IAAI,CAAC,MAAM,CACvB,GAAI,EAAM,GAAM,EACd,MAAM,AAAI,WAAW,6CAEvB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,GAAK,EAC5B,EAAK,IAAI,CAAE,EAAG,EAAI,GAEpB,OAAO,IAAI,AACb,EAEA,EAAO,SAAS,CAAC,MAAM,CAAG,WACxB,IAAM,EAAM,IAAI,CAAC,MAAM,CACvB,GAAI,EAAM,GAAM,EACd,MAAM,AAAI,WAAW,6CAEvB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,GAAK,EAC5B,EAAK,IAAI,CAAE,EAAG,EAAI,GAClB,EAAK,IAAI,CAAE,EAAI,EAAG,EAAI,GAExB,OAAO,IAAI,AACb,EAEA,EAAO,SAAS,CAAC,MAAM,CAAG,WACxB,IAAM,EAAM,IAAI,CAAC,MAAM,CACvB,GAAI,EAAM,GAAM,EACd,MAAM,AAAI,WAAW,6CAEvB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,GAAK,EAC5B,EAAK,IAAI,CAAE,EAAG,EAAI,GAClB,EAAK,IAAI,CAAE,EAAI,EAAG,EAAI,GACtB,EAAK,IAAI,CAAE,EAAI,EAAG,EAAI,GACtB,EAAK,IAAI,CAAE,EAAI,EAAG,EAAI,GAExB,OAAO,IAAI,AACb,EAEA,EAAO,SAAS,CAAC,QAAQ,CAAG,WAC1B,IAAM,EAAS,IAAI,CAAC,MAAM,QAC1B,AAAI,AAAW,IAAX,EAAqB,GACrB,AAAqB,GAArB,UAAU,MAAM,CAAe,EAAU,IAAI,CAAE,EAAG,GAC/C,EAAa,KAAK,CAAC,IAAI,CAAE,UAClC,EAEA,EAAO,SAAS,CAAC,cAAc,CAAG,EAAO,SAAS,CAAC,QAAQ,CAE3D,EAAO,SAAS,CAAC,MAAM,CAAG,SAAiB,CAAC,EAC1C,GAAI,CAAC,EAAO,QAAQ,CAAC,GAAI,MAAM,AAAI,UAAU,oCAC7C,AAAI,IAAI,GAAK,GACN,AAA4B,IAA5B,EAAO,OAAO,CAAC,IAAI,CAAE,EAC9B,EAEA,EAAO,SAAS,CAAC,OAAO,CAAG,WACzB,IAAI,EAAM,GACJ,EAAM,EAGZ,OAFA,EAAM,IAAI,CAAC,QAAQ,CAAC,MAAO,EAAG,GAAK,OAAO,CAAC,UAAW,OAAO,IAAI,GAC7D,IAAI,CAAC,MAAM,CAAG,GAAK,CAAA,GAAO,OAA9B,EACO,WAAa,EAAM,GAC5B,EACI,GACF,CAAA,EAAO,SAAS,CAAC,EAAoB,CAAG,EAAO,SAAS,CAAC,OAAO,AAAP,EAG3D,EAAO,SAAS,CAAC,OAAO,CAAG,SAAkB,CAAM,CAAE,CAAK,CAAE,CAAG,CAAE,CAAS,CAAE,CAAO,EAIjF,GAHI,EAAW,EAAQ,aACrB,CAAA,EAAS,EAAO,IAAI,CAAC,EAAQ,EAAO,MAAM,CAAE,EAAO,UAAU,CAAA,EAE3D,CAAC,EAAO,QAAQ,CAAC,GACnB,MAAM,AAAI,UACR,iFACoB,OAAO,GAiB/B,GAbc,KAAA,IAAV,GACF,CAAA,EAAQ,CAAA,EAEE,KAAA,IAAR,GACF,CAAA,EAAM,EAAS,EAAO,MAAM,CAAG,CAAA,EAEf,KAAA,IAAd,GACF,CAAA,EAAY,CAAA,EAEE,KAAA,IAAZ,GACF,CAAA,EAAU,IAAI,CAAC,MAAM,AAAN,EAGb,EAAQ,GAAK,EAAM,EAAO,MAAM,EAAI,EAAY,GAAK,EAAU,IAAI,CAAC,MAAM,CAC5E,MAAM,AAAI,WAAW,sBAGvB,GAAI,GAAa,GAAW,GAAS,EACnC,OAAO,EAET,GAAI,GAAa,EACf,OAAO,GAET,GAAI,GAAS,EACX,OAAO,EAQT,GALA,KAAW,EACX,KAAS,EACT,KAAe,EACf,KAAa,EAET,IAAI,GAAK,EAAQ,OAAO,EAE5B,IAAI,EAAI,EAAU,EACd,EAAI,EAAM,EACR,EAAM,KAAK,GAAG,CAAC,EAAG,GAElB,EAAW,IAAI,CAAC,KAAK,CAAC,EAAW,GACjC,EAAa,EAAO,KAAK,CAAC,EAAO,GAEvC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,EAAE,EACzB,GAAI,CAAQ,CAAC,EAAE,GAAK,CAAU,CAAC,EAAE,CAAE,CACjC,EAAI,CAAQ,CAAC,EAAE,CACf,EAAI,CAAU,CAAC,EAAE,CACjB,KACF,QAGF,AAAI,EAAI,EAAU,GACd,EAAI,EAAU,EACX,CACT,EA2HA,EAAO,SAAS,CAAC,QAAQ,CAAG,SAAmB,CAAG,CAAE,CAAU,CAAE,CAAQ,EACtE,OAAO,AAA4C,KAA5C,IAAI,CAAC,OAAO,CAAC,EAAK,EAAY,EACvC,EAEA,EAAO,SAAS,CAAC,OAAO,CAAG,SAAkB,CAAG,CAAE,CAAU,CAAE,CAAQ,EACpE,OAAO,EAAqB,IAAI,CAAE,EAAK,EAAY,EAAU,CAAA,EAC/D,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAG,CAAE,CAAU,CAAE,CAAQ,EAC5E,OAAO,EAAqB,IAAI,CAAE,EAAK,EAAY,EAAU,CAAA,EAC/D,EA4CA,EAAO,SAAS,CAAC,KAAK,CAAG,SAAgB,CAAM,CAAE,CAAM,CAAE,CAAM,CAAE,CAAQ,MAhBxC,EAAQ,EAIP,EAAQ,EAIP,EAAQ,EAIV,EAAQ,EAMvC,GAAI,AAAW,KAAA,IAAX,EACF,EAAW,OACX,EAAS,IAAI,CAAC,MAAM,CACpB,EAAS,OAEJ,GAAI,AAAW,KAAA,IAAX,GAAwB,AAAkB,UAAlB,OAAO,EACxC,EAAW,EACX,EAAS,IAAI,CAAC,MAAM,CACpB,EAAS,OAEJ,GAAI,SAAS,GAClB,KAAoB,EAChB,SAAS,IACX,KAAoB,EACH,KAAA,IAAb,GAAwB,CAAA,EAAW,MAAvC,IAEA,EAAW,EACX,EAAS,KAAA,QAGX,MAAM,AAAI,MACR,2EAIJ,IAAM,EAAY,IAAI,CAAC,MAAM,CAAG,EAGhC,GAFI,CAAA,AAAW,KAAA,IAAX,GAAwB,EAAS,CAAA,GAAW,CAAA,EAAS,CAAzD,EAEK,EAAO,MAAM,CAAG,GAAM,CAAA,EAAS,GAAK,EAAS,CAAA,GAAO,EAAS,IAAI,CAAC,MAAM,CAC3E,MAAM,AAAI,WAAW,0CAGlB,GAAU,CAAA,EAAW,MAA1B,EAEA,IAAI,EAAc,CAAA,EAClB,OACE,OAAQ,GACN,IAAK,MACH,OAAO,AAlFf,SAAmB,CAAG,CAAE,CAAM,CAAE,CAAM,CAAE,CAAM,MAiBxC,EAhBJ,EAAS,OAAO,IAAW,EAC3B,IAAM,EAAY,EAAI,MAAM,CAAG,EAC1B,EAGH,CAAA,EAAS,OAAO,EAAhB,EACa,GACX,CAAA,EAAS,CADX,EAHA,EAAS,EAQX,IAAM,EAAS,EAAO,MAAM,CAM5B,IAJI,EAAS,EAAS,GACpB,CAAA,EAAS,EAAS,CAAA,EAGf,EAAI,EAAG,EAAI,EAAQ,EAAE,EAAG,CAC3B,IAAM,EAAS,SAAS,EAAO,MAAM,CAAC,AAAI,EAAJ,EAAO,GAAI,IACjD,GAotCK,AAptCW,GAAA,EAAS,KACzB,CAAA,CAAG,CAAC,EAAS,EAAE,CAAG,CACpB,CACA,OAAO,CACT,EA0DwB,IAAI,CAAE,EAAQ,EAAQ,EAExC,KAAK,OACL,IAAK,QACH,OA5DyB,EA4DM,EA5DE,EA4DM,EA3DtC,EAAW,EA2DW,EA3DS,AA2Df,IAAI,CA3De,MAAM,CAAG,GA2D5B,IAAI,CA3DsC,EAAQ,EA6DrE,KAAK,QACL,IAAK,SACL,IAAK,SACH,OA7D0B,EA6DM,EA7DE,EA6DM,EA5DvC,EAAW,AAypCpB,SAAuB,CAAG,EACxB,IAAM,EAAY,EAAE,CACpB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,EAAE,EAEhC,EAAU,IAAI,CAAC,AAAoB,IAApB,EAAI,UAAU,CAAC,IAEhC,OAAO,CACT,EApmCgC,GAAN,IAAI,CA5DiB,EAAQ,EA8DjD,KAAK,SAEH,OA7D2B,EA6DM,EA7DE,EA6DM,EA5DxC,EAAW,EA4Da,GAAN,IAAI,CA5DiB,EAAQ,EA8DlD,KAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OA/DyB,EA+DM,EA/DE,EA+DM,EA9DtC,EAAW,AA0pCpB,SAAyB,CAAG,CAAE,CAAK,MAC7B,EAAG,EACP,IAAM,EAAY,EAAE,CACpB,IAAK,IAAI,EAAI,EACX,AADc,EAAI,EAAI,MAAM,GACvB,CAAA,AAAA,CAAA,GAAS,CAAA,EAAK,CAAA,EADW,EAAE,EAIhC,EAAK,AADL,CAAA,EAAI,EAAI,UAAU,CAAC,EAAnB,GACU,EAEV,EAAU,IAAI,CADT,EAAI,KAET,EAAU,IAAI,CAAC,GAGjB,OAAO,CACT,EA1mC+B,EA9DY,AA8DlB,IAAI,CA9DkB,MAAM,CAAG,GA8D/B,IAAI,CA9DyC,EAAQ,EAgExE,SACE,GAAI,EAAa,MAAM,AAAI,UAAU,qBAAuB,GAC5D,EAAY,AAAA,CAAA,GAAK,CAAA,EAAU,WAAW,GACtC,EAAc,CAAA,CAClB,CAEJ,EAEA,EAAO,SAAS,CAAC,MAAM,CAAG,WACxB,MAAO,CACL,KAAM,SACN,KAAM,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAI,IAAI,CAAE,EACtD,CACF,EAwJA,EAAO,SAAS,CAAC,KAAK,CAAG,SAAgB,CAAK,CAAE,CAAG,EACjD,IAAM,EAAM,IAAI,CAAC,MAAM,CACvB,EAAQ,CAAC,CAAC,EACV,EAAM,AAAQ,KAAA,IAAR,EAAoB,EAAM,CAAC,CAAC,EAE9B,EAAQ,EACV,CAAA,GAAS,CAAT,EACY,GAAG,CAAA,EAAQ,CAAA,EACd,EAAQ,GACjB,CAAA,EAAQ,CADV,EAII,EAAM,EACR,CAAA,GAAO,CAAP,EACU,GAAG,CAAA,EAAM,CAAA,EACV,EAAM,GACf,CAAA,EAAM,CADR,EAII,EAAM,GAAO,CAAA,EAAM,CAAvB,EAEA,IAAM,EAAS,IAAI,CAAC,QAAQ,CAAC,EAAO,GAIpC,OAFA,OAAO,cAAc,CAAC,EAAQ,EAAO,SAAS,EAEvC,CACT,EAUA,EAAO,SAAS,CAAC,UAAU,CAC3B,EAAO,SAAS,CAAC,UAAU,CAAG,SAAqB,CAAM,CAAE,CAAU,CAAE,CAAQ,EAC7E,KAAoB,EACpB,KAA4B,EACvB,GAAU,EAAY,EAAQ,EAAY,IAAI,CAAC,MAAM,EAE1D,IAAI,EAAM,IAAI,CAAC,EAAO,CAClB,EAAM,EACN,EAAI,EACR,KAAO,EAAE,EAAI,GAAe,CAAA,GAAO,GAAA,GACjC,GAAO,IAAI,CAAC,EAAS,EAAE,CAAG,EAG5B,OAAO,CACT,EAEA,EAAO,SAAS,CAAC,UAAU,CAC3B,EAAO,SAAS,CAAC,UAAU,CAAG,SAAqB,CAAM,CAAE,CAAU,CAAE,CAAQ,EAC7E,KAAoB,EACpB,KAA4B,EACvB,GACH,EAAY,EAAQ,EAAY,IAAI,CAAC,MAAM,EAG7C,IAAI,EAAM,IAAI,CAAC,EAAS,EAAE,EAAW,CACjC,EAAM,EACV,KAAO,EAAa,GAAM,CAAA,GAAO,GAAA,GAC/B,GAAO,IAAI,CAAC,EAAS,EAAE,EAAW,CAAG,EAGvC,OAAO,CACT,EAEA,EAAO,SAAS,CAAC,SAAS,CAC1B,EAAO,SAAS,CAAC,SAAS,CAAG,SAAoB,CAAM,CAAE,CAAQ,EAG/D,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,IAAI,CAAC,EAAO,AACrB,EAEA,EAAO,SAAS,CAAC,YAAY,CAC7B,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAGrE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,IAAI,CAAC,EAAO,CAAI,IAAI,CAAC,EAAS,EAAE,EAAI,CAC7C,EAEA,EAAO,SAAS,CAAC,YAAY,CAC7B,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAGrE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,IAAK,CAAC,EAAO,EAAI,EAAK,IAAI,CAAC,EAAS,EAAE,AAC/C,EAEA,EAAO,SAAS,CAAC,YAAY,CAC7B,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAIrE,OAHA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAE1C,AAAC,CAAA,IAAK,CAAC,EAAO,CAChB,IAAI,CAAC,EAAS,EAAE,EAAI,EACpB,IAAI,CAAC,EAAS,EAAE,EAAI,EAAA,EACpB,AAAmB,UAAnB,IAAI,CAAC,EAAS,EAAE,AACvB,EAEA,EAAO,SAAS,CAAC,YAAY,CAC7B,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAIrE,OAHA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAE1C,AAAgB,UAAhB,IAAK,CAAC,EAAO,CACjB,CAAA,IAAK,CAAC,EAAS,EAAE,EAAI,GACrB,IAAI,CAAC,EAAS,EAAE,EAAI,EACrB,IAAI,CAAC,EAAS,EAAC,AAAD,CAClB,EAEA,EAAO,SAAS,CAAC,eAAe,CAAG,EAAmB,SAA0B,CAAM,EAEpF,EADA,KAAoB,EACG,UACvB,IAAM,EAAQ,IAAI,CAAC,EAAO,CACpB,EAAO,IAAI,CAAC,EAAS,EAAE,CACzB,CAAA,AAAU,KAAA,IAAV,GAAuB,AAAS,KAAA,IAAT,CAAS,GAClC,EAAY,EAAQ,IAAI,CAAC,MAAM,CAAG,GAGpC,IAAM,EAAK,EACT,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,UAAjB,IAAI,CAAC,EAAE,EAAO,CAEV,EAAK,IAAI,CAAC,EAAE,EAAO,CACvB,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAO,UAAP,EAEF,OAAO,OAAO,GAAO,CAAA,OAAO,IAAO,OAAO,GAAA,CAC5C,GAEA,EAAO,SAAS,CAAC,eAAe,CAAG,EAAmB,SAA0B,CAAM,EAEpF,EADA,KAAoB,EACG,UACvB,IAAM,EAAQ,IAAI,CAAC,EAAO,CACpB,EAAO,IAAI,CAAC,EAAS,EAAE,CACzB,CAAA,AAAU,KAAA,IAAV,GAAuB,AAAS,KAAA,IAAT,CAAS,GAClC,EAAY,EAAQ,IAAI,CAAC,MAAM,CAAG,GAGpC,IAAM,EAAK,AAAQ,UAAR,EACT,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,IAAI,CAAC,EAAE,EAAO,CAEV,EAAK,AAAiB,UAAjB,IAAI,CAAC,EAAE,EAAO,CACvB,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,EAEF,MAAQ,AAAA,CAAA,OAAO,IAAO,OAAO,GAAA,EAAO,OAAO,EAC7C,GAEA,EAAO,SAAS,CAAC,SAAS,CAAG,SAAoB,CAAM,CAAE,CAAU,CAAE,CAAQ,EAC3E,KAAoB,EACpB,KAA4B,EACvB,GAAU,EAAY,EAAQ,EAAY,IAAI,CAAC,MAAM,EAE1D,IAAI,EAAM,IAAI,CAAC,EAAO,CAClB,EAAM,EACN,EAAI,EACR,KAAO,EAAE,EAAI,GAAe,CAAA,GAAO,GAAA,GACjC,GAAO,IAAI,CAAC,EAAS,EAAE,CAAG,EAM5B,OAFI,GAFJ,CAAA,GAAO,GAAP,GAEgB,CAAA,GAAO,KAAK,GAAG,CAAC,EAAG,EAAI,EAAvC,EAEO,CACT,EAEA,EAAO,SAAS,CAAC,SAAS,CAAG,SAAoB,CAAM,CAAE,CAAU,CAAE,CAAQ,EAC3E,KAAoB,EACpB,KAA4B,EACvB,GAAU,EAAY,EAAQ,EAAY,IAAI,CAAC,MAAM,EAE1D,IAAI,EAAI,EACJ,EAAM,EACN,EAAM,IAAI,CAAC,EAAS,EAAE,EAAE,CAC5B,KAAO,EAAI,GAAM,CAAA,GAAO,GAAA,GACtB,GAAO,IAAI,CAAC,EAAS,EAAE,EAAE,CAAG,EAM9B,OAFI,GAFJ,CAAA,GAAO,GAAP,GAEgB,CAAA,GAAO,KAAK,GAAG,CAAC,EAAG,EAAI,EAAvC,EAEO,CACT,EAEA,EAAO,SAAS,CAAC,QAAQ,CAAG,SAAmB,CAAM,CAAE,CAAQ,QAG7D,CAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC3C,AAAe,IAAf,IAAI,CAAC,EAAO,EACT,CAAA,CAAA,AAAA,CAAA,IAAO,IAAI,CAAC,EAAO,CAAG,CAAA,EAAK,CAApC,EADoC,IAAI,CAAC,EAAO,AAElD,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EACnE,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EACjD,IAAM,EAAM,IAAI,CAAC,EAAO,CAAI,IAAI,CAAC,EAAS,EAAE,EAAI,EAChD,OAAO,AAAO,MAAP,EAAiB,AAAM,WAAN,EAAmB,CAC7C,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EACnE,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EACjD,IAAM,EAAM,IAAI,CAAC,EAAS,EAAE,CAAI,IAAI,CAAC,EAAO,EAAI,EAChD,OAAO,AAAO,MAAP,EAAiB,AAAM,WAAN,EAAmB,CAC7C,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EAInE,OAHA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAE1C,IAAK,CAAC,EAAO,CACjB,IAAI,CAAC,EAAS,EAAE,EAAI,EACpB,IAAI,CAAC,EAAS,EAAE,EAAI,GACpB,IAAI,CAAC,EAAS,EAAE,EAAI,EACzB,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EAInE,OAHA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAE1C,IAAK,CAAC,EAAO,EAAI,GACrB,IAAI,CAAC,EAAS,EAAE,EAAI,GACpB,IAAI,CAAC,EAAS,EAAE,EAAI,EACpB,IAAI,CAAC,EAAS,EAAE,AACrB,EAEA,EAAO,SAAS,CAAC,cAAc,CAAG,EAAmB,SAAyB,CAAM,EAElF,EADA,KAAoB,EACG,UACvB,IAAM,EAAQ,IAAI,CAAC,EAAO,CACpB,EAAO,IAAI,CAAC,EAAS,EAAE,CAU7B,MATI,CAAA,AAAU,KAAA,IAAV,GAAuB,AAAS,KAAA,IAAT,CAAS,GAClC,EAAY,EAAQ,IAAI,CAAC,MAAM,CAAG,GAQ7B,AAAC,CAAA,OALI,IAAI,CAAC,EAAS,EAAE,CAC1B,AAAmB,IAAnB,IAAI,CAAC,EAAS,EAAE,CAChB,AAAmB,MAAnB,IAAI,CAAC,EAAS,EAAE,CACf,CAAA,GAAQ,EAAA,IAEY,OAAO,GAAA,EAC5B,OAAO,EACP,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,UAAjB,IAAI,CAAC,EAAE,EAAO,CAClB,GAEA,EAAO,SAAS,CAAC,cAAc,CAAG,EAAmB,SAAyB,CAAM,EAElF,EADA,KAAoB,EACG,UACvB,IAAM,EAAQ,IAAI,CAAC,EAAO,CACpB,EAAO,IAAI,CAAC,EAAS,EAAE,CAU7B,MATI,CAAA,AAAU,KAAA,IAAV,GAAuB,AAAS,KAAA,IAAT,CAAS,GAClC,EAAY,EAAQ,IAAI,CAAC,MAAM,CAAG,GAQ7B,AAAC,CAAA,OALI,AAAC,CAAA,GAAS,EAAA,EACpB,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,IAAI,CAAC,EAAE,EAAO,GAEO,OAAO,GAAA,EAC5B,OAAO,AAAiB,UAAjB,IAAI,CAAC,EAAE,EAAO,CACrB,AAAiB,MAAjB,IAAI,CAAC,EAAE,EAAO,CACd,AAAiB,IAAjB,IAAI,CAAC,EAAE,EAAO,CACd,EACJ,GAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EAGnE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,EAAA,IAAA,CAAa,IAAI,CAAE,EAAQ,CAAA,EAAM,GAAI,EAC9C,EAEA,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAM,CAAE,CAAQ,EAGnE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,EAAA,IAAA,CAAa,IAAI,CAAE,EAAQ,CAAA,EAAO,GAAI,EAC/C,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAGrE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,EAAA,IAAA,CAAa,IAAI,CAAE,EAAQ,CAAA,EAAM,GAAI,EAC9C,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAM,CAAE,CAAQ,EAGrE,OAFA,KAAoB,EACf,GAAU,EAAY,EAAQ,EAAG,IAAI,CAAC,MAAM,EAC1C,EAAA,IAAA,CAAa,IAAI,CAAE,EAAQ,CAAA,EAAO,GAAI,EAC/C,EAQA,EAAO,SAAS,CAAC,WAAW,CAC5B,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAK,CAAE,CAAM,CAAE,CAAU,CAAE,CAAQ,EAItF,GAHA,EAAQ,CAAC,EACT,KAAoB,EACpB,KAA4B,EACxB,CAAC,EAAU,CACb,IAAM,EAAW,KAAK,GAAG,CAAC,EAAG,EAAI,GAAc,EAC/C,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAY,EAAU,EACtD,CAEA,IAAI,EAAM,EACN,EAAI,EAER,IADA,IAAI,CAAC,EAAO,CAAG,AAAQ,IAAR,EACR,EAAE,EAAI,GAAe,CAAA,GAAO,GAAA,GACjC,IAAI,CAAC,EAAS,EAAE,CAAG,EAAS,EAAO,IAGrC,OAAO,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,WAAW,CAC5B,EAAO,SAAS,CAAC,WAAW,CAAG,SAAsB,CAAK,CAAE,CAAM,CAAE,CAAU,CAAE,CAAQ,EAItF,GAHA,EAAQ,CAAC,EACT,KAAoB,EACpB,KAA4B,EACxB,CAAC,EAAU,CACb,IAAM,EAAW,KAAK,GAAG,CAAC,EAAG,EAAI,GAAc,EAC/C,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAY,EAAU,EACtD,CAEA,IAAI,EAAI,EAAa,EACjB,EAAM,EAEV,IADA,IAAI,CAAC,EAAS,EAAE,CAAG,AAAQ,IAAR,EACZ,EAAE,GAAK,GAAM,CAAA,GAAO,GAAA,GACzB,IAAI,CAAC,EAAS,EAAE,CAAG,EAAS,EAAO,IAGrC,OAAO,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,UAAU,CAC3B,EAAO,SAAS,CAAC,UAAU,CAAG,SAAqB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAKxE,OAJA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,IAAM,GACtD,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EACT,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,aAAa,CAC9B,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAM9E,OALA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,MAAQ,GACxD,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EAChB,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EACvB,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,aAAa,CAC9B,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAM9E,OALA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,MAAQ,GACxD,IAAI,CAAC,EAAO,CAAI,IAAU,EAC1B,IAAI,CAAC,EAAS,EAAE,CAAI,AAAQ,IAAR,EACb,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,aAAa,CAC9B,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAQ9E,OAPA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,WAAY,GAC5D,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EAC9B,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EACT,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,aAAa,CAC9B,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAQ9E,OAPA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,WAAY,GAC5D,IAAI,CAAC,EAAO,CAAI,IAAU,GAC1B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,AAAQ,IAAR,EACb,EAAS,CAClB,EA8CA,EAAO,SAAS,CAAC,gBAAgB,CAAG,EAAmB,SAA2B,CAAK,CAAE,EAAS,CAAC,EACjG,OAAO,EAAe,IAAI,CAAE,EAAO,EAAQ,OAAO,GAAI,OAAO,sBAC/D,GAEA,EAAO,SAAS,CAAC,gBAAgB,CAAG,EAAmB,SAA2B,CAAK,CAAE,EAAS,CAAC,EACjG,OAAO,EAAe,IAAI,CAAE,EAAO,EAAQ,OAAO,GAAI,OAAO,sBAC/D,GAEA,EAAO,SAAS,CAAC,UAAU,CAAG,SAAqB,CAAK,CAAE,CAAM,CAAE,CAAU,CAAE,CAAQ,EAGpF,GAFA,EAAQ,CAAC,EACT,KAAoB,EAChB,CAAC,EAAU,CACb,IAAM,EAAQ,KAAK,GAAG,CAAC,EAAI,EAAI,EAAc,GAE7C,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAY,EAAQ,EAAG,CAAC,EACxD,CAEA,IAAI,EAAI,EACJ,EAAM,EACN,EAAM,EAEV,IADA,IAAI,CAAC,EAAO,CAAG,AAAQ,IAAR,EACR,EAAE,EAAI,GAAe,CAAA,GAAO,GAAA,GAC7B,EAAQ,GAAK,AAAQ,IAAR,GAAa,AAAyB,IAAzB,IAAI,CAAC,EAAS,EAAI,EAAE,EAChD,CAAA,EAAM,CAAA,EAER,IAAI,CAAC,EAAS,EAAE,CAAG,AAAC,CAAA,EAAS,GAAQ,CAAA,EAAK,EAAM,IAGlD,OAAO,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,UAAU,CAAG,SAAqB,CAAK,CAAE,CAAM,CAAE,CAAU,CAAE,CAAQ,EAGpF,GAFA,EAAQ,CAAC,EACT,KAAoB,EAChB,CAAC,EAAU,CACb,IAAM,EAAQ,KAAK,GAAG,CAAC,EAAI,EAAI,EAAc,GAE7C,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAY,EAAQ,EAAG,CAAC,EACxD,CAEA,IAAI,EAAI,EAAa,EACjB,EAAM,EACN,EAAM,EAEV,IADA,IAAI,CAAC,EAAS,EAAE,CAAG,AAAQ,IAAR,EACZ,EAAE,GAAK,GAAM,CAAA,GAAO,GAAA,GACrB,EAAQ,GAAK,AAAQ,IAAR,GAAa,AAAyB,IAAzB,IAAI,CAAC,EAAS,EAAI,EAAE,EAChD,CAAA,EAAM,CAAA,EAER,IAAI,CAAC,EAAS,EAAE,CAAG,AAAC,CAAA,EAAS,GAAQ,CAAA,EAAK,EAAM,IAGlD,OAAO,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,SAAS,CAAG,SAAoB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAMtE,OALA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,IAAM,MAClD,EAAQ,GAAG,CAAA,EAAQ,IAAO,EAAQ,CAAA,EACtC,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EACT,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAM5E,OALA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,MAAQ,QACxD,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EAChB,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EACvB,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAM5E,OALA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,MAAQ,QACxD,IAAI,CAAC,EAAO,CAAI,IAAU,EAC1B,IAAI,CAAC,EAAS,EAAE,CAAI,AAAQ,IAAR,EACb,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAQ5E,OAPA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,WAAY,aAC5D,IAAI,CAAC,EAAO,CAAI,AAAQ,IAAR,EAChB,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GACvB,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAS5E,OARA,EAAQ,CAAC,EACT,KAAoB,EACf,GAAU,EAAS,IAAI,CAAE,EAAO,EAAQ,EAAG,WAAY,aACxD,EAAQ,GAAG,CAAA,EAAQ,WAAa,EAAQ,CAAA,EAC5C,IAAI,CAAC,EAAO,CAAI,IAAU,GAC1B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,GAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,IAAU,EAC9B,IAAI,CAAC,EAAS,EAAE,CAAI,AAAQ,IAAR,EACb,EAAS,CAClB,EAEA,EAAO,SAAS,CAAC,eAAe,CAAG,EAAmB,SAA0B,CAAK,CAAE,EAAS,CAAC,EAC/F,OAAO,EAAe,IAAI,CAAE,EAAO,EAAQ,CAAC,OAAO,sBAAuB,OAAO,sBACnF,GAEA,EAAO,SAAS,CAAC,eAAe,CAAG,EAAmB,SAA0B,CAAK,CAAE,EAAS,CAAC,EAC/F,OAAO,EAAe,IAAI,CAAE,EAAO,EAAQ,CAAC,OAAO,sBAAuB,OAAO,sBACnF,GAiBA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAC5E,OAAO,EAAW,IAAI,CAAE,EAAO,EAAQ,CAAA,EAAM,EAC/C,EAEA,EAAO,SAAS,CAAC,YAAY,CAAG,SAAuB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAC5E,OAAO,EAAW,IAAI,CAAE,EAAO,EAAQ,CAAA,EAAO,EAChD,EAYA,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAC9E,OAAO,EAAY,IAAI,CAAE,EAAO,EAAQ,CAAA,EAAM,EAChD,EAEA,EAAO,SAAS,CAAC,aAAa,CAAG,SAAwB,CAAK,CAAE,CAAM,CAAE,CAAQ,EAC9E,OAAO,EAAY,IAAI,CAAE,EAAO,EAAQ,CAAA,EAAO,EACjD,EAGA,EAAO,SAAS,CAAC,IAAI,CAAG,SAAe,CAAM,CAAE,CAAW,CAAE,CAAK,CAAE,CAAG,EACpE,GAAI,CAAC,EAAO,QAAQ,CAAC,GAAS,MAAM,AAAI,UAAU,+BAQlD,GAPK,GAAO,CAAA,EAAQ,CAAA,EACf,GAAO,AAAQ,IAAR,GAAW,CAAA,EAAM,IAAI,CAAC,MAAM,AAAN,EAC9B,GAAe,EAAO,MAAM,EAAE,CAAA,EAAc,EAAO,MAAM,AAAN,EAClD,GAAa,CAAA,EAAc,CAAA,EAC5B,EAAM,GAAK,EAAM,GAAO,CAAA,EAAM,CAAlC,EAGI,IAAQ,GACR,AAAkB,IAAlB,EAAO,MAAM,EAAU,AAAgB,IAAhB,IAAI,CAAC,MAAM,CADnB,OAAO,EAI1B,GAAI,EAAc,EAChB,MAAM,AAAI,WAAW,6BAEvB,GAAI,EAAQ,GAAK,GAAS,IAAI,CAAC,MAAM,CAAE,MAAM,AAAI,WAAW,sBAC5D,GAAI,EAAM,EAAG,MAAM,AAAI,WAAW,2BAG9B,EAAM,IAAI,CAAC,MAAM,EAAE,CAAA,EAAM,IAAI,CAAC,MAAM,AAAN,EAC9B,EAAO,MAAM,CAAG,EAAc,EAAM,GACtC,CAAA,EAAM,EAAO,MAAM,CAAG,EAAc,CADtC,EAIA,IAAM,EAAM,EAAM,EAalB,OAXI,IAAI,GAAK,GAAU,AAA2C,YAA3C,OAAO,WAAW,SAAS,CAAC,UAAU,CAE3D,IAAI,CAAC,UAAU,CAAC,EAAa,EAAO,GAEpC,WAAW,SAAS,CAAC,GAAG,CAAC,IAAI,CAC3B,EACA,IAAI,CAAC,QAAQ,CAAC,EAAO,GACrB,GAIG,CACT,EAMA,EAAO,SAAS,CAAC,IAAI,CAAG,SAAe,CAAG,CAAE,CAAK,CAAE,CAAG,CAAE,CAAQ,MA6C1D,EA3CJ,GAAI,AAAe,UAAf,OAAO,EAAkB,CAS3B,GARI,AAAiB,UAAjB,OAAO,GACT,EAAW,EACX,EAAQ,EACR,EAAM,IAAI,CAAC,MAAM,EACO,UAAf,OAAO,IAChB,EAAW,EACX,EAAM,IAAI,CAAC,MAAM,EAEf,AAAa,KAAA,IAAb,GAA0B,AAAoB,UAApB,OAAO,EACnC,MAAM,AAAI,UAAU,6BAEtB,GAAI,AAAoB,UAApB,OAAO,GAAyB,CAAC,EAAO,UAAU,CAAC,GACrD,MAAM,AAAI,UAAU,qBAAuB,GAE7C,GAAI,AAAe,IAAf,EAAI,MAAM,CAAQ,CACpB,IAAM,EAAO,EAAI,UAAU,CAAC,GACvB,CAAA,AAAa,SAAb,GAAuB,EAAO,KAC/B,AAAa,WAAb,CAAa,GAEf,CAAA,EAAM,CAAN,CAEJ,CACF,KAAW,AAAe,UAAf,OAAO,EAChB,GAAY,IACY,WAAf,OAAO,GAChB,CAAA,EAAM,OAAO,EADR,EAKP,GAAI,EAAQ,GAAK,IAAI,CAAC,MAAM,CAAG,GAAS,IAAI,CAAC,MAAM,CAAG,EACpD,MAAM,AAAI,WAAW,sBAGvB,GAAI,GAAO,EACT,OAAO,IAAI,CASb,GANA,KAAkB,EAClB,EAAM,AAAQ,KAAA,IAAR,EAAoB,IAAI,CAAC,MAAM,CAAG,IAAQ,EAE3C,GAAK,CAAA,EAAM,CAAA,EAGZ,AAAe,UAAf,OAAO,EACT,IAAK,EAAI,EAAO,EAAI,EAAK,EAAE,EACzB,IAAI,CAAC,EAAE,CAAG,MAEP,CACL,IAAM,EAAQ,EAAO,QAAQ,CAAC,GAC1B,EACA,EAAO,IAAI,CAAC,EAAK,GACf,EAAM,EAAM,MAAM,CACxB,GAAI,AAAQ,IAAR,EACF,MAAM,AAAI,UAAU,cAAgB,EAClC,qCAEJ,IAAK,EAAI,EAAG,EAAI,EAAM,EAAO,EAAE,EAC7B,IAAI,CAAC,EAAI,EAAM,CAAG,CAAK,CAAC,EAAI,EAAI,AAEpC,CAEA,OAAO,IAAI,AACb,EAMA,IAAM,EAAS,CAAC,EAChB,SAAS,EAAG,CAAG,CAAE,CAAU,CAAE,CAAI,EAC/B,CAAM,CAAC,EAAI,CAAG,cAAwB,EACpC,aAAe,CACb,KAAK,GAEL,OAAO,cAAc,CAAC,IAAI,CAAE,UAAW,CACrC,MAAO,EAAW,KAAK,CAAC,IAAI,CAAE,WAC9B,SAAU,CAAA,EACV,aAAc,CAAA,CAChB,GAGA,IAAI,CAAC,IAAI,CAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,EAAI,CAAC,CAAC,CAGnC,IAAI,CAAC,KAAK,CAEV,OAAO,IAAI,CAAC,IAAI,AAClB,CAEA,IAAI,MAAQ,CACV,OAAO,CACT,CAEA,IAAI,KAAM,CAAK,CAAE,CACf,OAAO,cAAc,CAAC,IAAI,CAAE,OAAQ,CAClC,aAAc,CAAA,EACd,WAAY,CAAA,EACZ,MAAA,EACA,SAAU,CAAA,CACZ,EACF,CAEA,UAAY,CACV,MAAO,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,EAAI,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,AACjD,CACF,CACF,CA+BA,SAAS,EAAuB,CAAG,EACjC,IAAI,EAAM,GACN,EAAI,EAAI,MAAM,CACZ,EAAQ,AAAW,MAAX,CAAG,CAAC,EAAE,CAAW,EAAI,EACnC,KAAO,GAAK,EAAQ,EAAG,GAAK,EAC1B,EAAM,CAAC,CAAC,EAAE,EAAI,KAAK,CAAC,EAAI,EAAG,GAAG,EAAE,EAAI,CAAC,CAEvC,MAAO,CAAC,EAAE,EAAI,KAAK,CAAC,EAAG,GAAG,EAAE,EAAI,CAAC,AACnC,CAYA,SAAS,EAAY,CAAK,CAAE,CAAG,CAAE,CAAG,CAAE,CAAG,CAAE,CAAM,CAAE,CAAU,EAC3D,GAAI,EAAQ,GAAO,EAAQ,EAAK,KAE1B,EADJ,IAAM,EAAI,AAAe,UAAf,OAAO,EAAmB,IAAM,EAY1C,OARI,EAFA,EAAa,EACX,AAAQ,IAAR,GAAa,IAAQ,OAAO,GACtB,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAG,AAAA,CAAA,EAAa,CAAA,EAAK,EAAE,EAAE,EAAE,CAAC,CAErD,CAAC,MAAM,EAAE,EAAE,IAAI,EAAG,AAAA,CAAA,EAAa,CAAA,EAAK,EAAI,EAAE,EAAE,EAC3C,aAAA,EAAG,AAAA,CAAA,EAAa,CAAA,EAAK,EAAI,EAAE,EAAE,EAAE,CAD4B,CAI9D,CAAC,GAAG,EAAE,EAAI,EAAE,EAAE,QAAQ,EAAE,EAAI,EAAE,EAAE,CAAC,CAErC,IAAI,EAAO,gBAAgB,CAAC,QAAS,EAAO,EACpD,CArBA,EAsBiB,EAtBM,UACnB,CAAA,AAAgB,KAAA,IAAhB,AAqBQ,CArBL,CAqBU,EArBF,EAAkB,AAA6B,KAAA,IAA7B,AAqBrB,CArBwB,CAAC,AAqBpB,EAAQ,EArBgC,AAAK,GAC5D,EAoBe,EApBK,AAoBV,EApBc,MAAM,CAAI,CAAA,AAoBX,EApBwB,CAAA,EAqBnD,CAEA,SAAS,EAAgB,CAAK,CAAE,CAAI,EAClC,GAAI,AAAiB,UAAjB,OAAO,EACT,MAAM,IAAI,EAAO,oBAAoB,CAAC,EAAM,SAAU,EAE1D,CAEA,SAAS,EAAa,CAAK,CAAE,CAAM,CAAE,CAAI,EACvC,GAAI,KAAK,KAAK,CAAC,KAAW,EAExB,MADA,EAAe,EAAO,GAChB,IAAI,EAAO,gBAAgB,CAAC,GAAQ,SAAU,aAAc,GAGpE,GAAI,EAAS,EACX,MAAM,IAAI,EAAO,wBAAwB,AAG3C,OAAM,IAAI,EAAO,gBAAgB,CAAC,GAAQ,SACR,CAAC,GAAG,EAAE,EAAO,EAAI,EAAE,QAAQ,EAAE,EAAO,CAAC,CACrC,EACpC,CAvFA,EAAE,2BACA,SAAU,CAAI,SACZ,AAAI,EACK,CAAC,EAAE,EAAK,4BAA4B,CAAC,CAGvC,gDACT,EAAG,YACL,EAAE,uBACA,SAAU,CAAI,CAAE,CAAM,EACpB,MAAO,CAAC,KAAK,EAAE,EAAK,iDAAiD,EAAE,OAAO,EAAO,CAAC,AACxF,EAAG,WACL,EAAE,mBACA,SAAU,CAAG,CAAE,CAAK,CAAE,CAAK,EACzB,IAAI,EAAM,CAAC,cAAc,EAAE,EAAI,kBAAkB,CAAC,CAC9C,EAAW,EAWf,OAVI,OAAO,SAAS,CAAC,IAAU,KAAK,GAAG,CAAC,GAAS,YAC/C,EAAW,EAAsB,OAAO,IACd,UAAjB,OAAO,IAChB,EAAW,OAAO,GACd,CAAA,EAAQ,OAAO,IAAM,OAAO,KAAO,EAAQ,CAAE,CAAA,OAAO,IAAM,OAAO,GAAA,CAAE,GACrE,CAAA,EAAW,EAAsB,EADnC,EAGA,GAAY,KAEd,GAAO,CAAC,YAAY,EAAE,EAAM,WAAW,EAAE,EAAS,CAAC,AAErD,EAAG,YAiEL,IAAM,EAAoB,oBAgB1B,SAAS,EAAa,CAAM,CAAE,CAAK,MAE7B,EADJ,EAAQ,GAAS,IAEjB,IAAM,EAAS,EAAO,MAAM,CACxB,EAAgB,KACd,EAAQ,EAAE,CAEhB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,EAAE,EAAG,CAI/B,GAAI,AAHJ,CAAA,EAAY,EAAO,UAAU,CAAC,EAA9B,EAGgB,OAAU,EAAY,MAAQ,CAE5C,GAAI,CAAC,EAAe,CAElB,GAAI,EAAY,OAIL,EAAI,IAAM,EAJG,CAEjB,CAAA,GAAS,CAAA,EAAK,IAAI,EAAM,IAAI,CAAC,IAAM,IAAM,KAC9C,QACF,CAOA,EAAgB,EAEhB,QACF,CAGA,GAAI,EAAY,MAAQ,CACjB,CAAA,GAAS,CAAA,EAAK,IAAI,EAAM,IAAI,CAAC,IAAM,IAAM,KAC9C,EAAgB,EAChB,QACF,CAGA,EAAa,AAAA,CAAA,EAAgB,OAAU,GAAK,EAAY,KAAA,EAAU,KACpE,MAAW,GAEL,AAAC,CAAA,GAAS,CAAA,EAAK,IAAI,EAAM,IAAI,CAAC,IAAM,IAAM,KAMhD,GAHA,EAAgB,KAGZ,EAAY,IAAM,CACpB,GAAK,AAAA,CAAA,GAAS,CAAA,EAAK,EAAG,MACtB,EAAM,IAAI,CAAC,EACb,MAAO,GAAI,EAAY,KAAO,CAC5B,GAAK,AAAA,CAAA,GAAS,CAAA,EAAK,EAAG,MACtB,EAAM,IAAI,CACR,GAAa,EAAM,IACnB,AAAY,GAAZ,EAAmB,IAEvB,MAAO,GAAI,EAAY,MAAS,CAC9B,GAAK,AAAA,CAAA,GAAS,CAAA,EAAK,EAAG,MACtB,EAAM,IAAI,CACR,GAAa,GAAM,IACnB,GAAa,EAAM,GAAO,IAC1B,AAAY,GAAZ,EAAmB,IAEvB,MAAO,GAAI,EAAY,QAAU,CAC/B,GAAK,AAAA,CAAA,GAAS,CAAA,EAAK,EAAG,MACtB,EAAM,IAAI,CACR,GAAa,GAAO,IACpB,GAAa,GAAM,GAAO,IAC1B,GAAa,EAAM,GAAO,IAC1B,AAAY,GAAZ,EAAmB,IAEvB,MACE,MAAM,AAAI,MAAM,qBAEpB,CAEA,OAAO,CACT,CA2BA,SAAS,EAAe,CAAG,EACzB,OAAO,EAAA,WAAA,CAAmB,AAxH5B,SAAsB,CAAG,EAMvB,GAAI,AAFJ,CAAA,EAAM,AAFN,CAAA,EAAM,EAAI,KAAK,CAAC,IAAI,CAAC,EAAE,AAAF,EAEX,IAAI,GAAG,OAAO,CAAC,EAAmB,GAA5C,EAEQ,MAAM,CAAG,EAAG,MAAO,GAE3B,KAAO,EAAI,MAAM,CAAG,GAAM,GACxB,GAAY,IAEd,OAAO,CACT,EA4GwC,GACxC,CAEA,SAAS,EAAY,CAAG,CAAE,CAAG,CAAE,CAAM,CAAE,CAAM,EAC3C,IAAI,EACJ,IAAK,EAAI,EACP,AADU,EAAI,IACV,CAAA,EAAK,GAAU,EAAI,MAAM,AAAN,IAAY,CAAA,GAAK,EAAI,MAAM,AAAN,EADtB,EAAE,EAExB,CAAG,CAAC,EAAI,EAAO,CAAG,CAAG,CAAC,EAAE,CAE1B,OAAO,CACT,CAKA,SAAS,EAAY,CAAG,CAAE,CAAI,EAC5B,OAAO,aAAe,GACnB,AAAO,MAAP,GAAe,AAAmB,MAAnB,EAAI,WAAW,EAAY,AAAwB,MAAxB,EAAI,WAAW,CAAC,IAAI,EAC7D,EAAI,WAAW,CAAC,IAAI,GAAK,EAAK,IAAI,AACxC,CAQA,IAAM,EAAsB,WAC1B,IAAM,EAAW,mBACX,EAAQ,AAAI,MAAM,KACxB,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,EAAE,EAAG,CAC3B,IAAM,EAAM,AAAI,GAAJ,EACZ,IAAK,IAAI,EAAI,EAAG,EAAI,GAAI,EAAE,EACxB,CAAK,CAAC,EAAM,EAAE,CAAG,CAAQ,CAAC,EAAE,CAAG,CAAQ,CAAC,EAAE,AAE9C,CACA,OAAO,CACT,IAGA,SAAS,EAAoB,CAAE,EAC7B,MAAO,AAAkB,aAAlB,OAAO,OAAyB,EAAyB,CAClE,CAEA,SAAS,IACP,MAAM,AAAI,MAAM,uBAClB,C,G,E,Q,S,C,C,C,E,E,E,O,C,c,I,E,A,G,E,G,E,E,O,C,gB,I,E,A,G,E,GCtjEA,EAiDA,SAAsB,CAAG,EAEvB,IADI,EAcA,EAbA,EAAO,AAjCb,SAAkB,CAAG,EACnB,IAAI,EAAM,EAAI,MAAM,CAEpB,GAAI,EAAM,EAAI,EACZ,MAAM,AAAI,MAAM,kDAKlB,IAAI,EAAW,EAAI,OAAO,CAAC,IACV,CAAA,KAAb,GAAiB,CAAA,EAAW,CAAhC,EAEA,IAAI,EAAkB,IAAa,EAC/B,EACA,EAAK,EAAW,EAEpB,MAAO,CAAC,EAAU,EAAgB,AACpC,EAgBqB,GACf,EAAW,CAAI,CAAC,EAAE,CAClB,EAAkB,CAAI,CAAC,EAAE,CAEzB,EAAM,IAAI,EATL,CAAA,AAS0B,EAAU,CATzB,EAAmB,EAAI,EASE,GAEzC,EAAU,EAGV,EAAM,EAAkB,EACxB,EAAW,EACX,EAGJ,IAAK,EAAI,EAAG,EAAI,EAAK,GAAK,EACxB,EACG,CAAS,CAAC,EAAI,UAAU,CAAC,GAAG,EAAI,GAChC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,EAAI,GACpC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,EAAI,EACrC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,CAClC,CAAG,CAAC,IAAU,CAAG,GAAQ,GAAM,IAC/B,CAAG,CAAC,IAAU,CAAG,GAAQ,EAAK,IAC9B,CAAG,CAAC,IAAU,CAAG,AAAM,IAAN,EAmBnB,OAhBwB,IAApB,IACF,EACG,CAAS,CAAC,EAAI,UAAU,CAAC,GAAG,EAAI,EAChC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,EAAI,EACvC,CAAG,CAAC,IAAU,CAAG,AAAM,IAAN,GAGK,IAApB,IACF,EACE,CAAU,CAAC,EAAI,UAAU,CAAC,GAAG,EAAI,GAChC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,EAAI,EACpC,CAAS,CAAC,EAAI,UAAU,CAAC,EAAI,GAAG,EAAI,EACvC,CAAG,CAAC,IAAU,CAAG,GAAQ,EAAK,IAC9B,CAAG,CAAC,IAAU,CAAG,AAAM,IAAN,GAGZ,CACT,EA5FA,EAkHA,SAAwB,CAAK,EAQ3B,IAAK,IAPD,EACA,EAAM,EAAM,MAAM,CAClB,EAAa,EAAM,EACnB,EAAQ,EAAE,CAIL,EAAI,EAAG,EAAO,EAAM,EAAY,EAAI,EAAM,GAH9B,MAInB,EAAM,IAAI,CAAC,AAtBf,SAAsB,CAAK,CAAE,CAAK,CAAE,CAAG,EAGrC,IAAK,IAFD,EACA,EAAS,EAAE,CACN,EAAI,EAAO,EAAI,EAAK,GAAK,EAKhC,EAAO,IAAI,CAdN,CAAM,CAAC,AAUZ,CAAA,EACE,AAAC,CAAA,CAAM,CAAC,EAAE,EAAI,GAAM,QAAA,EAClB,CAAA,CAAK,CAAC,EAAI,EAAE,EAAI,EAAK,KAAA,EACtB,CAAA,AAAe,IAAf,CAAK,CAAC,EAAI,EAAE,AAAG,CAAG,GAbF,GAAK,GAAK,CAC7B,CAAM,CAAC,AAaqB,GAbd,GAAK,GAAK,CACxB,CAAM,CAAC,AAYqB,GAZd,EAAI,GAAK,CACvB,CAAM,CAAC,AAAM,GAWe,EAXV,EAapB,OAAO,EAAO,IAAI,CAAC,GACrB,EAW2B,EAAO,EAAI,EAJf,MAIqC,EAAO,EAAQ,EAJpD,QAyBrB,OAjBI,AAAe,IAAf,EAEF,EAAM,IAAI,CACR,CAAM,CAAC,AAFT,CAAA,EAAM,CAAK,CAAC,EAAM,EAAE,AAAF,GAEF,EAAE,CAChB,CAAM,CAAC,GAAQ,EAAK,GAAK,CACzB,MAEsB,IAAf,GAET,EAAM,IAAI,CACR,CAAM,CAAC,AAFT,CAAA,EAAM,AAAC,CAAA,CAAK,CAAC,EAAM,EAAE,EAAI,CAAA,EAAK,CAAK,CAAC,EAAM,EAAE,AAAF,GAE1B,GAAG,CACjB,CAAM,CAAE,GAAO,EAAK,GAAK,CACzB,CAAM,CAAC,GAAQ,EAAK,GAAK,CACzB,KAIG,EAAM,IAAI,CAAC,GACpB,EA1IA,IAAK,IARL,EACA,EAEI,EAAS,EAAE,CACX,EAAY,EAAE,CACd,EAAM,AAAsB,aAAtB,OAAO,WAA6B,WAAa,MAEvD,EAAO,mEACF,EAAI,EAAG,EAAM,EAAK,MAAM,CAAE,EAAI,EAAK,EAAE,EAC5C,CAAM,CAAC,EAAE,CAAG,CAAI,CAAC,EAAE,CACnB,CAAS,CAAC,EAAK,UAAU,CAAC,GAAG,CAAG,CAKlC,CAAA,CAAS,CAAC,IAAI,UAAU,CAAC,GAAG,CAAG,GAC/B,CAAS,CAAC,IAAI,UAAU,CAAC,GAAG,CAAG,E,G,E,Q,S,C,C,C,MClB/B,EAiCA,E,E,E,O,C,O,I,E,A,G,E,G,E,E,O,C,Q,I,E,A,G,E,GAjCA,EAAe,SAAU,CAAM,CAAE,CAAM,CAAE,CAAI,CAAE,CAAI,CAAE,CAAM,EAEzD,IADI,EAAG,EACH,EAAQ,AAAS,EAAT,EAAc,EAAO,EAC7B,EAAO,AAAC,CAAA,GAAK,CAAA,EAAQ,EACrB,EAAQ,GAAQ,EAChB,EAAQ,GACR,EAAI,EAAQ,EAAS,EAAK,EAC1B,EAAI,EAAO,GAAK,EAChB,EAAI,CAAM,CAAC,EAAS,EAAE,CAO1B,IALA,GAAK,EAEL,EAAI,EAAK,AAAC,CAAA,GAAM,CAAC,CAAA,EAAU,EAC3B,IAAO,CAAC,EACR,GAAS,EACF,EAAQ,EAAG,EAAI,AAAK,IAAL,EAAY,CAAM,CAAC,EAAS,EAAE,CAAE,GAAK,EAAG,GAAS,GAKvE,IAHA,EAAI,EAAK,AAAC,CAAA,GAAM,CAAC,CAAA,EAAU,EAC3B,IAAO,CAAC,EACR,GAAS,EACF,EAAQ,EAAG,EAAI,AAAK,IAAL,EAAY,CAAM,CAAC,EAAS,EAAE,CAAE,GAAK,EAAG,GAAS,GAEvE,GAAI,AAAM,IAAN,EACF,EAAI,EAAI,MAGH,CAFA,GAAI,IAAM,EACf,OAAO,EAAI,IAAO,IAAC,CAAA,EAAI,GAAK,CAAA,EAE5B,GAAQ,KAAK,GAAG,CAAC,EAAG,GACpB,GAAQ,CACV,CACA,MAAO,AAAC,CAAA,EAAI,GAAK,CAAA,EAAK,EAAI,KAAK,GAAG,CAAC,EAAG,EAAI,EAC5C,EAEA,EAAgB,SAAU,CAAM,CAAE,CAAK,CAAE,CAAM,CAAE,CAAI,CAAE,CAAI,CAAE,CAAM,EAEjE,IADI,EAAG,EAAG,EACN,EAAQ,AAAS,EAAT,EAAc,EAAO,EAC7B,EAAO,AAAC,CAAA,GAAK,CAAA,EAAQ,EACrB,EAAQ,GAAQ,EAChB,EAAM,AAAS,KAAT,EAAc,qBAAsC,EAC1D,EAAI,EAAO,EAAK,EAAS,EACzB,EAAI,EAAO,EAAI,GACf,EAAI,EAAQ,GAAM,AAAU,IAAV,GAAe,EAAI,EAAQ,EAAK,EAAI,EAmC1D,IA/BI,MAFJ,EAAQ,KAAK,GAAG,CAAC,KAEG,IAAU,KAC5B,EAAI,MAAM,GAAS,EAAI,EACvB,EAAI,IAEJ,EAAI,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,GAAS,KAAK,GAAG,EACrC,EAAS,CAAA,EAAI,KAAK,GAAG,CAAC,EAAG,CAAC,EAAA,EAAM,IAClC,IACA,GAAK,GAEH,EAAI,GAAS,EACf,GAAS,EAAK,EAEd,GAAS,EAAK,KAAK,GAAG,CAAC,EAAG,EAAI,GAE5B,EAAQ,GAAK,IACf,IACA,GAAK,GAGH,EAAI,GAAS,GACf,EAAI,EACJ,EAAI,GACK,EAAI,GAAS,GACtB,EAAI,AAAC,CAAA,EAAS,EAAK,CAAA,EAAK,KAAK,GAAG,CAAC,EAAG,GACpC,GAAQ,IAER,EAAI,EAAQ,KAAK,GAAG,CAAC,EAAG,EAAQ,GAAK,KAAK,GAAG,CAAC,EAAG,GACjD,EAAI,IAID,GAAQ,EAAG,CAAM,CAAC,EAAS,EAAE,CAAG,AAAI,IAAJ,EAAU,GAAK,EAAG,GAAK,IAAK,GAAQ,GAI3E,IAFA,EAAK,GAAK,EAAQ,EAClB,GAAQ,EACD,EAAO,EAAG,CAAM,CAAC,EAAS,EAAE,CAAG,AAAI,IAAJ,EAAU,GAAK,EAAG,GAAK,IAAK,GAAQ,GAE1E,CAAM,CAAC,EAAS,EAAI,EAAE,EAAI,AAAI,IAAJ,CAC5B,C,G,E,Q,S,C,C,C,ECnFA,IAOI,EACA,EAkFA,EA1FA,EAAU,EAAA,OAAA,CAAiB,CAAC,EAUhC,SAAS,IACL,MAAM,AAAI,MAAM,kCACpB,CACA,SAAS,IACL,MAAM,AAAI,MAAM,oCACpB,CAqBA,SAAS,EAAW,CAAG,EACnB,GAAI,IAAqB,WAErB,OAAO,WAAW,EAAK,GAG3B,GAAK,AAAA,CAAA,IAAqB,GAAoB,CAAC,CAAA,GAAqB,WAEhE,OADA,EAAmB,WACZ,WAAW,EAAK,GAE3B,GAAI,CAEA,OAAO,EAAiB,EAAK,EACjC,CAAE,MAAM,EAAE,CACN,GAAI,CAEA,OAAO,EAAiB,IAAI,CAAC,KAAM,EAAK,EAC5C,CAAE,MAAM,EAAE,CAEN,OAAO,EAAiB,IAAI,CAAC,IAAI,CAAE,EAAK,EAC5C,CACJ,CAGJ,EA5CC,AAAA,WACG,GAAI,CAEI,EADA,AAAsB,YAAtB,OAAO,WACY,WAEA,CAE3B,CAAE,MAAO,EAAG,CACR,EAAmB,CACvB,CACA,GAAI,CAEI,EADA,AAAwB,YAAxB,OAAO,aACc,aAEA,CAE7B,CAAE,MAAO,EAAG,CACR,EAAqB,CACzB,CACJ,IAqDA,IAAI,EAAQ,EAAE,CACV,EAAW,CAAA,EAEX,EAAa,GAEjB,SAAS,IACA,GAAa,IAGlB,EAAW,CAAA,EACP,EAAa,MAAM,CACnB,EAAQ,EAAa,MAAM,CAAC,GAE5B,EAAa,GAEb,EAAM,MAAM,EACZ,IAER,CAEA,SAAS,IACL,IAAI,GAGJ,IAAI,EAAU,EAAW,GACzB,EAAW,CAAA,EAGX,IADA,IAAI,EAAM,EAAM,MAAM,CAChB,GAAK,CAGP,IAFA,EAAe,EACf,EAAQ,EAAE,CACH,EAAE,EAAa,GACd,GACA,CAAY,CAAC,EAAW,CAAC,GAAG,GAGpC,EAAa,GACb,EAAM,EAAM,MAAM,AACtB,CACA,EAAe,KACf,EAAW,CAAA,EACX,AApEJ,SAAyB,CAAM,EAC3B,GAAI,IAAuB,aAEvB,OAAO,aAAa,GAGxB,GAAK,AAAA,CAAA,IAAuB,GAAuB,CAAC,CAAA,GAAuB,aAEvE,OADA,EAAqB,aACd,aAAa,GAExB,GAAI,CAEO,EAAmB,EAC9B,CAAE,MAAO,EAAE,CACP,GAAI,CAEA,OAAO,EAAmB,IAAI,CAAC,KAAM,EACzC,CAAE,MAAO,EAAE,CAGP,OAAO,EAAmB,IAAI,CAAC,IAAI,CAAE,EACzC,CACJ,CAIJ,EA0CoB,GACpB,CAgBA,SAAS,EAAK,CAAG,CAAE,CAAK,EACpB,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,KAAK,CAAG,CACjB,CAWA,SAAS,IAAQ,CA5BjB,EAAQ,QAAQ,CAAG,SAAU,CAAG,EAC5B,IAAI,EAAO,AAAI,MAAM,UAAU,MAAM,CAAG,GACxC,GAAI,UAAU,MAAM,CAAG,EACnB,IAAK,IAAI,EAAI,EAAG,EAAI,UAAU,MAAM,CAAE,IAClC,CAAI,CAAC,EAAI,EAAE,CAAG,SAAS,CAAC,EAAE,CAGlC,EAAM,IAAI,CAAC,IAAI,EAAK,EAAK,IACJ,IAAjB,EAAM,MAAM,EAAW,GACvB,EAAW,EAEnB,EAOA,EAAK,SAAS,CAAC,GAAG,CAAG,WACjB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAM,IAAI,CAAC,KAAK,CACnC,EACA,EAAQ,KAAK,CAAG,UAChB,EAAQ,OAAO,CAAG,CAAA,EAClB,EAAQ,GAAG,CAAG,CAAC,EACf,EAAQ,IAAI,CAAG,EAAE,CACjB,EAAQ,OAAO,CAAG,GAClB,EAAQ,QAAQ,CAAG,CAAC,EAIpB,EAAQ,EAAE,CAAG,EACb,EAAQ,WAAW,CAAG,EACtB,EAAQ,IAAI,CAAG,EACf,EAAQ,GAAG,CAAG,EACd,EAAQ,cAAc,CAAG,EACzB,EAAQ,kBAAkB,CAAG,EAC7B,EAAQ,IAAI,CAAG,EACf,EAAQ,eAAe,CAAG,EAC1B,EAAQ,mBAAmB,CAAG,EAE9B,EAAQ,SAAS,CAAG,SAAU,CAAI,EAAI,MAAO,EAAE,AAAC,EAEhD,EAAQ,OAAO,CAAG,SAAU,CAAI,EAC5B,MAAM,AAAI,MAAM,mCACpB,EAEA,EAAQ,GAAG,CAAG,WAAc,MAAO,GAAI,EACvC,EAAQ,KAAK,CAAG,SAAU,CAAG,EACzB,MAAM,AAAI,MAAM,iCACpB,EACA,EAAQ,KAAK,CAAG,WAAa,OAAO,CAAG,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,O,C,K,EEvL1B,EAAA,OAAA,CAAA,OAAO,CAAG,Q,G,E,Q,S,C,C,C,E,I,E,A,E,S,M,C,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,2B,C,E,O,C,a,C,E,O,C,gB,C,E,O,C,M,C,K,E,I,E,E,S,G,E,S,E,SEavB,OAAa,EAGX,YACU,CAAmC,CAC3C,CAA2B,CAF7B,CACU,IAAA,CAAA,QAAQ,CAAR,EAGR,IAAI,CAAC,UAAU,CAAG,CACpB,CAEA,OAAO,gBAAsB,CAAkB,CAAE,CAA2B,CAA5E,CACE,IAAI,EAAW,CAAA,EA4Df,OAAO,IAAI,EA1DX,kBACE,GAAI,EACF,MAAM,AAAI,MAAM,4EAElB,EAAW,CAAA,EACX,IAAI,EAAO,CAAA,EACX,GAAI,CACF,UAAW,IAAM,KAAO,EAAiB,EAAU,GACjD,IAAI,GAEJ,GAAI,EAAI,IAAI,CAAC,UAAU,CAAC,UAAW,CACjC,EAAO,CAAA,EACP,QACD,CAED,GAAI,AAAc,OAAd,EAAI,KAAK,CAAW,CACtB,IAAI,EAEJ,GAAI,CACF,EAAO,KAAK,KAAK,CAAC,EAAI,IAAI,CAC3B,CAAC,MAAO,EAAG,CAGV,MAFA,QAAQ,KAAK,CAAC,qCAAsC,EAAI,IAAI,EAC5D,QAAQ,KAAK,CAAC,cAAe,EAAI,GAAG,EAC9B,CACP,CAED,GAAI,GAAQ,EAAK,KAAK,CACpB,MAAM,IAAI,EAAA,QAAA,CAAS,KAAA,EAAW,EAAK,KAAK,CAAE,KAAA,EAAW,KAAA,EAGvD,OAAM,CACP,KAAM,CACL,IAAI,EACJ,GAAI,CACF,EAAO,KAAK,KAAK,CAAC,EAAI,IAAI,CAC3B,CAAC,MAAO,EAAG,CAGV,MAFA,QAAQ,KAAK,CAAC,qCAAsC,EAAI,IAAI,EAC5D,QAAQ,KAAK,CAAC,cAAe,EAAI,GAAG,EAC9B,CACP,CAED,GAAI,AAAa,SAAb,EAAI,KAAK,CACX,MAAM,IAAI,EAAA,QAAA,CAAS,KAAA,EAAW,EAAK,KAAK,CAAE,EAAK,OAAO,CAAE,KAAA,EAE1D,MAAM,CAAE,MAAO,EAAI,KAAK,CAAE,KAAM,CAAI,CACrC,EAEH,EAAO,CAAA,CACR,CAAC,MAAO,EAAG,CAEV,GAAI,aAAa,OAAS,AAAW,eAAX,EAAE,IAAI,CAAmB,MACnD,OAAM,CACP,QAAS,CAEH,GAAM,EAAW,KAAK,EAC5B,CACH,EAE4B,EAC9B,CAMA,OAAO,mBAAyB,CAA8B,CAAE,CAA2B,CAA3F,CACE,IAAI,EAAW,CAAA,EAEf,eAAgB,IACd,IAAM,EAAc,IAAI,EAGxB,UAAW,IAAM,KADJ,EAAmC,GAE9C,IAAK,IAAM,KAAQ,EAAY,MAAM,CAAC,GACpC,MAAM,EAIV,IAAK,IAAM,KAAQ,EAAY,KAAK,GAClC,MAAM,CAEV,CAwBA,OAAO,IAAI,EAtBX,kBACE,GAAI,EACF,MAAM,AAAI,MAAM,4EAElB,EAAW,CAAA,EACX,IAAI,EAAO,CAAA,EACX,GAAI,CACF,UAAW,IAAM,KAAQ,KACnB,GACA,GAAM,CAAA,MAAM,KAAK,KAAK,CAAC,EAA3B,EAEF,EAAO,CAAA,CACR,CAAC,MAAO,EAAG,CAEV,GAAI,aAAa,OAAS,AAAW,eAAX,EAAE,IAAI,CAAmB,MACnD,OAAM,CACP,QAAS,CAEH,GAAM,EAAW,KAAK,EAC5B,CACH,EAE4B,EAC9B,CAEA,CAAC,OAAO,aAAa,CAAC,EAAtB,CACE,OAAO,IAAI,CAAC,QAAQ,EACtB,CAMA,KAAA,CACE,IAAM,EAA6C,EAAE,CAC/C,EAA8C,EAAE,CAChD,EAAW,IAAI,CAAC,QAAQ,GAExB,EAAc,AAAC,GACZ,CAAA,CACL,KAAM,KACJ,GAAI,AAAiB,IAAjB,EAAM,MAAM,CAAQ,CACtB,IAAM,EAAS,EAAS,IAAI,GAC5B,EAAK,IAAI,CAAC,GACV,EAAM,IAAI,CAAC,EACZ,CACD,OAAO,EAAM,KAAK,EACpB,CACD,CAAA,EAGH,MAAO,CACL,IAAI,EAAO,IAAM,EAAY,GAAO,IAAI,CAAC,UAAU,EACnD,IAAI,EAAO,IAAM,EAAY,GAAQ,IAAI,CAAC,UAAU,EACrD,AACH,CAOA,kBAAA,KAEM,EADJ,IAAM,EAAO,IAAI,CAEX,EAAU,IAAI,YAEpB,OAAO,IAAI,EAAA,cAAA,CAAe,CACxB,MAAM,QACJ,EAAO,CAAI,CAAC,OAAO,aAAa,CAAC,EACnC,EACA,MAAM,KAAK,CAAS,EAClB,GAAI,CACF,GAAM,CAAA,MAAE,CAAK,CAAA,KAAE,CAAI,CAAE,CAAG,MAAM,EAAK,IAAI,GACvC,GAAI,EAAM,OAAO,EAAK,KAAK,GAE3B,IAAM,EAAQ,EAAQ,MAAM,CAAC,KAAK,SAAS,CAAC,GAAS,MAErD,EAAK,OAAO,CAAC,EACd,CAAC,MAAO,EAAK,CACZ,EAAK,KAAK,CAAC,EACZ,CACH,EACA,MAAM,SACJ,MAAM,EAAK,MAAM,IACnB,CACD,EACH,CACD,CAEM,eAAgB,EACrB,CAAkB,CAClB,CAA2B,EAE3B,GAAI,CAAC,EAAS,IAAI,CAEhB,MADA,EAAW,KAAK,GACV,IAAI,EAAA,WAAA,CAAY,qDAGxB,IAAM,EAAa,IAAI,EACjB,EAAc,IAAI,EAGxB,UAAW,IAAM,KAAY,EADhB,EAAmC,EAAS,IAAI,GAE3D,IAAK,IAAM,KAAQ,EAAY,MAAM,CAAC,GAAW,CAC/C,IAAM,EAAM,EAAW,MAAM,CAAC,GAC1B,GAAK,CAAA,MAAM,CAAf,CACD,CAGH,IAAK,IAAM,KAAQ,EAAY,KAAK,GAAI,CACtC,IAAM,EAAM,EAAW,MAAM,CAAC,GAC1B,GAAK,CAAA,MAAM,CAAf,CACD,CACH,CAMA,eAAgB,EAAc,CAAsC,EAClE,IAAI,EAAO,IAAI,WAEf,UAAW,IAAM,KAAS,EAAU,KAe9B,EAdJ,GAAI,AAAS,MAAT,EACF,SAGF,IAAM,EACJ,aAAiB,YAAc,IAAI,WAAW,GAC5C,AAAiB,UAAjB,OAAO,EAAqB,IAAI,cAAc,MAAM,CAAC,GACrD,EAEA,EAAU,IAAI,WAAW,EAAK,MAAM,CAAG,EAAY,MAAM,EAM7D,IALA,EAAQ,GAAG,CAAC,GACZ,EAAQ,GAAG,CAAC,EAAa,EAAK,MAAM,EACpC,EAAO,EAGC,AAAiD,KAAjD,CAAA,EAAe,AAW3B,SAAgC,CAAkB,EAOhD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAG,EAAG,IAAK,CAC1C,GAJc,KAIV,CAAM,CAAC,EAAE,EAAgB,AAJf,KAIe,CAAM,CAAC,EAAI,EAAE,EAItC,AAPW,KAOX,CAAM,CAAC,EAAE,EAAiB,AAPf,KAOe,CAAM,CAAC,EAAI,EAAE,CAFzC,OAAO,EAAI,EAMb,GACE,AAZa,KAYb,CAAM,CAAC,EAAE,EACT,AAdY,KAcZ,CAAM,CAAC,EAAI,EAAE,EACb,EAAI,EAAI,EAAO,MAAM,EACrB,AAfa,KAeb,CAAM,CAAC,EAAI,EAAE,EACb,AAjBY,KAiBZ,CAAM,CAAC,EAAI,EAAE,CAGb,OAAO,EAAI,CAEd,CAED,OAAO,EACT,EAxCkD,EAAA,GAC5C,MAAM,EAAK,KAAK,CAAC,EAAG,GACpB,EAAO,EAAK,KAAK,CAAC,EAErB,CAEG,EAAK,MAAM,CAAG,GAChB,CAAA,MAAM,CADR,CAGF,CApPA,EAAA,OAAA,CAAA,MAAA,CAAA,EA0LA,EAAA,OAAA,CAAA,gBAAA,CAAA,CA2FA,OAAM,EAKJ,aAAA,CACE,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,IAAI,CAAG,EAAE,CACd,IAAI,CAAC,MAAM,CAAG,EAAE,AAClB,CAEA,OAAO,CAAY,CAAnB,CAKE,GAJI,EAAK,QAAQ,CAAC,OAChB,CAAA,EAAO,EAAK,SAAS,CAAC,EAAG,EAAK,MAAM,CAAG,EADzC,EAII,CAAC,EAAM,CAET,GAAI,CAAC,IAAI,CAAC,KAAK,EAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAE,OAAO,KAE7C,IAAM,EAAuB,CAC3B,MAAO,IAAI,CAAC,KAAK,CACjB,KAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MACrB,IAAK,IAAI,CAAC,MAAM,AACjB,EAMD,OAJA,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,IAAI,CAAG,EAAE,CACd,IAAI,CAAC,MAAM,CAAG,EAAE,CAET,CACR,CAID,GAFA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAEb,EAAK,UAAU,CAAC,KAClB,OAAO,KAGT,GAAI,CAAC,EAAW,EAAG,EAAM,CAAG,AA0IhC,SAAmB,CAAW,CAAE,CAAiB,EAC/C,IAAM,EAAQ,EAAI,OAAO,CA3IqB,YA4I9C,AAAI,AAAU,KAAV,EACK,CAAC,EAAI,SAAS,CAAC,EAAG,GA7ImB,IA6IA,EAAI,SAAS,CAAC,EAAQ,EAAU,MAAM,EAAE,CAG/E,CAAC,EAAK,GAAI,GAAG,AACtB,EAjJ0C,EAAM,KAY5C,OAVI,EAAM,UAAU,CAAC,MACnB,CAAA,EAAQ,EAAM,SAAS,CAAC,EAD1B,EAII,AAAc,UAAd,EACF,IAAI,CAAC,KAAK,CAAG,EACU,SAAd,GACT,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAGV,IACT,CACD,CAQD,MAAM,EASJ,aAAA,CACE,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,UAAU,CAAG,CAAA,CACpB,CAEA,OAAO,CAAY,CAAnB,CACE,IAAI,EAAO,IAAI,CAAC,UAAU,CAAC,GAW3B,GATI,IAAI,CAAC,UAAU,GACjB,EAAO,KAAO,EACd,IAAI,CAAC,UAAU,CAAG,CAAA,GAEhB,EAAK,QAAQ,CAAC,QAChB,IAAI,CAAC,UAAU,CAAG,CAAA,EAClB,EAAO,EAAK,KAAK,CAAC,EAAG,KAGnB,CAAC,EACH,MAAO,EAAE,CAGX,IAAM,EAAkB,EAAY,aAAa,CAAC,GAAG,CAAC,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,EAAI,IAC3E,EAAQ,EAAK,KAAK,CAAC,EAAY,cAAc,QAQjD,CAJI,GACF,EAAM,GAAG,GAGP,AAAiB,IAAjB,EAAM,MAAM,EAAW,IAKvB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,IACvB,EAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAM,CAAK,CAAC,EAAE,IAAK,EAAM,KAAK,CAAC,GAAG,CAC5D,IAAI,CAAC,MAAM,CAAG,EAAE,EAGb,GACH,CAAA,IAAI,CAAC,MAAM,CAAG,CAAC,EAAM,GAAG,IAAM,GAAG,AAAA,EAG5B,IAbL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAK,CAAC,EAAG,EACnB,EAAE,CAab,CAEA,WAAW,CAAY,CAAvB,CACE,GAAI,AAAS,MAAT,EAAe,MAAO,GAC1B,GAAI,AAAiB,UAAjB,OAAO,EAAoB,OAAO,EAGtC,GAAI,AAAkB,KAAA,IAAlB,EAA+B,CACjC,GAAI,aAAA,EACF,OAAO,EAAM,QAAQ,GAEvB,GAAI,aAAiB,WACnB,OAAO,EAAO,IAAI,CAAC,GAAO,QAAQ,EAGpC,OAAM,IAAI,EAAA,WAAA,CACR,CAAA,qCAAA,EAAwC,EAAM,WAAW,CAAC,IAAI,CAAA,iIAAA,CAAmI,CAEpM,CAGD,GAAI,AAAuB,aAAvB,OAAO,YAA6B,CACtC,GAAI,aAAiB,YAAc,aAAiB,YAElD,OADA,IAAI,CAAC,WAAW,EAAhB,CAAA,IAAI,CAAC,WAAW,CAAK,IAAI,YAAY,OAAA,EAC9B,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAGjC,OAAM,IAAI,EAAA,WAAA,CACR,CAAA,iDAAA,EACG,EAAc,WAAW,CAAC,IAC7B,CAAA,8CAAA,CAAgD,CAEnD,CAED,MAAM,IAAI,EAAA,WAAA,CACR,iGAEJ,CAEA,OAAA,CACE,GAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAI,CAAC,IAAI,CAAC,UAAU,CACzC,MAAO,EAAE,CAGX,IAAM,EAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAGpC,OAFA,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,UAAU,CAAG,CAAA,EACX,CACT,C,CA6BF,SAAgB,EAA+B,CAAW,EACxD,GAAI,CAAM,CAAC,OAAO,aAAa,CAAC,CAAE,OAAO,EAEzC,IAAM,EAAS,EAAO,SAAS,GAC/B,MAAO,CACL,MAAM,OACJ,GAAI,CACF,IAAM,EAAS,MAAM,EAAO,IAAI,GAEhC,OADI,GAAQ,MAAM,EAAO,WAAW,GAC7B,CACR,CAAC,MAAO,EAAG,CAEV,MADA,EAAO,WAAW,GACZ,CACP,CACH,EACA,MAAM,SACJ,IAAM,EAAgB,EAAO,MAAM,GAGnC,OAFA,EAAO,WAAW,GAClB,MAAM,EACC,CAAE,KAAM,CAAA,EAAM,MAAO,KAAA,CAAS,CACvC,EACA,CAAC,OAAO,aAAa,CAAC,GACpB,OAAO,IAAI,AACb,CACD,CACH,CA1JS,EAAA,aAAa,CAAG,IAAI,IAAI,CAAC,KAAM,KAAK,EACpC,EAAA,cAAc,CAAG,eAuG1B,EAAA,OAAA,CAAA,aAAA,CAAA,SAA8B,CAAgB,EAC5C,IAAM,EAAU,IAAI,EACd,EAAkB,EAAE,CAC1B,IAAK,IAAM,KAAS,EAClB,EAAM,IAAI,IAAI,EAAQ,MAAM,CAAC,IAG/B,OAAO,CACT,EAiBA,EAAA,OAAA,CAAA,2BAAA,CAAA,C,G,E,Q,S,C,C,C,ECheC,IAAA,EAAA,EAAA,S,E,E,SAID,IAAK,IAAM,KADN,EAAM,IAAI,EAAE,EAAM,QAAQ,CAAC,EAAA,UAAA,GAAmB,CAAE,KAAM,CAAA,CAAK,GACzC,OAAO,IAAI,CAAC,IACjC,OAAO,cAAc,CAAC,EAAA,OAAA,CAAS,EAAU,CACvC,IAAA,IACS,CAAK,CAAC,EAAS,AAE1B,E,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,Q,C,E,O,C,c,C,E,O,C,Y,C,E,O,C,e,C,E,O,C,0B,C,E,O,C,c,C,E,O,C,I,C,E,O,C,I,C,E,O,C,Q,C,E,O,C,O,C,E,O,C,Q,C,E,O,C,O,C,E,O,C,K,C,E,O,C,I,C,E,O,C,I,C,K,EEeS,EAAA,OAAA,CAAA,IAAI,CAAG,CAAA,EACP,EAAA,OAAA,CAAA,IAAI,CAA8B,KAAA,EAClC,EAAA,OAAA,CAAA,KAAK,CAA+B,KAAA,EACpC,EAAA,OAAA,CAAA,OAAO,CAAiC,KAAA,EACxC,EAAA,OAAA,CAAA,QAAQ,CAAkC,KAAA,EAC1C,EAAA,OAAA,CAAA,OAAO,CAAiC,KAAA,EACxC,EAAA,OAAA,CAAA,QAAQ,CAAkC,KAAA,EAC1C,EAAA,OAAA,CAAA,IAAI,CAA8B,KAAA,EAClC,EAAA,OAAA,CAAA,IAAI,CAA8B,KAAA,EAClC,EAAA,OAAA,CAAA,cAAc,CAAwC,KAAA,EACtD,EAAA,OAAA,CAAA,0BAA0B,CAAoD,KAAA,EAC9E,EAAA,OAAA,CAAA,eAAe,CAAyC,KAAA,EACxD,EAAA,OAAA,CAAA,YAAY,CAAsC,KAAA,EAClD,EAAA,OAAA,CAAA,cAAc,CAAwC,KAAA,EAEjE,EAAA,OAAA,CAAA,QAAA,CAAA,SAAyB,CAAY,CAAE,EAA6B,CAAE,KAAM,CAAA,CAAK,CAAE,EACjF,GAAI,EAAA,OAAA,CAAA,IAAI,CACN,MAAM,AAAI,MACR,CAAA,gCAAA,EAAmC,EAAM,IAAI,CAAA,8CAAA,CAAgD,EAGjG,GAAI,EAAA,OAAA,CAAA,IAAI,CACN,MAAM,AAAI,MAAM,CAAA,6BAAA,EAAgC,EAAM,IAAI,CAAA,iCAAA,EAAoC,EAAA,OAAA,CAAA,IAAI,CAAA,GAAA,CAAK,CAEzG,CAAA,EAAA,OAAA,CAAA,IAAI,CAAG,EAAQ,IAAI,CACnB,EAAA,OAAA,CAAA,IAAI,CAAG,EAAM,IAAI,CACjB,EAAA,OAAA,CAAA,KAAK,CAAG,EAAM,KAAK,CACnB,EAAA,OAAA,CAAA,OAAO,CAAG,EAAM,OAAO,CACvB,EAAA,OAAA,CAAA,QAAQ,CAAG,EAAM,QAAQ,CACzB,EAAA,OAAA,CAAA,OAAO,CAAG,EAAM,OAAO,CACvB,EAAA,OAAA,CAAA,QAAQ,CAAG,EAAM,QAAQ,CACzB,EAAA,OAAA,CAAA,IAAI,CAAG,EAAM,IAAI,CACjB,EAAA,OAAA,CAAA,IAAI,CAAG,EAAM,IAAI,CACjB,EAAA,OAAA,CAAA,cAAc,CAAG,EAAM,cAAc,CACrC,EAAA,OAAA,CAAA,0BAA0B,CAAG,EAAM,0BAA0B,CAC7D,EAAA,OAAA,CAAA,eAAe,CAAG,EAAM,eAAe,CACvC,EAAA,OAAA,CAAA,YAAY,CAAG,EAAM,YAAY,CACjC,EAAA,OAAA,CAAA,cAAc,CAAG,EAAM,cAAc,AACvC,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,Y,E,S,C,C,C,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,E,E,O,c,C,E,O,C,a,C,M,C,C,GE7DA,EAAA,EAAA,SAAA,EADG,OAAA,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,U,C,K,E,I,E,E,QEKH,CAAA,EAAA,OAAA,CAAA,UAAA,CAAA,SAA2B,CAAA,iBAAE,CAAgB,CAAA,CAAqC,CAAA,CAAE,MAS9E,EAAQ,EAAU,EAAW,EARjC,IAAM,EACJ,EACE,gCACA,CAAF;;;AAGH,CAAA,CAGC,GAAI,CAEF,EAAS,MAET,EAAW,QAEX,EAAY,SAEZ,EAAW,OACZ,CAAC,MAAO,EAAO,CACd,MAA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AAO,IAAI,CAAC,IAAI,EAAI,EAAE,AACxB,CAGA,gBAAA,CACE,IAAM,EAAO,IAAI,CAAC,YAAY,GAC9B,GAAI,CAAC,EAAM,OAAO,KAClB,GAAI,WAAY,EAAM,OAAO,EAAK,MAAM,CACxC,IAAM,EAAS,OAAO,WAAW,CAAC,EAAK,GAAG,CAAC,YAAY,SACvD,AAAK,OAAO,IAAI,CAAC,GAAQ,MAAM,CACxB,EADiC,IAE1C,CAEA,cAAA,CACE,IAAM,EAAO,IAAI,CAAC,iBAAiB,GACnC,GAAI,CAAC,EAAK,MAAM,CACd,OAAO,KAGT,IAAM,EAAK,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,EAAE,UAClC,AAAK,EAIE,CAAE,OAAQ,CAAE,MAAO,CAAE,CAAE,EAHrB,IAIX,CACD,CA5CD,EAAA,OAAA,CAAA,UAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,Y,E,S,C,C,C,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,E,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,O,C,E,O,C,W,C,E,O,C,M,C,E,O,C,U,C,E,O,C,M,C,E,O,C,U,C,E,O,C,K,C,E,O,C,e,C,E,O,C,U,C,E,O,C,W,C,E,O,C,I,C,E,O,C,O,C,E,O,C,W,C,E,O,C,K,C,K,EEnDA,EAAA,EAAA,SAAA,EAAA,OAAA,EACA,EAAA,EAAA,SAAA,EAAA,OAAA,E,I,E,E,SAC0C,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,KAAA,AAAK,CAAA,G,I,E,E,SAO7C,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,cAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WAAA,AAAW,CAAA,GACX,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,OAAA,AAAO,CAAA,G,I,E,E,SAEA,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,OAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,IAAA,AAAI,CAAA,G,I,E,E,SAQX,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,cAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WAAA,AAAW,CAAA,G,I,E,E,SAOX,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,aAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,UAAA,AAAU,CAAA,G,I,E,E,SASV,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,kBAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,eAAA,AAAe,CAAA,GACf,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,KAAA,AAAK,CAAA,G,I,E,E,SAEE,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,aAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,UAAA,AAAU,CAAA,G,I,E,E,SAQjB,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,MAAA,AAAM,CAAA,G,I,E,E,SAEsB,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,aAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,UAAA,AAAU,CAAA,GAAE,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,MAAA,AAAM,CAAA,G,I,E,E,SAS9C,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,cAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WAAA,AAAW,CAAA,G,I,E,E,SAE8C,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,OAAA,AAAO,CAAA,E,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,I,C,E,O,C,W,C,K,E,I,E,E,SE/BhE,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,cAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WAAA,AAAW,CAAA,G,I,E,E,SAEO,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,OAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,IAAA,AAAI,CAAA,E,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,K,E,I,E,E,QEtBxB,OAAa,UAAoB,EAAjC,WAAA,CAgBE,OACE,CAAgC,CAChC,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAqB,CAAE,KAAA,EAAM,GAAG,CAAO,CAAE,OAAQ,EAAK,MAAM,EAAI,CAAA,CAAK,EAGhG,CACD,CAxBD,EAAA,OAAA,CAAA,WAAA,CAAA,EA6/BiB,EAAA,OAAA,CAAA,WAAW,EAAX,CAAA,EAAA,OAAA,CAAA,WAAW,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,K,EEpgC5B,EAAA,OAAA,CAAA,WAAA,CAAA,MAGE,YAAY,CAAc,CAA1B,CACE,IAAI,CAAC,OAAO,CAAG,CACjB,CACD,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,I,C,K,E,I,E,E,SEND,IAAA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAa,EAA1B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,WAAW,CAA+B,IAAI,EAAe,WAAW,CAAC,IAAI,CAAC,OAAO,CACvF,CAAC,CAFD,EAAA,OAAA,CAAA,IAAA,CAAA,EAqCgB,AAFC,CAAA,EAAA,EAAA,OAAA,CAAA,IAAI,EAAJ,CAAA,EAAA,OAAA,CAAA,IAAI,CAAA,CAAA,CAAA,CAAA,EAEL,WAAW,CAAG,EAAe,WAAW,A,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,E,G,E,Q,S,C,C,C,E,IIrBvC,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,K,C,K,E,I,E,E,SAlBjB,IAAA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAc,EAA3B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,cAAc,CAAqC,IAAI,EAAkB,cAAc,CAAC,IAAI,CAAC,OAAO,EACpG,IAAA,CAAA,YAAY,CAAiC,IAAI,EAAgB,YAAY,CAAC,IAAI,CAAC,OAAO,EAC1F,IAAA,CAAA,MAAM,CAAqB,IAAI,EAAU,MAAM,CAAC,IAAI,CAAC,OAAO,CAC9D,CAAC,CAJD,EAAA,OAAA,CAAA,KAAA,CAAA,EAiBgB,CAHC,EAAA,EAAA,EAAA,OAAA,CAAA,KAAK,EAAL,CAAA,EAAA,OAAA,CAAA,KAAK,CAAA,CAAA,CAAA,GAGN,cAAc,CAAG,EAAkB,cAAc,CAWjD,EAAA,YAAY,CAAG,EAAgB,YAAY,CAS3C,EAAA,MAAM,CAAG,EAAU,MAAM,A,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,M,C,K,E,I,E,E,QEtCzC,OAAa,UAAe,EAA5B,WAAA,CAIE,OAAO,CAAwB,CAAE,CAA6B,CAA9D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAiB,CAAE,KAAA,EAAM,GAAG,CAAO,CAAE,iBAAkB,CAAA,CAAI,EACtF,CACD,CAPD,EAAA,OAAA,CAAA,MAAA,CAAA,EA4CiB,EAAA,OAAA,CAAA,MAAM,EAAN,CAAA,EAAA,OAAA,CAAA,MAAM,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,c,C,K,E,I,E,E,SEhDvB,IAAA,EAAA,EAAA,EAAA,SAIA,OAAa,UAAuB,EAApC,WAAA,CAiBE,OACE,CAA+B,CAC/B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,wBAAyB,EAAK,2BAA2B,CAAC,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,GACvG,CACD,CAvBD,EAAA,OAAA,CAAA,cAAA,CAAA,EAwMiB,EAAA,OAAA,CAAA,cAAc,EAAd,CAAA,EAAA,OAAA,CAAA,cAAc,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,Y,C,K,E,I,E,E,SE5M/B,IAAA,EAAA,EAAA,EAAA,SAKA,OAAa,UAAqB,EAAlC,WAAA,CAiBE,OACE,CAA6B,CAC7B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,sBAAuB,EAAK,2BAA2B,CAAC,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,GACrG,CACD,CAvBD,EAAA,OAAA,CAAA,YAAA,CAAA,EA4FiB,EAAA,OAAA,CAAA,YAAY,EAAZ,CAAA,EAAA,OAAA,CAAA,YAAY,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,E,O,C,O,C,K,E,I,E,E,S,E,E,SE/F7B,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAGA,OAAa,UAAgB,EAA7B,WAAA,CAIE,OAAO,CAAuB,CAAE,CAA6B,CAA7D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAY,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EACzD,CAKA,SAAS,CAAe,CAAE,CAA6B,CAAvD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,SAAA,EAAY,EAAO,CAAE,CAAE,EACjD,CAOA,KACE,EAA+C,CAAA,CAAE,CACjD,CAA6B,CAF/B,OAIE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,CAAA,EAAI,GAEhB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,WAAY,EAAa,CAAE,MAAA,EAAO,GAAG,CAAO,AAAA,EAC7E,CAOA,OAAO,CAAe,CAAE,CAA6B,CAArD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAO,OAAA,CAAS,CAAE,EACzD,CACD,CAtCD,EAAA,OAAA,CAAA,OAAA,CAAA,CAwCA,OAAa,UAAoB,EAAjC,UAAA,CAAqD,CAArD,EAAA,OAAA,CAAA,WAAA,CAAA,EA0MgB,AAJC,CAAA,EAAA,EAAA,OAAA,CAAA,OAAO,EAAP,CAAA,EAAA,OAAA,CAAA,OAAO,CAAA,CAAA,CAAA,CAAA,EAIR,WAAW,CAAG,EAAW,WAAW,A,G,E,Q,S,C,C,C,E,IE3OnC,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,I,C,K,E,I,E,E,SAZjB,IAAA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAa,EAA1B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,YAAY,CAAiC,IAAI,EAAgB,YAAY,CAAC,IAAI,CAAC,OAAO,EAC1F,IAAA,CAAA,IAAI,CAAiB,IAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,EAClD,IAAA,CAAA,UAAU,CAA6B,IAAI,EAAc,UAAU,CAAC,IAAI,CAAC,OAAO,EAChF,IAAA,CAAA,OAAO,CAAuB,IAAI,EAAW,OAAO,CAAC,IAAI,CAAC,OAAO,CACnE,CAAC,CALD,EAAA,OAAA,CAAA,IAAA,CAAA,EAQgB,CADC,EAAA,EAAA,EAAA,OAAA,CAAA,IAAI,EAAJ,CAAA,EAAA,OAAA,CAAA,IAAI,CAAA,CAAA,CAAA,GACL,YAAY,CAAG,EAAgB,YAAY,CAU3C,EAAA,gBAAgB,CAAG,EAAgB,gBAAgB,CAInD,EAAA,IAAI,CAAG,EAAQ,IAAI,CACnB,EAAA,UAAU,CAAG,EAAc,UAAU,CAYrC,EAAA,cAAc,CAAG,EAAc,cAAc,CAI7C,EAAA,OAAO,CAAG,EAAW,OAAO,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,c,C,E,O,C,U,C,K,E,I,E,E,S,E,E,SE1C5C,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAUA,OAAa,UAAmB,EAAhC,WAAA,CAIE,OAAO,CAA2B,CAAE,CAA6B,CAAjE,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAe,CACtC,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,SAAS,CAAmB,CAAE,CAA6B,CAA3D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,YAAA,EAAe,EAAW,CAAE,CAAE,CACpD,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,OACE,CAAmB,CACnB,CAA2B,CAC3B,CAA6B,CAH/B,CAKE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,YAAA,EAAe,EAAW,CAAE,CAAE,CACrD,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAUA,KACE,EAAmD,CAAA,CAAE,CACrD,CAA6B,CAF/B,OAIE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,CAAA,EAAI,GAEhB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,cAAe,EAAgB,CAC5D,MAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,IAAI,CAAmB,CAAE,CAA6B,CAAtD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA,YAAA,EAAe,EAAW,CAAE,CAAE,CACvD,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CACD,CApED,EAAA,OAAA,CAAA,UAAA,CAAA,CAsEA,OAAa,UAAuB,EAApC,UAAA,CAA4D,CAA5D,EAAA,OAAA,CAAA,cAAA,CAAA,EAmyCgB,AAZC,CAAA,EAAA,EAAA,OAAA,CAAA,UAAU,EAAV,CAAA,EAAA,OAAA,CAAA,UAAU,CAAA,CAAA,CAAA,CAAA,EAYX,cAAc,CAAG,EAAc,cAAc,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,I,C,K,E,I,E,E,SEr3C7D,IAAA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAa,EAA1B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,WAAW,CAA+B,IAAI,EAAe,WAAW,CAAC,IAAI,CAAC,OAAO,CACvF,CAAC,CAFD,EAAA,OAAA,CAAA,IAAA,CAAA,EAKgB,AADC,CAAA,EAAA,EAAA,OAAA,CAAA,IAAI,EAAJ,CAAA,EAAA,OAAA,CAAA,IAAI,CAAA,CAAA,CAAA,CAAA,EACL,WAAW,CAAG,EAAe,WAAW,A,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,E,O,C,oB,C,E,O,C,mB,C,E,O,C,e,C,E,O,C,6B,C,E,O,C,oB,C,K,E,I,E,E,S,G,E,S,E,UEL/C,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA,uBAAA,CAAA,WAAA,CAAA,EAAA,IAAA,WAAA,OAAA,EAAA,oBAAA,AAAoB,CAAA,G,I,G,E,S,E,UAM3B,OAAA,cAAA,CAAA,EAAA,OAAA,CAAA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,C,G,E,Q,S,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,C,C,E,G,A,M,E,M,A,U,kC,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,2E,M,A,M,E,E,I,C,E,G,E,E,K,C,E,E,G,C,E,G,C,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,E,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,4E,M,A,M,E,E,A,M,E,E,I,C,G,E,E,K,C,E,G,C,E,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,K,E,I,E,E,QEzBA,CAAA,EAAA,OAAA,CAAA,WAAA,CAAA,MAoBE,aAAA,C,E,G,C,I,EAnBA,IAAA,CAAA,UAAU,CAAoB,IAAI,gBAElC,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GACA,EAAA,GAAA,CAAA,IAAA,CAAuC,KAAO,GAC9C,EAAA,GAAA,CAAA,IAAA,CAAwD,KAAO,GAE/D,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GACA,EAAA,GAAA,CAAA,IAAA,CAAiC,KAAO,GACxC,EAAA,GAAA,CAAA,IAAA,CAAkD,KAAO,GAEzD,EAAA,GAAA,CAAA,IAAA,CAEI,CAAA,GAEJ,EAAA,GAAA,CAAA,IAAA,CAAS,CAAA,GACT,EAAA,GAAA,CAAA,IAAA,CAAW,CAAA,GACX,EAAA,GAAA,CAAA,IAAA,CAAW,CAAA,GACX,EAAA,GAAA,CAAA,IAAA,CAA0B,CAAA,GAGxB,EAAA,IAAI,CAAA,EAAqB,IAAI,QAAc,CAAC,EAAS,KACnD,EAAA,IAAI,CAAA,EAA4B,EAAO,KACvC,EAAA,IAAI,CAAA,EAA2B,EAAM,IACvC,GAAE,KAEF,EAAA,IAAI,CAAA,EAAe,IAAI,QAAc,CAAC,EAAS,KAC7C,EAAA,IAAI,CAAA,EAAsB,EAAO,KACjC,EAAA,IAAI,CAAA,EAAqB,EAAM,IACjC,GAAE,KAMF,EAAA,IAAI,CAAA,EAAA,KAAmB,KAAK,CAAC,KAAO,GACpC,EAAA,IAAI,CAAA,EAAA,KAAa,KAAK,CAAC,KAAO,EAChC,CAEU,KAAoC,CAA4B,CAAhE,CAGR,WAAW,KACT,IAAW,IAAI,CAAC,KACd,IAAI,CAAC,UAAU,GACf,IAAI,CAAC,KAAK,CAAC,MACb,EAAG,EAAA,IAAI,CAAA,EAAA,IAAA,GAAc,IAAI,CAAC,IAAI,EAChC,EAAG,EACL,CAEU,YAAA,CACJ,IAAI,CAAC,KAAK,GACd,EAAA,IAAI,CAAA,EAAA,KAAyB,IAAA,CAA7B,IAAI,EACJ,IAAI,CAAC,KAAK,CAAC,WACb,CAEA,IAAI,OAAJ,CACE,OAAO,EAAA,IAAI,CAAA,EAAA,IACb,CAEA,IAAI,SAAJ,CACE,OAAO,EAAA,IAAI,CAAA,EAAA,IACb,CAEA,IAAI,SAAJ,CACE,OAAO,EAAA,IAAI,CAAA,EAAA,IACb,CAEA,OAAA,CACE,IAAI,CAAC,UAAU,CAAC,KAAK,EACvB,CASA,GAAmC,CAAY,CAAE,CAA0C,CAA3F,CAIE,MADA,AADE,CAAA,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,EAAK,CAAA,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,CAAG,EAAE,AAAF,CAAE,EAC9C,IAAI,CAAC,CAAE,SAAA,CAAQ,GAClB,IAAI,AACb,CASA,IAAoC,CAAY,CAAE,CAA0C,CAA5F,CACE,IAAM,EAAY,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,CACxC,GAAI,CAAC,EAAW,OAAO,IAAI,CAC3B,IAAM,EAAQ,EAAU,SAAS,CAAC,AAAC,GAAM,EAAE,QAAQ,GAAK,GAExD,OADI,GAAS,GAAG,EAAU,MAAM,CAAC,EAAO,GACjC,IAAI,AACb,CAOA,KAAqC,CAAY,CAAE,CAA0C,CAA7F,CAIE,MADA,AADE,CAAA,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,EAAK,CAAA,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,CAAG,EAAE,AAAF,CAAE,EAC9C,IAAI,CAAC,CAAE,SAAA,EAAU,KAAM,CAAA,CAAI,GAC9B,IAAI,AACb,CAaA,QACE,CAAY,CADd,CAOE,OAAO,IAAI,QAAQ,CAAC,EAAS,KAC3B,EAAA,IAAI,CAAA,EAA2B,CAAA,EAAI,KACrB,UAAV,GAAmB,IAAI,CAAC,IAAI,CAAC,QAAS,GAC1C,IAAI,CAAC,IAAI,CAAC,EAAO,EACnB,EACF,CAEA,MAAM,MAAN,CACE,EAAA,IAAI,CAAA,EAA2B,CAAA,EAAI,KACnC,MAAM,EAAA,IAAI,CAAA,EAAA,IACZ,CAyBA,MAEE,CAAY,CACZ,GAAG,CAAwC,CAH7C,CAME,GAAI,EAAA,IAAI,CAAA,EAAA,KACN,MAGY,CAAA,QAAV,IACF,EAAA,IAAI,CAAA,EAAU,CAAA,EAAI,KAClB,EAAA,IAAI,CAAA,EAAA,KAAmB,IAAA,CAAvB,IAAI,GAGN,IAAM,EAA2D,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,CAMvF,GALI,IACF,EAAA,IAAI,CAAA,EAAA,IAAW,CAAC,EAAM,CAAG,EAAU,MAAM,CAAC,AAAC,GAAM,CAAC,EAAE,IAAI,EACxD,EAAU,OAAO,CAAC,CAAC,CAAA,SAAE,CAAQ,CAAO,GAAK,KAAa,KAGpD,AAAU,UAAV,EAAmB,CACrB,IAAM,EAAQ,CAAI,CAAC,EAAuB,CACrC,EAAA,IAAI,CAAA,EAAA,MAA6B,GAAW,QAC/C,QAAQ,MAAM,CAAC,GAEjB,EAAA,IAAI,CAAA,EAAA,KAAwB,IAAA,CAA5B,IAAI,CAAyB,GAC7B,EAAA,IAAI,CAAA,EAAA,KAAkB,IAAA,CAAtB,IAAI,CAAmB,GACvB,IAAI,CAAC,KAAK,CAAC,OACX,MACD,CAED,GAAI,AAAU,UAAV,EAAmB,CAGrB,IAAM,EAAQ,CAAI,CAAC,EAAiB,CAC/B,EAAA,IAAI,CAAA,EAAA,MAA6B,GAAW,QAO/C,QAAQ,MAAM,CAAC,GAEjB,EAAA,IAAI,CAAA,EAAA,KAAwB,IAAA,CAA5B,IAAI,CAAyB,GAC7B,EAAA,IAAI,CAAA,EAAA,KAAkB,IAAA,CAAtB,IAAI,CAAmB,GACvB,IAAI,CAAC,KAAK,CAAC,MACZ,CACH,CAEU,YAAU,CAAU,CAC/B,EA3E6C,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,EAAA,SAAA,CAAc,EAKxD,GAJA,EAAA,IAAI,CAAA,EAAY,CAAA,EAAI,KAChB,aAAiB,OAAS,AAAe,eAAf,EAAM,IAAI,EACtC,CAAA,EAAQ,IAAI,EADd,iBAAA,AAAA,EAGI,aAAiB,EAAA,iBAAA,CAEnB,OADA,EAAA,IAAI,CAAA,EAAY,CAAA,EAAI,KACb,IAAI,CAAC,KAAK,CAAC,QAAS,GAE7B,GAAI,aAAiB,EAAA,WAAA,CACnB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAS,GAE7B,GAAI,aAAiB,MAAO,CAC1B,IAAM,EAA2B,IAAI,EAAA,WAAA,CAAY,EAAM,OAAO,EAG9D,OADA,EAAY,KAAK,CAAG,EACb,IAAI,CAAC,KAAK,CAAC,QAAS,EAC5B,CACD,OAAO,IAAI,CAAC,KAAK,CAAC,QAAS,IAAI,EAAA,WAAA,CAAY,OAAO,IACpD,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,kB,C,E,O,C,qB,C,E,O,C,mB,C,E,O,C,mB,C,E,O,C,wB,C,E,O,C,kB,C,E,O,C,iB,C,E,O,C,4B,C,E,O,C,2B,C,K,E,I,E,E,SE/GF,SAAgB,EACd,CAAoB,EAEpB,OAAO,GAAkB,SAAc,gCACzC,CAmDA,SAAgB,EAAmB,CAAS,EAC1C,OAAO,GAAO,SAAc,qBAC9B,CAmBA,SAAgB,EAGd,CAA0B,CAAE,CAAc,EAC1C,IAAM,EAAwC,EAAW,OAAO,CAAC,GAAG,CAAC,AAAC,QA4BtD,EA3Bd,GAAI,AAAyB,WAAzB,EAAO,aAAa,CACtB,MAAM,IAAI,EADZ,uBAAA,CAIA,GAAI,AAAyB,mBAAzB,EAAO,aAAa,CACtB,MAAM,IAAI,EADZ,8BAAA,CAIA,MAAO,CACL,GAAG,CAAM,CACT,QAAS,CACP,GAAG,EAAO,OAAO,CACjB,WAAY,EAAO,OAAO,CAAC,UAAU,EAAE,IAAI,AAAC,GAAa,AAiCjE,CAAA,SACE,CAAc,CACd,CAAuC,EAEvC,IAAM,EAAY,EAAO,KAAK,EAAE,KAAK,AAAC,GAAc,EAAU,QAAQ,EAAE,OAAS,EAAS,QAAQ,CAAC,IAAI,EACvG,MAAO,CACL,GAAG,CAAQ,CACX,SAAU,CACR,GAAG,EAAS,QAAQ,CACpB,iBACE,EAAmB,GAAa,EAAU,SAAS,CAAC,EAAS,QAAQ,CAAC,SAAS,EAC7E,GAAW,SAAS,OAAS,KAAK,KAAK,CAAC,EAAS,QAAQ,CAAC,SAAS,EACnE,IACL,CACF,CACH,CAAA,EAhD+E,EAAQ,KAAc,EAAE,CAC/F,OACE,EAAO,OAAO,CAAC,OAAO,EAAI,CAAC,EAAO,OAAO,CAAC,OAAO,EAazC,EAZsB,EAAO,OAAO,CAAC,OAAO,CAa5D,AAAI,AAb0B,EAanB,eAAe,EAAE,OAAS,cAC5B,KAGL,AAjB0B,EAiBnB,eAAe,EAAE,OAAS,cACnC,AAAI,cAAe,AAlBS,EAkBF,eAAe,CAGhC,AAFiB,AAnBE,EAmBK,eAAuD,CAE/D,SAAS,CAAC,GAG5B,KAAK,KAAK,CAAC,GAGb,MA1BG,IACL,CACF,CACH,GAEA,MAAO,CAAE,GAAG,CAAU,CAAE,QAAA,CAAO,CACjC,CAoDA,SAAgB,EAAsB,CAAqC,QACzE,EAAI,EAA6B,EAAO,eAAe,GAKrD,CAAA,EAAO,KAAK,EAAE,KACZ,AAAC,GAAM,EAAmB,IAAO,AAAW,aAAX,EAAE,IAAI,EAAmB,AAAsB,CAAA,IAAtB,EAAE,QAAQ,CAAC,MAAM,GACxE,CAAA,CAHP,CAKF,CAzLA,EAAA,OAAA,CAAA,2BAAA,CAAA,SACE,CAAyC,CACzC,CAAoC,EAEpC,IAAM,EAAM,CAAE,GAAG,CAAe,AAAA,EAahC,OAXA,OAAO,gBAAgB,CAAC,EAAK,CAC3B,OAAQ,CACN,MAAO,iCACP,WAAY,CAAA,CACb,EACD,UAAW,CACT,MAAO,EACP,WAAY,CAAA,CACb,CACF,GAEM,CACT,EAEA,EAAA,OAAA,CAAA,4BAAA,CAAA,EAyBA,EAAA,OAAA,CAAA,iBAAA,CAAA,SACE,CAAwB,CACxB,CAAA,OACE,CAAM,CAAA,SACN,CAAQ,CAIT,EAED,IAAM,EAAM,CAAE,GAAG,CAAI,AAAA,EAiBrB,OAfA,OAAO,gBAAgB,CAAC,EAAK,CAC3B,OAAQ,CACN,MAAO,sBACP,WAAY,CAAA,CACb,EACD,UAAW,CACT,MAAO,EACP,WAAY,CAAA,CACb,EACD,UAAW,CACT,MAAO,EACP,WAAY,CAAA,CACb,CACF,GAEM,CACT,EAEA,EAAA,OAAA,CAAA,kBAAA,CAAA,EAIA,EAAA,OAAA,CAAA,wBAAA,CAAA,SAGE,CAA0B,CAAE,CAAc,SAC1C,AAAI,AAAC,GAAW,EAAsB,GAU/B,EAAoB,EAAY,GAT9B,CACL,GAAG,CAAU,CACb,QAAS,EAAW,OAAO,CAAC,GAAG,CAAC,AAAC,GAAY,CAAA,CAC3C,GAAG,CAAM,CACT,QAAS,CAAE,GAAG,EAAO,OAAO,CAAE,OAAQ,KAAM,WAAY,EAAO,OAAO,CAAC,UAAU,EAAI,EAAE,AAAA,CACxF,CAAA,EACF,CAIL,EAEA,EAAA,OAAA,CAAA,mBAAA,CAAA,EAmEA,EAAA,OAAA,CAAA,mBAAA,CAAA,SACE,CAAqD,CACrD,CAAuC,EAEvC,GAAI,CAAC,EACH,MAAO,CAAA,EAGT,IAAM,EAAY,EAAO,KAAK,EAAE,KAAK,AAAC,GAAc,EAAU,QAAQ,EAAE,OAAS,EAAS,QAAQ,CAAC,IAAI,EACvG,OAAO,EAAmB,IAAc,GAAW,SAAS,QAAU,CAAA,CACxE,EAEA,EAAA,OAAA,CAAA,qBAAA,CAAA,EAYA,EAAA,OAAA,CAAA,kBAAA,CAAA,SAAmC,CAAuC,EACxE,IAAK,IAAM,KAAQ,GAAS,EAAE,CAAE,CAC9B,GAAI,AAAc,aAAd,EAAK,IAAI,CACX,MAAM,IAAI,EAAA,WAAA,CACR,CAAA,wEAAA,EAA2E,EAAK,IAAI,CAAA,EAAA,CAAI,EAI5F,GAAI,AAAyB,CAAA,IAAzB,EAAK,QAAQ,CAAC,MAAM,CACtB,MAAM,IAAI,EAAA,WAAA,CACR,CAAA,MAAA,EAAS,EAAK,QAAQ,CAAC,IAAI,CAAA,0FAAA,CAA4F,CAG5H,CACH,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,6B,C,K,E,I,E,E,QE5MA,OAAa,UACH,EADV,oBAAA,CAIE,OAAgB,mBAAmB,CAAsB,CAAzD,CACE,IAAM,EAAS,IAAI,EAA8B,MAEjD,OADA,EAAO,IAAI,CAAC,IAAM,EAAO,mBAAmB,CAAC,IACtC,CACT,CAGA,OAAO,aACL,CAAc,CACd,CAAsD,CACtD,CAAuB,CAHzB,CAKE,IAAM,EAAS,IAAI,EAA8B,MAC3C,EAAO,CACX,GAAG,CAAO,CACV,QAAS,CAAE,GAAG,GAAS,OAAO,CAAE,4BAA6B,cAAc,CAC5E,EAED,OADA,EAAO,IAAI,CAAC,IAAM,EAAO,aAAa,CAAC,EAAQ,EAAQ,IAChD,CACT,CAEA,OAAO,SACL,CAAc,CACd,CAAkD,CAClD,CAAuB,CAHzB,CAKE,IAAM,EAAS,IAAI,EAEjB,GAEI,EAAO,CACX,GAAG,CAAO,CACV,QAAS,CAAE,GAAG,GAAS,OAAO,CAAE,4BAA6B,UAAU,CACxE,EAED,OADA,EAAO,IAAI,CAAC,IAAM,EAAO,SAAS,CAAC,EAAQ,EAAQ,IAC5C,CACT,CACD,CAzCD,EAAA,OAAA,CAAA,6BAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,C,C,E,G,A,M,E,M,A,U,kC,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,2E,M,A,M,E,E,I,C,E,G,E,E,K,C,E,E,G,C,E,G,C,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,E,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,4E,M,A,M,E,E,A,M,E,E,I,C,G,E,E,K,C,E,G,C,E,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,oB,C,K,E,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QEgGA,OAAa,UACH,EADV,4BAAA,CAQE,YAAY,CAAyC,CAArD,CACE,KAAK,G,E,G,C,I,EALP,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GACA,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GACA,EAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GAIE,EAAA,IAAI,CAAA,EAAW,EAAM,KACrB,EAAA,IAAI,CAAA,EAAsB,EAAE,CAAA,IAC9B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G,CACV,EAAoB,OAAO,GAC5B,CACF,CACH,EAEM,EAAY,KAChB,KAAO,EAAQ,GAAU,SAAU,QAAQ,CAAC,CAAU,CAAC,EAAO,GAC5D,GAEJ,EAEA,OAAO,GACT,CAKS,CAAA,EAAA,OAAA,CAAA,YAAA,CAFY,AAAC,GAAkB,AAtMxC,CAAA,SAAmB,CAAkB,CAAE,EAAuB,EAAM,GAAG,EACrE,GAAI,AAAsB,UAAtB,OAAO,EACT,MAAM,AAAI,UAAU,CAAA,mBAAA,EAAsB,OAAO,EAAU,CAAE,EAE/D,GAAI,CAAC,EAAW,IAAI,GAClB,MAAM,AAAI,MAAM,CAAA,EAAG,EAAU,SAAA,CAAW,EAE1C,OAAO,EAAW,EAAW,IAAI,GAAI,EACvC,CAAA,EA8LkD,EAAO,EAAM,GAAG,CAAG,EAAM,GAAG,C,G,E,Q,S,C,C,C,E,IE+tC7D,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,O,C,K,E,I,E,E,S,E,E,S,E,E,SAx8CjB,IAAA,EAAA,EAAA,EAAA,UAEA,EAAA,EAAA,EAAA,SAGA,OAAa,UAAgB,EAA7B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,IAAI,CAAiB,IAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,EAClD,IAAA,CAAA,QAAQ,CAAyB,IAAI,EAAY,QAAQ,CAAC,IAAI,CAAC,OAAO,CAqGxE,CA9FE,OACE,EAAiD,CAAA,CAAE,CACnD,CAA6B,CAF/B,OAIE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,MAAM,CAAC,CAAA,EAAI,GAElB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAY,CACnC,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,SAAS,CAAgB,CAAE,CAA6B,CAAxD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,SAAA,EAAY,EAAQ,CAAE,CAAE,CAC9C,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,OAAO,CAAgB,CAAE,CAAwB,CAAE,CAA6B,CAAhF,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,CAAE,CAAE,CAC/C,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,IAAI,CAAgB,CAAE,CAA6B,CAAnD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA,SAAA,EAAY,EAAQ,CAAE,CAAE,CACjD,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAiBA,aACE,CAA8B,CAC9B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAiB,CACxC,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,EAC9D,OAAQ,EAAK,MAAM,EAAI,CAAA,CACxB,EACH,CAOA,MAAM,iBACJ,CAA0C,CAC1C,CAA2D,CAF7D,CAIE,IAAM,EAAM,MAAM,IAAI,CAAC,YAAY,CAAC,EAAM,GAC1C,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAI,SAAS,CAAE,EAAI,EAAE,CAAE,EACrD,CAKA,mBACE,CAAwC,CACxC,CAA6B,CAF/B,CAIE,OAAO,EAAA,eAAA,CAAgB,2BAA2B,CAAC,EAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAE,EACtF,CACD,CAvGD,EAAA,OAAA,CAAA,OAAA,CAAA,EAi9CgB,CAdC,EAAA,EAAA,EAAA,OAAA,CAAA,OAAO,EAAP,CAAA,EAAA,OAAA,CAAA,OAAO,CAAA,CAAA,CAAA,GAcR,IAAI,CAAG,EAAQ,IAAI,CAInB,EAAA,QAAQ,CAAG,EAAQ,QAAQ,CAc3B,EAAA,QAAQ,CAAG,EAAY,QAAQ,CA6B/B,EAAA,YAAY,CAAG,EAAY,YAAY,A,G,E,Q,S,C,C,C,E,I,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,E,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,4E,M,A,M,E,E,A,M,E,E,I,C,G,E,E,K,C,E,G,C,E,E,E,E,O,E,E,O,C,sB,E,S,C,C,C,C,C,C,C,C,C,E,G,A,M,E,M,A,U,kC,G,A,M,G,C,E,M,A,U,iD,G,A,Y,O,E,I,G,C,E,C,E,G,C,G,M,A,U,2E,M,A,M,E,E,I,C,E,G,E,E,K,C,E,E,G,C,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,e,C,K,EErgDvD,IAAA,EAAA,EAAA,EAAA,U,I,E,E,S,E,E,S,E,E,QA8DA,OAAa,UACH,EADV,WAAA,CAAA,aAAA,C,K,I,W,E,G,C,I,EAKE,EAAA,GAAA,CAAA,IAAA,CAAkC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,GAAI,EACF,MAAO,CAAC,EAAU,EAAW,AAE7B,OAAM,MAAM,0DAEjB,CACD,MAAM,MAAM,0CACd,EAAC,EAAA,SAGC,CAAmC,CACnC,CAA0C,EAE1C,OAAO,EAAgB,eAAe,CAAC,EAA+C,EAGxF,EAAC,EAAA,SAkEiC,CAAqB,EAErD,OADA,EAAA,IAAI,CAAA,EAAuB,EAAM,IAAI,CAAA,KAC7B,EAAM,KAAK,EACjB,IAAK,qBAEL,IAAK,oBAEL,IAAK,yBAHH,KAKF,KAAK,6BACL,IAAK,uBACL,IAAK,oBACL,IAAK,uBACL,IAAK,qBACH,EAAA,IAAI,CAAA,EAAa,EAAM,IAAI,CAAA,KACvB,EAAA,IAAI,CAAA,EAAA,OACN,IAAI,CAAC,KAAK,CAAC,eAAgB,EAAA,IAAI,CAAA,EAAA,MAC/B,EAAA,IAAI,CAAA,EAAoB,KAAA,EAAS,KAKtC,CACH,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,Y,C,E,O,C,Q,C,K,E,I,E,E,S,E,E,SEjuBF,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAIA,OAAa,UAAiB,EAA9B,WAAA,CAIE,OACE,CAAgB,CAChB,CAAyB,CACzB,CAA6B,CAH/B,CAKE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,SAAA,CAAW,CAAE,CACxD,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,SAAS,CAAgB,CAAE,CAAiB,CAAE,CAA6B,CAA3E,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,SAAA,EAAY,EAAQ,UAAA,EAAa,EAAS,CAAE,CAAE,CACpE,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,OACE,CAAgB,CAChB,CAAiB,CACjB,CAAyB,CACzB,CAA6B,CAJ/B,CAME,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,UAAA,EAAa,EAAS,CAAE,CAAE,CACrE,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAWA,KACE,CAAgB,CAChB,EAAiD,CAAA,CAAE,CACnD,CAA6B,CAH/B,OAKE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,EAAU,CAAA,EAAI,GAE1B,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA,SAAA,EAAY,EAAQ,SAAA,CAAW,CAAE,EAAc,CAC5E,MAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,IAAI,CAAgB,CAAE,CAAiB,CAAE,CAA6B,CAAtE,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA,SAAA,EAAY,EAAQ,UAAA,EAAa,EAAS,CAAE,CAAE,CACvE,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CACD,CA3ED,EAAA,OAAA,CAAA,QAAA,CAAA,CA6EA,OAAa,UAAqB,EAAlC,UAAA,CAAwD,CAAxD,EAAA,OAAA,CAAA,YAAA,CAAA,EA2pBgB,AA7BC,CAAA,EAAA,EAAA,OAAA,CAAA,QAAQ,EAAR,CAAA,EAAA,OAAA,CAAA,QAAQ,CAAA,CAAA,CAAA,CAAA,EA6BT,YAAY,CAAG,EAAY,YAAY,A,G,E,Q,S,C,C,C,E,IEo2BtC,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,Q,C,E,O,C,I,C,K,E,I,E,E,S,E,E,S,E,E,S,E,E,SA5kDjB,IAAA,EAAA,EAAA,EAAA,OAAA,EAKA,EAAA,EAAA,EAAA,U,I,E,E,QAIA,OAAa,UAAa,EAA1B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,KAAK,CAAmB,IAAI,EAAS,KAAK,CAAC,IAAI,CAAC,OAAO,CA+PzD,CA3OE,OACE,CAAgB,CAChB,CAAuB,CACvB,CAA6B,CAH/B,CAKE,GAAM,CAAA,QAAE,CAAO,CAAE,GAAG,EAAM,CAAG,EAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,KAAA,CAAO,CAAE,CACpD,MAAO,CAAE,QAAA,CAAO,EAChB,KAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,EAC9D,OAAQ,EAAO,MAAM,EAAI,CAAA,CAC1B,EACH,CAKA,SAAS,CAAgB,CAAE,CAAa,CAAE,CAA6B,CAAvE,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,SAAA,EAAY,EAAQ,MAAA,EAAS,EAAK,CAAE,CAAE,CAC5D,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAKA,OACE,CAAgB,CAChB,CAA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AAO,EAAA,eAAA,CAAgB,yBAAyB,CAC9C,EACA,EACA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAC9B,EACA,EAEJ,CACD,CAhQD,EAAA,OAAA,CAAA,IAAA,CAAA,CAkQA,OAAa,UAAiB,EAA9B,UAAA,CAAgD,CAAhD,EAAA,OAAA,CAAA,QAAA,CAAA,EAq0CgB,CAJC,EAAA,EAAA,EAAA,OAAA,CAAA,IAAI,EAAJ,CAAA,EAAA,OAAA,CAAA,IAAI,CAAA,CAAA,CAAA,GAIL,QAAQ,CAAG,EAAQ,QAAQ,CAc3B,EAAA,KAAK,CAAG,EAAS,KAAK,CAmBtB,EAAA,YAAY,CAAG,EAAS,YAAY,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,Y,C,E,O,C,K,C,K,E,I,E,E,S,E,E,SErnDpD,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAGA,OAAa,UAAc,EAA3B,WAAA,CAiBE,SACE,CAAgB,CAChB,CAAa,CACb,CAAc,CACd,EAAkD,CAAA,CAAE,CACpD,CAA6B,CAL/B,OAOE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,QAAQ,CAAC,EAAU,EAAO,EAAQ,CAAA,EAAI,GAE7C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,SAAA,EAAY,EAAQ,MAAA,EAAS,EAAK,OAAA,EAAU,EAAM,CAAE,CAAE,CAC5E,MAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CAgBA,KACE,CAAgB,CAChB,CAAa,CACb,EAA8C,CAAA,CAAE,CAChD,CAA6B,CAJ/B,OAME,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,EAAU,EAAO,CAAA,EAAI,GAEjC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA,SAAA,EAAY,EAAQ,MAAA,EAAS,EAAK,MAAA,CAAQ,CAAE,EAAc,CACvF,MAAA,EACA,GAAG,CAAO,CACV,QAAS,CAAE,cAAe,gBAAiB,GAAG,GAAS,OAAO,AAAA,CAC/D,EACH,CACD,CA/DD,EAAA,OAAA,CAAA,KAAA,CAAA,CAiEA,OAAa,UAAqB,EAAlC,UAAA,CAAwD,CAAxD,EAAA,OAAA,CAAA,YAAA,CAAA,EA8qBgB,AAnBC,CAAA,EAAA,EAAA,OAAA,CAAA,KAAK,EAAL,CAAA,EAAA,OAAA,CAAA,KAAK,CAAA,CAAA,CAAA,CAAA,EAmBN,YAAY,CAAG,EAAS,YAAY,A,G,E,Q,S,C,C,C,E,IElYnC,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,gB,C,E,O,C,Y,C,K,E,I,E,E,S,E,E,SAhXjB,IAAA,EAAA,EAAA,EAAA,OAAA,EACA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,U,I,E,E,QAG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AC,IAAI,CAAC,EAAe,EAAS,EAAE,CAAE,EACrD,CACD,CAjKD,EAAA,OAAA,CAAA,KAAA,CAAA,CAmKA,OAAa,UAA6B,EAA1C,UAAA,CAAwE,CAAxE,EAAA,OAAA,CAAA,oBAAA,CAAA,EAuHgB,AAHC,CAAA,EAAA,EAAA,OAAA,CAAA,KAAK,EAAL,CAAA,EAAA,OAAA,CAAA,KAAK,CAAA,CAAA,CAAA,CAAA,EAGN,oBAAoB,CAAG,EAAS,oBAAoB,A,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,K,E,I,E,E,QE1RpE,OAAa,UAAoB,EAAjC,WAAA,CAaE,OACE,CAA4B,CAC5B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,eAAgB,CAAE,KAAA,EAAM,GAAG,CAAO,CAAE,OAAQ,EAAK,MAAM,EAAI,CAAA,CAAK,EAG3F,CACD,CArBD,EAAA,OAAA,CAAA,WAAA,CAAA,EAyUiB,EAAA,OAAA,CAAA,WAAW,EAAX,CAAA,EAAA,OAAA,CAAA,WAAW,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,U,C,K,E,I,E,E,QE5U5B,OAAa,UAAmB,EAAhC,WAAA,CAIE,OACE,CAA2B,CAC3B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,cAAe,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EAC5D,CACD,CAVD,EAAA,OAAA,CAAA,UAAA,CAAA,EAoHiB,EAAA,OAAA,CAAA,UAAU,EAAV,CAAA,EAAA,OAAA,CAAA,UAAU,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,e,C,E,O,C,K,C,K,E,I,E,E,S,E,E,SEpH3B,IAAA,EAAA,EAAA,EAAA,UACA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAIA,OAAa,UAAc,EAA3B,WAAA,CAwBE,OAAO,CAAsB,CAAE,CAA6B,CAA5D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAU,EAAK,2BAA2B,CAAC,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,GACxF,CAKA,SAAS,CAAc,CAAE,CAA6B,CAAtD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,OAAA,EAAU,EAAM,CAAE,CAAE,EAC9C,CAOA,KACE,EAA8C,CAAA,CAAE,CAChD,CAA6B,CAF/B,OAIE,AAAI,AAAA,CAAA,EAAA,AAAA,EAAA,SAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,CAAA,EAAI,GAEhB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAU,EAAiB,CAAE,MAAA,EAAO,GAAG,CAAO,AAAA,EAC/E,CAKA,IAAI,CAAc,CAAE,CAA6B,CAAjD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA,OAAA,EAAU,EAAM,CAAE,CAAE,EACjD,CAKA,QAAQ,CAAc,CAAE,CAA6B,CAArD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,OAAA,EAAU,EAAM,QAAA,CAAU,CAAE,CAAE,GAAG,CAAO,CAAE,iBAAkB,CAAA,CAAI,EAC1F,CAOA,gBAAgB,CAAc,CAAE,CAA6B,CAA7D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,OAAA,EAAU,EAAM,QAAA,CAAU,CAAE,CAClD,GAAG,CAAO,CACV,QAAS,CAAE,OAAQ,mBAAoB,GAAG,GAAS,OAAO,AAAA,CAC3D,EACH,CAKA,MAAM,kBACJ,CAAU,CACV,CAAA,aAAE,EAAe,GAAA,CAAA,QAAM,EAAU,IAAA,CAAc,CAAkD,CAAA,CAAE,CAFrG,CAIE,IAAM,EAAkB,IAAI,IAAI,CAAC,YAAa,QAAS,UAAU,EAE3D,EAAQ,KAAK,GAAG,GAClB,EAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,GAE/B,KAAO,CAAC,EAAK,MAAM,EAAI,CAAC,EAAgB,GAAG,CAAC,EAAK,MAAM,GAIrD,GAHA,MAAM,AAAA,CAAA,EAAA,AAAA,EAAA,SAAA,KAAA,AAAA,EAAM,GAEZ,EAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,GACvB,KAAK,GAAG,GAAK,EAAQ,EACvB,MAAM,IAAI,EAAA,yBAAA,CAA0B,CAClC,QAAS,CAAA,8BAAA,EAAiC,EAAE,4BAAA,EAA+B,EAAO,cAAA,CAAgB,AACnG,GAIL,OAAO,CACT,CACD,CArGD,EAAA,OAAA,CAAA,KAAA,CAAA,CA0GA,OAAa,UAAwB,EADlC,IAAA,CACqD,CAAxD,EAAA,OAAA,CAAA,eAAA,CAAA,EA+GgB,AALC,CAAA,EAAA,EAAA,OAAA,CAAA,KAAK,EAAL,CAAA,EAAA,OAAA,CAAA,KAAK,CAAA,CAAA,CAAA,CAAA,EAKN,eAAe,CAAG,EAAS,eAAe,A,G,E,Q,S,C,C,C,E,IE3NzC,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,U,C,K,E,I,E,E,SANjB,IAAA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAmB,EAAhC,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,IAAI,CAAiB,IAAI,EAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,CACpD,CAAC,CAFD,EAAA,OAAA,CAAA,UAAA,CAAA,EAKgB,CADC,EAAA,EAAA,EAAA,OAAA,CAAA,UAAU,EAAV,CAAA,EAAA,OAAA,CAAA,UAAU,CAAA,CAAA,CAAA,GACX,IAAI,CAAG,EAAQ,IAAI,CAMnB,EAAA,kBAAkB,CAAG,EAAQ,kBAAkB,CAC/C,EAAA,uBAAuB,CAAG,EAAQ,uBAAuB,A,G,E,Q,S,C,C,C,E,IE8axD,E,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,uB,C,E,O,C,kB,C,E,O,C,I,C,K,E,I,E,E,S,E,E,SA1bjB,IAAA,EAAA,EAAA,EAAA,OAAA,EACA,EAAA,EAAA,EAAA,U,I,E,E,QAGA,OAAa,UAAa,EAA1B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,WAAW,CAA+B,IAAI,EAAe,WAAW,CAAC,IAAI,CAAC,OAAO,CA0EvF,CA/DE,OAAO,CAAqB,CAAE,CAA6B,CAA3D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAqB,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EAClE,CAOA,SAAS,CAAuB,CAAE,CAA6B,CAA/D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,kBAAA,EAAqB,EAAe,CAAE,CAAE,EAClE,CAUA,KACE,EAA6C,CAAA,CAAE,CAC/C,CAA6B,CAF/B,OAIE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,CAAA,EAAI,GAEhB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,oBAAqB,EAAoB,CAAE,MAAA,EAAO,GAAG,CAAO,AAAA,EAC7F,CAKA,OAAO,CAAuB,CAAE,CAA6B,CAA7D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,kBAAA,EAAqB,EAAe,OAAA,CAAS,CAAE,EAC1E,CAcA,WACE,CAAuB,CACvB,EAAmD,CAAA,CAAE,CACrD,CAA6B,CAH/B,OAKE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,UAAU,CAAC,EAAiB,CAAA,EAAI,GAEvC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA,kBAAA,EAAqB,EAAe,OAAA,CAAS,CAAE,EAAyB,CACrG,MAAA,EACA,GAAG,CAAO,AACX,EACH,CACD,CA3ED,EAAA,OAAA,CAAA,IAAA,CAAA,CA6EA,OAAa,UAA2B,EAAxC,UAAA,CAAoE,CAApE,EAAA,OAAA,CAAA,kBAAA,CAAA,CAEA,OAAa,UAAgC,EAA7C,UAAA,CAA8E,CAA9E,EAAA,OAAA,CAAA,uBAAA,CAAA,EA6WgB,CANC,EAAA,EAAA,EAAA,OAAA,CAAA,IAAI,EAAJ,CAAA,EAAA,OAAA,CAAA,IAAI,CAAA,CAAA,CAAA,GAML,kBAAkB,CAAG,EAAQ,kBAAkB,CAC/C,EAAA,uBAAuB,CAAG,EAAQ,uBAAuB,CAIzD,EAAA,WAAW,CAAG,EAAe,WAAW,CAExC,EAAA,4BAA4B,CAAG,EAAe,4BAA4B,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,4B,C,E,O,C,W,C,K,E,I,E,E,S,E,E,SEvc1F,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAGA,OAAa,UAAoB,EAAjC,WAAA,CAaE,KACE,CAAuB,CACvB,EAAoD,CAAA,CAAE,CACtD,CAA6B,CAH/B,OAKE,AAAI,AAAA,CAAA,EAAA,EAAA,gBAAA,AAAA,EAAiB,GACZ,IAAI,CAAC,IAAI,CAAC,EAAiB,CAAA,EAAI,GAEjC,IAAI,CAAC,OAAO,CAAC,UAAU,CAC5B,CAAA,kBAAA,EAAqB,EAAe,YAAA,CAAc,CAClD,EACA,CAAE,MAAA,EAAO,GAAG,CAAO,AAAA,EAEvB,CACD,CA3BD,EAAA,OAAA,CAAA,WAAA,CAAA,CA6BA,OAAa,UAAqC,EAAlD,UAAA,CAAwF,CAAxF,EAAA,OAAA,CAAA,4BAAA,CAAA,EAoEgB,AAFC,CAAA,EAAA,EAAA,OAAA,CAAA,WAAW,EAAX,CAAA,EAAA,OAAA,CAAA,WAAW,CAAA,CAAA,CAAA,CAAA,EAEZ,4BAA4B,CAAG,EAAe,4BAA4B,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,M,C,K,E,I,E,E,SEtG1F,IAAA,EAAA,EAAA,EAAA,SAGA,OAAa,UAAe,EAA5B,WAAA,CAIE,gBACE,CAAgC,CAChC,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,qBAAsB,EAAK,2BAA2B,CAAC,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,GACpG,CAKA,KAAK,CAAqB,CAAE,CAA6B,CAAzD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAiB,EAAK,2BAA2B,CAAC,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,GAC/F,CAKA,SAAS,CAAyB,CAAE,CAA6B,CAAjE,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,sBAAuB,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EACpE,CACD,CAxBD,EAAA,OAAA,CAAA,MAAA,CAAA,EA2MiB,EAAA,OAAA,CAAA,MAAM,EAAN,CAAA,EAAA,OAAA,CAAA,MAAM,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,U,C,E,O,C,M,C,K,E,I,E,E,SE7MvB,IAAA,EAAA,EAAA,EAAA,OAAA,E,I,E,E,QAGA,OAAa,UAAe,EAA5B,WAAA,CAKE,SAAS,CAAa,CAAE,CAA6B,CAArD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,QAAA,EAAW,EAAK,CAAE,CAAE,EAC9C,CAMA,KAAK,CAA6B,CAAlC,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAW,EAAY,EACxD,CAMA,IAAI,CAAa,CAAE,CAA6B,CAAhD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA,QAAA,EAAW,EAAK,CAAE,CAAE,EACjD,CACD,CAxBD,EAAA,OAAA,CAAA,MAAA,CAAA,CA6BA,OAAa,UAAmB,EAD7B,IAAA,CAC2C,CAA9C,EAAA,OAAA,CAAA,UAAA,CAAA,EAsCgB,AAHC,CAAA,EAAA,EAAA,OAAA,CAAA,MAAM,EAAN,CAAA,EAAA,OAAA,CAAA,MAAM,CAAA,CAAA,CAAA,CAAA,EAGP,UAAU,CAAG,EAAU,UAAU,A,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,W,C,K,E,I,E,E,QEpEjD,OAAa,UAAoB,EAAjC,WAAA,CAKE,OACE,CAA4B,CAC5B,CAA6B,CAF/B,CAIE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,eAAgB,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EAC7D,CACD,CAXD,EAAA,OAAA,CAAA,WAAA,CAAA,EAiWiB,EAAA,OAAA,CAAA,WAAW,EAAX,CAAA,EAAA,OAAA,CAAA,WAAW,CAAA,CAAA,CAAA,C,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,O,C,K,E,I,E,E,SEjW5B,IAAA,EAAA,EAAA,EAAA,SAEA,OAAa,UAAgB,EAA7B,WAAA,CAAA,aAAA,C,K,I,WACE,IAAA,CAAA,KAAK,CAAmB,IAAI,EAAS,KAAK,CAAC,IAAI,CAAC,OAAO,CAyDzD,CAjCE,OAAO,CAAwB,CAAE,CAA6B,CAA9D,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAY,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EACzD,CAKA,OAAO,CAAgB,CAAE,CAA6B,CAAtD,CACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,OAAA,CAAS,CAAE,EAC1D,CAiBA,SACE,CAAgB,CAChB,CAA0B,CAC1B,CAA6B,CAH/B,CAKE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,EAAQ,SAAA,CAAW,CAAE,CAAE,KAAA,EAAM,GAAG,CAAO,AAAA,EAC9E,CACD,CA1DD,EAAA,OAAA,CAAA,OAAA,CAAA,EA6JgB,AAJC,CAAA,EAAA,EAAA,OAAA,CAAA,OAAO,EAAP,CAAA,EAAA,OAAA,CAAA,OAAO,CAAA,CAAA,CAAA,CAAA,EAIR,KAAK,CAAG,EAAS,KAAK,A,G,E,Q,S,C,C,C,E,I,E,E,O,E,E,O,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,I,E,O,wB,C,E,G,C,C,G,C,Q,E,C,E,U,C,E,Q,E,E,Y,A,C,G,C,E,C,W,C,E,I,W,O,C,C,E,A,C,C,E,O,c,C,E,E,E,E,S,C,C,C,C,C,C,C,E,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,E,O,E,E,O,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,E,O,E,E,O,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,Y,G,O,S,C,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,O,c,C,E,O,C,a,C,M,C,C,G,E,O,C,K,C,K,E,I,E,E,SElKtC,IAAA,EAAA,EAAA,EAAA,SAGA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","sources":["<anon>","node_modules/openai/index.js","node_modules/openai/src/index.ts","node_modules/openai/error.js","node_modules/openai/src/error.ts","node_modules/openai/core.js","node_modules/openai/src/core.ts","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/process/browser.js","node_modules/openai/version.js","node_modules/openai/src/version.ts","node_modules/openai/streaming.js","node_modules/openai/src/streaming.ts","node_modules/openai/_shims/index.js","node_modules/openai/_shims/registry.js","node_modules/openai/src/_shims/registry.ts","node_modules/openai/_shims/auto/runtime.js","node_modules/openai/src/_shims/auto/runtime.ts","node_modules/openai/_shims/web-runtime.js","node_modules/openai/src/_shims/web-runtime.ts","node_modules/openai/_shims/MultipartBody.js","node_modules/openai/src/_shims/MultipartBody.ts","node_modules/openai/uploads.js","node_modules/openai/src/uploads.ts","node_modules/openai/internal/qs/index.js","node_modules/openai/src/internal/qs/index.ts","node_modules/openai/internal/qs/formats.js","node_modules/openai/src/internal/qs/formats.ts","node_modules/openai/internal/qs/stringify.js","node_modules/openai/src/internal/qs/stringify.ts","node_modules/openai/internal/qs/utils.js","node_modules/openai/src/internal/qs/utils.ts","node_modules/openai/pagination.js","node_modules/openai/src/pagination.ts","node_modules/openai/resources/index.js","node_modules/openai/src/resources/index.ts","node_modules/openai/resources/chat/index.js","node_modules/openai/src/resources/chat/index.ts","node_modules/openai/resources/chat/completions.js","node_modules/openai/src/resources/chat/completions.ts","node_modules/openai/resource.js","node_modules/openai/src/resource.ts","node_modules/openai/resources/chat/chat.js","node_modules/openai/src/resources/chat/chat.ts","node_modules/openai/resources/shared.js","node_modules/openai/src/resources/shared.ts","node_modules/openai/resources/audio/audio.js","node_modules/openai/src/resources/audio/audio.ts","node_modules/openai/resources/audio/speech.js","node_modules/openai/src/resources/audio/speech.ts","node_modules/openai/resources/audio/transcriptions.js","node_modules/openai/src/resources/audio/transcriptions.ts","node_modules/openai/resources/audio/translations.js","node_modules/openai/src/resources/audio/translations.ts","node_modules/openai/resources/batches.js","node_modules/openai/src/resources/batches.ts","node_modules/openai/resources/beta/beta.js","node_modules/openai/src/resources/beta/beta.ts","node_modules/openai/resources/beta/assistants.js","node_modules/openai/src/resources/beta/assistants.ts","node_modules/openai/resources/beta/chat/chat.js","node_modules/openai/src/resources/beta/chat/chat.ts","node_modules/openai/resources/beta/chat/completions.js","node_modules/openai/src/resources/beta/chat/completions.ts","node_modules/openai/lib/ChatCompletionRunner.js","node_modules/openai/src/lib/ChatCompletionRunner.ts","node_modules/openai/lib/AbstractChatCompletionRunner.js","node_modules/openai/src/lib/AbstractChatCompletionRunner.ts","node_modules/openai/lib/RunnableFunction.js","node_modules/openai/src/lib/RunnableFunction.ts","node_modules/openai/lib/chatCompletionUtils.js","node_modules/openai/src/lib/chatCompletionUtils.ts","node_modules/openai/lib/EventStream.js","node_modules/openai/src/lib/EventStream.ts","node_modules/openai/lib/parser.js","node_modules/openai/src/lib/parser.ts","node_modules/openai/lib/ChatCompletionStreamingRunner.js","node_modules/openai/src/lib/ChatCompletionStreamingRunner.ts","node_modules/openai/lib/ChatCompletionStream.js","node_modules/openai/src/lib/ChatCompletionStream.ts","node_modules/openai/_vendor/partial-json-parser/parser.js","node_modules/openai/src/_vendor/partial-json-parser/parser.ts","node_modules/openai/resources/beta/threads/threads.js","node_modules/openai/src/resources/beta/threads/threads.ts","node_modules/openai/lib/AssistantStream.js","node_modules/openai/src/lib/AssistantStream.ts","node_modules/openai/resources/beta/threads/messages.js","node_modules/openai/src/resources/beta/threads/messages.ts","node_modules/openai/resources/beta/threads/runs/runs.js","node_modules/openai/src/resources/beta/threads/runs/runs.ts","node_modules/openai/resources/beta/threads/runs/steps.js","node_modules/openai/src/resources/beta/threads/runs/steps.ts","node_modules/openai/resources/beta/vector-stores/vector-stores.js","node_modules/openai/src/resources/beta/vector-stores/vector-stores.ts","node_modules/openai/resources/beta/vector-stores/file-batches.js","node_modules/openai/src/resources/beta/vector-stores/file-batches.ts","node_modules/openai/lib/Util.js","node_modules/openai/src/lib/Util.ts","node_modules/openai/resources/beta/vector-stores/files.js","node_modules/openai/src/resources/beta/vector-stores/files.ts","node_modules/openai/resources/completions.js","node_modules/openai/src/resources/completions.ts","node_modules/openai/resources/embeddings.js","node_modules/openai/src/resources/embeddings.ts","node_modules/openai/resources/files.js","node_modules/openai/src/resources/files.ts","node_modules/openai/resources/fine-tuning/fine-tuning.js","node_modules/openai/src/resources/fine-tuning/fine-tuning.ts","node_modules/openai/resources/fine-tuning/jobs/jobs.js","node_modules/openai/src/resources/fine-tuning/jobs/jobs.ts","node_modules/openai/resources/fine-tuning/jobs/checkpoints.js","node_modules/openai/src/resources/fine-tuning/jobs/checkpoints.ts","node_modules/openai/resources/images.js","node_modules/openai/src/resources/images.ts","node_modules/openai/resources/models.js","node_modules/openai/src/resources/models.ts","node_modules/openai/resources/moderations.js","node_modules/openai/src/resources/moderations.ts","node_modules/openai/resources/uploads/uploads.js","node_modules/openai/src/resources/uploads/uploads.ts","node_modules/openai/resources/uploads/parts.js","node_modules/openai/src/resources/uploads/parts.ts","script.js","chat.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire74b2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire74b2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"cM6Z0\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AzureOpenAI = exports.fileFromPath = exports.toFile = exports.UnprocessableEntityError = exports.PermissionDeniedError = exports.InternalServerError = exports.AuthenticationError = exports.BadRequestError = exports.RateLimitError = exports.ConflictError = exports.NotFoundError = exports.APIUserAbortError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIError = exports.OpenAIError = exports.OpenAI = void 0;\n\nconst Errors = __importStar((parcelRequire(\"hTt11\")));\n\nconst Uploads = __importStar((parcelRequire(\"laDyk\")));\n\nconst qs = __importStar((parcelRequire(\"bk3WJ\")));\n\nconst Core = __importStar((parcelRequire(\"9xH07\")));\n\nconst Pagination = __importStar((parcelRequire(\"61UiY\")));\n\nconst API = __importStar((parcelRequire(\"1X4UA\")));\n/**\n * API Client for interfacing with the OpenAI API.\n */ class OpenAI extends Core.APIClient {\n    /**\n     * API Client for interfacing with the OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */ constructor({ baseURL = Core.readEnv(\"OPENAI_BASE_URL\"), apiKey = Core.readEnv(\"OPENAI_API_KEY\"), organization = Core.readEnv(\"OPENAI_ORG_ID\") ?? null, project = Core.readEnv(\"OPENAI_PROJECT_ID\") ?? null, ...opts } = {}){\n        if (apiKey === undefined) throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        const options = {\n            apiKey: apiKey,\n            organization: organization,\n            project: project,\n            ...opts,\n            baseURL: baseURL || `https://api.openai.com/v1`\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */ ,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            \"OpenAI-Organization\": this.organization,\n            \"OpenAI-Project\": this.project,\n            ...this._options.defaultHeaders\n        };\n    }\n    authHeaders(opts) {\n        return {\n            Authorization: `Bearer ${this.apiKey}`\n        };\n    }\n    stringifyQuery(query) {\n        return qs.stringify(query, {\n            arrayFormat: \"brackets\"\n        });\n    }\n}\nexports.OpenAI = OpenAI;\n_a = OpenAI;\nOpenAI.OpenAI = _a;\nOpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes\nOpenAI.OpenAIError = Errors.OpenAIError;\nOpenAI.APIError = Errors.APIError;\nOpenAI.APIConnectionError = Errors.APIConnectionError;\nOpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nOpenAI.APIUserAbortError = Errors.APIUserAbortError;\nOpenAI.NotFoundError = Errors.NotFoundError;\nOpenAI.ConflictError = Errors.ConflictError;\nOpenAI.RateLimitError = Errors.RateLimitError;\nOpenAI.BadRequestError = Errors.BadRequestError;\nOpenAI.AuthenticationError = Errors.AuthenticationError;\nOpenAI.InternalServerError = Errors.InternalServerError;\nOpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\nOpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\nOpenAI.toFile = Uploads.toFile;\nOpenAI.fileFromPath = Uploads.fileFromPath;\nexports.OpenAIError = Errors.OpenAIError, exports.APIError = Errors.APIError, exports.APIConnectionError = Errors.APIConnectionError, exports.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError, exports.APIUserAbortError = Errors.APIUserAbortError, exports.NotFoundError = Errors.NotFoundError, exports.ConflictError = Errors.ConflictError, exports.RateLimitError = Errors.RateLimitError, exports.BadRequestError = Errors.BadRequestError, exports.AuthenticationError = Errors.AuthenticationError, exports.InternalServerError = Errors.InternalServerError, exports.PermissionDeniedError = Errors.PermissionDeniedError, exports.UnprocessableEntityError = Errors.UnprocessableEntityError;\nexports.toFile = Uploads.toFile;\nexports.fileFromPath = Uploads.fileFromPath;\n(function(OpenAI) {\n    OpenAI.Page = Pagination.Page;\n    OpenAI.CursorPage = Pagination.CursorPage;\n    OpenAI.Completions = API.Completions;\n    OpenAI.Chat = API.Chat;\n    OpenAI.Embeddings = API.Embeddings;\n    OpenAI.Files = API.Files;\n    OpenAI.FileObjectsPage = API.FileObjectsPage;\n    OpenAI.Images = API.Images;\n    OpenAI.Audio = API.Audio;\n    OpenAI.Moderations = API.Moderations;\n    OpenAI.Models = API.Models;\n    OpenAI.ModelsPage = API.ModelsPage;\n    OpenAI.FineTuning = API.FineTuning;\n    OpenAI.Beta = API.Beta;\n    OpenAI.Batches = API.Batches;\n    OpenAI.BatchesPage = API.BatchesPage;\n    OpenAI.Uploads = API.Uploads;\n})(OpenAI = exports.OpenAI || (exports.OpenAI = {}));\n/** API Client for interfacing with the Azure OpenAI API. */ class AzureOpenAI extends OpenAI {\n    /**\n     * API Client for interfacing with the Azure OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */ constructor({ baseURL = Core.readEnv(\"OPENAI_BASE_URL\"), apiKey = Core.readEnv(\"AZURE_OPENAI_API_KEY\"), apiVersion = Core.readEnv(\"OPENAI_API_VERSION\"), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}){\n        if (!apiVersion) throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        if (typeof azureADTokenProvider === \"function\") dangerouslyAllowBrowser = true;\n        if (!azureADTokenProvider && !apiKey) throw new Errors.OpenAIError(\"Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.\");\n        if (azureADTokenProvider && apiKey) throw new Errors.OpenAIError(\"The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.\");\n        // define a sentinel value to avoid any typing issues\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = {\n            ...opts.defaultQuery,\n            \"api-version\": apiVersion\n        };\n        if (!baseURL) {\n            if (!endpoint) endpoint = undefined;\n            if (!endpoint) throw new Errors.OpenAIError(\"Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable\");\n            baseURL = `${endpoint}/openai`;\n        } else {\n            if (endpoint) throw new Errors.OpenAIError(\"baseURL and endpoint are mutually exclusive\");\n        }\n        super({\n            apiKey: apiKey,\n            baseURL: baseURL,\n            ...opts,\n            ...dangerouslyAllowBrowser !== undefined ? {\n                dangerouslyAllowBrowser: dangerouslyAllowBrowser\n            } : {}\n        });\n        this.apiVersion = \"\";\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this._deployment = deployment;\n    }\n    buildRequest(options) {\n        if (_deployments_endpoints.has(options.path) && options.method === \"post\" && options.body !== undefined) {\n            if (!Core.isObj(options.body)) throw new Error(\"Expected request body to be an object\");\n            const model = this._deployment || options.body[\"model\"];\n            if (model !== undefined && !this.baseURL.includes(\"/deployments\")) options.path = `/deployments/${model}${options.path}`;\n        }\n        return super.buildRequest(options);\n    }\n    async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === \"function\") {\n            const token = await this._azureADTokenProvider();\n            if (!token || typeof token !== \"string\") throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n            return token;\n        }\n        return undefined;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    async prepareOptions(opts) {\n        /**\n         * The user should provide a bearer token provider if they want\n         * to use Azure AD authentication. The user shouldn't set the\n         * Authorization header manually because the header is overwritten\n         * with the Azure AD token if a bearer token provider is provided.\n         */ if (opts.headers?.[\"api-key\"]) return super.prepareOptions(opts);\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) opts.headers[\"Authorization\"] = `Bearer ${token}`;\n        else if (this.apiKey !== API_KEY_SENTINEL) opts.headers[\"api-key\"] = this.apiKey;\n        else throw new Errors.OpenAIError(\"Unable to handle auth\");\n        return super.prepareOptions(opts);\n    }\n}\nexports.AzureOpenAI = AzureOpenAI;\nconst _deployments_endpoints = new Set([\n    \"/completions\",\n    \"/chat/completions\",\n    \"/embeddings\",\n    \"/audio/transcriptions\",\n    \"/audio/translations\",\n    \"/audio/speech\",\n    \"/images/generations\"\n]);\nconst API_KEY_SENTINEL = \"<Missing Key>\";\n// ---------------------- End Azure ----------------------\nexports = module.exports = OpenAI;\nmodule.exports.AzureOpenAI = AzureOpenAI;\nexports.default = OpenAI;\n\n});\nparcelRegister(\"hTt11\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ContentFilterFinishReasonError = module.exports.LengthFinishReasonError = module.exports.InternalServerError = module.exports.RateLimitError = module.exports.UnprocessableEntityError = module.exports.ConflictError = module.exports.NotFoundError = module.exports.PermissionDeniedError = module.exports.AuthenticationError = module.exports.BadRequestError = module.exports.APIConnectionTimeoutError = module.exports.APIConnectionError = module.exports.APIUserAbortError = module.exports.APIError = module.exports.OpenAIError = void 0;\n\nvar $9xH07 = parcelRequire(\"9xH07\");\nclass $d06e149166359a9e$var$OpenAIError extends Error {\n}\nmodule.exports.OpenAIError = $d06e149166359a9e$var$OpenAIError;\nclass $d06e149166359a9e$var$APIError extends $d06e149166359a9e$var$OpenAIError {\n    constructor(status, error, message, headers){\n        super(`${$d06e149166359a9e$var$APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.[\"x-request-id\"];\n        const data = error;\n        this.error = data;\n        this.code = data?.[\"code\"];\n        this.param = data?.[\"param\"];\n        this.type = data?.[\"type\"];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ? typeof error.message === \"string\" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;\n        if (status && msg) return `${status} ${msg}`;\n        if (status) return `${status} status code (no body)`;\n        if (msg) return msg;\n        return \"(no status code or body)\";\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status) return new $d06e149166359a9e$var$APIConnectionError({\n            message: message,\n            cause: (0, $9xH07.castToError)(errorResponse)\n        });\n        const error = errorResponse?.[\"error\"];\n        if (status === 400) return new $d06e149166359a9e$var$BadRequestError(status, error, message, headers);\n        if (status === 401) return new $d06e149166359a9e$var$AuthenticationError(status, error, message, headers);\n        if (status === 403) return new $d06e149166359a9e$var$PermissionDeniedError(status, error, message, headers);\n        if (status === 404) return new $d06e149166359a9e$var$NotFoundError(status, error, message, headers);\n        if (status === 409) return new $d06e149166359a9e$var$ConflictError(status, error, message, headers);\n        if (status === 422) return new $d06e149166359a9e$var$UnprocessableEntityError(status, error, message, headers);\n        if (status === 429) return new $d06e149166359a9e$var$RateLimitError(status, error, message, headers);\n        if (status >= 500) return new $d06e149166359a9e$var$InternalServerError(status, error, message, headers);\n        return new $d06e149166359a9e$var$APIError(status, error, message, headers);\n    }\n}\nmodule.exports.APIError = $d06e149166359a9e$var$APIError;\nclass $d06e149166359a9e$var$APIUserAbortError extends $d06e149166359a9e$var$APIError {\n    constructor({ message: message } = {}){\n        super(undefined, undefined, message || \"Request was aborted.\", undefined);\n        this.status = undefined;\n    }\n}\nmodule.exports.APIUserAbortError = $d06e149166359a9e$var$APIUserAbortError;\nclass $d06e149166359a9e$var$APIConnectionError extends $d06e149166359a9e$var$APIError {\n    constructor({ message: message, cause: cause }){\n        super(undefined, undefined, message || \"Connection error.\", undefined);\n        this.status = undefined;\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause) this.cause = cause;\n    }\n}\nmodule.exports.APIConnectionError = $d06e149166359a9e$var$APIConnectionError;\nclass $d06e149166359a9e$var$APIConnectionTimeoutError extends $d06e149166359a9e$var$APIConnectionError {\n    constructor({ message: message } = {}){\n        super({\n            message: message ?? \"Request timed out.\"\n        });\n    }\n}\nmodule.exports.APIConnectionTimeoutError = $d06e149166359a9e$var$APIConnectionTimeoutError;\nclass $d06e149166359a9e$var$BadRequestError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 400;\n    }\n}\nmodule.exports.BadRequestError = $d06e149166359a9e$var$BadRequestError;\nclass $d06e149166359a9e$var$AuthenticationError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 401;\n    }\n}\nmodule.exports.AuthenticationError = $d06e149166359a9e$var$AuthenticationError;\nclass $d06e149166359a9e$var$PermissionDeniedError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 403;\n    }\n}\nmodule.exports.PermissionDeniedError = $d06e149166359a9e$var$PermissionDeniedError;\nclass $d06e149166359a9e$var$NotFoundError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 404;\n    }\n}\nmodule.exports.NotFoundError = $d06e149166359a9e$var$NotFoundError;\nclass $d06e149166359a9e$var$ConflictError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 409;\n    }\n}\nmodule.exports.ConflictError = $d06e149166359a9e$var$ConflictError;\nclass $d06e149166359a9e$var$UnprocessableEntityError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 422;\n    }\n}\nmodule.exports.UnprocessableEntityError = $d06e149166359a9e$var$UnprocessableEntityError;\nclass $d06e149166359a9e$var$RateLimitError extends $d06e149166359a9e$var$APIError {\n    constructor(){\n        super(...arguments);\n        this.status = 429;\n    }\n}\nmodule.exports.RateLimitError = $d06e149166359a9e$var$RateLimitError;\nclass $d06e149166359a9e$var$InternalServerError extends $d06e149166359a9e$var$APIError {\n}\nmodule.exports.InternalServerError = $d06e149166359a9e$var$InternalServerError;\nclass $d06e149166359a9e$var$LengthFinishReasonError extends $d06e149166359a9e$var$OpenAIError {\n    constructor(){\n        super(`Could not parse response content as the length limit was reached`);\n    }\n}\nmodule.exports.LengthFinishReasonError = $d06e149166359a9e$var$LengthFinishReasonError;\nclass $d06e149166359a9e$var$ContentFilterFinishReasonError extends $d06e149166359a9e$var$OpenAIError {\n    constructor(){\n        super(`Could not parse response content as the request was rejected by the content filter`);\n    }\n}\nmodule.exports.ContentFilterFinishReasonError = $d06e149166359a9e$var$ContentFilterFinishReasonError;\n\n});\nparcelRegister(\"9xH07\", function(module, exports) {\n\nvar $6ZWSX = parcelRequire(\"6ZWSX\");\nvar $6f288d3a82088e8b$require$Buffer = $6ZWSX.Buffer;\n\nvar $hPtJY = parcelRequire(\"hPtJY\");\n\"use strict\";\nvar $6f288d3a82088e8b$var$__classPrivateFieldSet = module.exports && module.exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar $6f288d3a82088e8b$var$__classPrivateFieldGet = module.exports && module.exports.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar $6f288d3a82088e8b$var$_AbstractPage_client;\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.isObj = module.exports.toBase64 = module.exports.getHeader = module.exports.getRequiredHeader = module.exports.isHeadersProtocol = module.exports.isRunningInBrowser = module.exports.debug = module.exports.hasOwn = module.exports.isEmptyObj = module.exports.maybeCoerceBoolean = module.exports.maybeCoerceFloat = module.exports.maybeCoerceInteger = module.exports.coerceBoolean = module.exports.coerceFloat = module.exports.coerceInteger = module.exports.readEnv = module.exports.ensurePresent = module.exports.castToError = module.exports.sleep = module.exports.safeJSON = module.exports.isRequestOptions = module.exports.createResponseHeaders = module.exports.PagePromise = module.exports.AbstractPage = module.exports.APIClient = module.exports.APIPromise = module.exports.createForm = module.exports.multipartFormRequestOptions = module.exports.maybeMultipartFormRequestOptions = void 0;\n\nvar $bNSG8 = parcelRequire(\"bNSG8\");\n\nvar $9Dbsu = parcelRequire(\"9Dbsu\");\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nvar $dJFm5 = parcelRequire(\"dJFm5\");\n\nvar $laDyk = parcelRequire(\"laDyk\");\n\nvar $laDyk = parcelRequire(\"laDyk\");\nObject.defineProperty(module.exports, \"maybeMultipartFormRequestOptions\", {\n    enumerable: true,\n    get: function() {\n        return $laDyk.maybeMultipartFormRequestOptions;\n    }\n});\nObject.defineProperty(module.exports, \"multipartFormRequestOptions\", {\n    enumerable: true,\n    get: function() {\n        return $laDyk.multipartFormRequestOptions;\n    }\n});\nObject.defineProperty(module.exports, \"createForm\", {\n    enumerable: true,\n    get: function() {\n        return $laDyk.createForm;\n    }\n});\nasync function $6f288d3a82088e8b$var$defaultParseResponse(props) {\n    const { response: response } = props;\n    if (props.options.stream) {\n        $6f288d3a82088e8b$var$debug(\"response\", response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        return $9Dbsu.Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) return null;\n    if (props.options.__binaryResponse) return response;\n    const contentType = response.headers.get(\"content-type\");\n    const isJSON = contentType?.includes(\"application/json\") || contentType?.includes(\"application/vnd.api+json\");\n    if (isJSON) {\n        const json = await response.json();\n        $6f288d3a82088e8b$var$debug(\"response\", response.status, response.url, response.headers, json);\n        return $6f288d3a82088e8b$var$_addRequestID(json, response);\n    }\n    const text = await response.text();\n    $6f288d3a82088e8b$var$debug(\"response\", response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction $6f288d3a82088e8b$var$_addRequestID(value, response) {\n    if (!value || typeof value !== \"object\" || Array.isArray(value)) return value;\n    return Object.defineProperty(value, \"_request_id\", {\n        value: response.headers.get(\"x-request-id\"),\n        enumerable: false\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */ class $6f288d3a82088e8b$var$APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = $6f288d3a82088e8b$var$defaultParseResponse){\n        super((resolve)=>{\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new $6f288d3a82088e8b$var$APIPromise(this.responsePromise, async (props)=>$6f288d3a82088e8b$var$_addRequestID(transform(await this.parseResponse(props)), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import … from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */ asResponse() {\n        return this.responsePromise.then((p)=>p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import … from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */ async withResponse() {\n        const [data, response] = await Promise.all([\n            this.parse(),\n            this.asResponse()\n        ]);\n        return {\n            data: data,\n            response: response,\n            request_id: response.headers.get(\"x-request-id\")\n        };\n    }\n    parse() {\n        if (!this.parsedPromise) this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nmodule.exports.APIPromise = $6f288d3a82088e8b$var$APIPromise;\nclass $6f288d3a82088e8b$var$APIClient {\n    constructor({ baseURL: baseURL, maxRetries: maxRetries = 2, timeout: timeout = 600000, httpAgent: httpAgent, fetch: overridenFetch }){\n        this.baseURL = baseURL;\n        this.maxRetries = $6f288d3a82088e8b$var$validatePositiveInteger(\"maxRetries\", maxRetries);\n        this.timeout = $6f288d3a82088e8b$var$validatePositiveInteger(\"timeout\", timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overridenFetch ?? $dJFm5.fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */ defaultHeaders(opts) {\n        return {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\",\n            \"User-Agent\": this.getUserAgent(),\n            ...$6f288d3a82088e8b$var$getPlatformHeaders(),\n            ...this.authHeaders(opts)\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */ validateHeaders(headers, customHeaders) {}\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${$6f288d3a82088e8b$var$uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest(\"get\", path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest(\"post\", path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest(\"patch\", path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest(\"put\", path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest(\"delete\", path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts)=>{\n            const body = opts && (0, $laDyk.isBlobLike)(opts?.body) ? new DataView(await opts.body.arrayBuffer()) : opts?.body instanceof DataView ? opts.body : opts?.body instanceof ArrayBuffer ? new DataView(opts.body) : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer) : opts?.body;\n            return {\n                method: method,\n                path: path,\n                ...opts,\n                body: body\n            };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, {\n            method: \"get\",\n            path: path,\n            ...opts\n        });\n    }\n    calculateContentLength(body) {\n        if (typeof body === \"string\") {\n            if (typeof $6f288d3a82088e8b$require$Buffer !== \"undefined\") return $6f288d3a82088e8b$require$Buffer.byteLength(body, \"utf8\").toString();\n            if (typeof TextEncoder !== \"undefined\") {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        } else if (ArrayBuffer.isView(body)) return body.byteLength.toString();\n        return null;\n    }\n    buildRequest(options, { retryCount: retryCount = 0 } = {}) {\n        const { method: method, path: path, query: query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === \"string\" ? options.body : (0, $laDyk.isMultipartBody)(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if (\"timeout\" in options) $6f288d3a82088e8b$var$validatePositiveInteger(\"timeout\", options.timeout);\n        const timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? (0, $dJFm5.getDefaultAgent)(url);\n        const minAgentTimeout = timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === \"number\" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) // Allow any given request to bump our agent active socket timeout.\n        // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n        // and without mutating agent we would need to create more of them.\n        // This tradeoff optimizes for performance.\n        httpAgent.options.timeout = minAgentTimeout;\n        if (this.idempotencyHeader && method !== \"get\") {\n            if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({\n            options: options,\n            headers: headers,\n            contentLength: contentLength,\n            retryCount: retryCount\n        });\n        const req = {\n            method: method,\n            ...body && {\n                body: body\n            },\n            headers: reqHeaders,\n            ...httpAgent && {\n                agent: httpAgent\n            },\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null\n        };\n        return {\n            req: req,\n            url: url,\n            timeout: timeout\n        };\n    }\n    buildHeaders({ options: options, headers: headers, contentLength: contentLength, retryCount: retryCount }) {\n        const reqHeaders = {};\n        if (contentLength) reqHeaders[\"content-length\"] = contentLength;\n        const defaultHeaders = this.defaultHeaders(options);\n        $6f288d3a82088e8b$var$applyHeadersMut(reqHeaders, defaultHeaders);\n        $6f288d3a82088e8b$var$applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if ((0, $laDyk.isMultipartBody)(options.body) && $dJFm5.kind !== \"node\") delete reqHeaders[\"content-type\"];\n        // Don't set the retry count header if it was already set or removed by the caller. We check `headers`,\n        // which can contain nulls, instead of `reqHeaders` to account for the removal case.\n        if ((0, module.exports.getHeader)(headers, \"x-stainless-retry-count\") === undefined) reqHeaders[\"x-stainless-retry-count\"] = String(retryCount);\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */ async prepareOptions(options) {}\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */ async prepareRequest(request, { url: url, options: options }) {}\n    parseHeaders(headers) {\n        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header)=>[\n                ...header\n            ])) : {\n            ...headers\n        };\n    }\n    makeStatusError(status, error, message, headers) {\n        return $hTt11.APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new $6f288d3a82088e8b$var$APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) retriesRemaining = maxRetries;\n        await this.prepareOptions(options);\n        const { req: req, url: url, timeout: timeout } = this.buildRequest(options, {\n            retryCount: maxRetries - retriesRemaining\n        });\n        await this.prepareRequest(req, {\n            url: url,\n            options: options\n        });\n        $6f288d3a82088e8b$var$debug(\"request\", url, options, req.headers);\n        if (options.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(module.exports.castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) throw new $hTt11.APIUserAbortError();\n            if (retriesRemaining) return this.retryRequest(options, retriesRemaining);\n            if (response.name === \"AbortError\") throw new $hTt11.APIConnectionTimeoutError();\n            throw new $hTt11.APIConnectionError({\n                cause: response\n            });\n        }\n        const responseHeaders = (0, module.exports.createResponseHeaders)(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                $6f288d3a82088e8b$var$debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e)=>(0, module.exports.castToError)(e).message);\n            const errJSON = (0, module.exports.safeJSON)(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            $6f288d3a82088e8b$var$debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return {\n            response: response,\n            options: options,\n            controller: controller\n        };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new $6f288d3a82088e8b$var$PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = $6f288d3a82088e8b$var$isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith(\"/\") && path.startsWith(\"/\") ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!$6f288d3a82088e8b$var$isEmptyObj(defaultQuery)) query = {\n            ...defaultQuery,\n            ...query\n        };\n        if (typeof query === \"object\" && query && !Array.isArray(query)) url.search = this.stringifyQuery(query);\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query).filter(([_, value])=>typeof value !== \"undefined\").map(([key, value])=>{\n            if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            if (value === null) return `${encodeURIComponent(key)}=`;\n            throw new $hTt11.OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        }).join(\"&\");\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal: signal, ...options } = init || {};\n        if (signal) signal.addEventListener(\"abort\", ()=>controller.abort());\n        const timeout = setTimeout(()=>controller.abort(), ms);\n        return this.getRequestClient()// use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        .fetch.call(undefined, url, {\n            signal: controller.signal,\n            ...options\n        }).finally(()=>{\n            clearTimeout(timeout);\n        });\n    }\n    getRequestClient() {\n        return {\n            fetch: this.fetch\n        };\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === \"true\") return true;\n        if (shouldRetryHeader === \"false\") return false;\n        // Retry on request timeouts.\n        if (response.status === 408) return true;\n        // Retry on lock timeouts.\n        if (response.status === 409) return true;\n        // Retry on rate limits.\n        if (response.status === 429) return true;\n        // Retry internal errors.\n        if (response.status >= 500) return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.[\"retry-after-ms\"];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) timeoutMillis = timeoutMs;\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.[\"retry-after\"];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) timeoutMillis = timeoutSeconds * 1000;\n            else timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await (0, module.exports.sleep)(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${$bNSG8.VERSION}`;\n    }\n}\nmodule.exports.APIClient = $6f288d3a82088e8b$var$APIClient;\nclass $6f288d3a82088e8b$var$AbstractPage {\n    constructor(client, response, body, options){\n        $6f288d3a82088e8b$var$_AbstractPage_client.set(this, void 0);\n        $6f288d3a82088e8b$var$__classPrivateFieldSet(this, $6f288d3a82088e8b$var$_AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length) return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) throw new $hTt11.OpenAIError(\"No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.\");\n        const nextOptions = {\n            ...this.options\n        };\n        if (\"params\" in nextInfo && typeof nextOptions.query === \"object\") nextOptions.query = {\n            ...nextOptions.query,\n            ...nextInfo.params\n        };\n        else if (\"url\" in nextInfo) {\n            const params = [\n                ...Object.entries(nextOptions.query || {}),\n                ...nextInfo.url.searchParams.entries()\n            ];\n            for (const [key, value] of params)nextInfo.url.searchParams.set(key, value);\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await $6f288d3a82088e8b$var$__classPrivateFieldGet(this, $6f288d3a82088e8b$var$_AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while(page.hasNextPage()){\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[($6f288d3a82088e8b$var$_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages())for (const item of page.getPaginatedItems())yield item;\n    }\n}\nmodule.exports.AbstractPage = $6f288d3a82088e8b$var$AbstractPage;\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */ class $6f288d3a82088e8b$var$PagePromise extends $6f288d3a82088e8b$var$APIPromise {\n    constructor(client, request, Page){\n        super(request, async (props)=>new Page(client, props.response, await $6f288d3a82088e8b$var$defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */ async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page)yield item;\n    }\n}\nmodule.exports.PagePromise = $6f288d3a82088e8b$var$PagePromise;\nconst $6f288d3a82088e8b$var$createResponseHeaders = (headers)=>{\n    return new Proxy(Object.fromEntries(// @ts-ignore\n    headers.entries()), {\n        get (target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        }\n    });\n};\nmodule.exports.createResponseHeaders = $6f288d3a82088e8b$var$createResponseHeaders;\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst $6f288d3a82088e8b$var$requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true\n};\nconst $6f288d3a82088e8b$var$isRequestOptions = (obj)=>{\n    return typeof obj === \"object\" && obj !== null && !$6f288d3a82088e8b$var$isEmptyObj(obj) && Object.keys(obj).every((k)=>$6f288d3a82088e8b$var$hasOwn($6f288d3a82088e8b$var$requestOptionsKeys, k));\n};\nmodule.exports.isRequestOptions = $6f288d3a82088e8b$var$isRequestOptions;\nconst $6f288d3a82088e8b$var$getPlatformProperties = ()=>{\n    if (typeof Deno !== \"undefined\" && Deno.build != null) return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": $bNSG8.VERSION,\n        \"X-Stainless-OS\": $6f288d3a82088e8b$var$normalizePlatform(Deno.build.os),\n        \"X-Stainless-Arch\": $6f288d3a82088e8b$var$normalizeArch(Deno.build.arch),\n        \"X-Stainless-Runtime\": \"deno\",\n        \"X-Stainless-Runtime-Version\": typeof Deno.version === \"string\" ? Deno.version : Deno.version?.deno ?? \"unknown\"\n    };\n    if (typeof EdgeRuntime !== \"undefined\") return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": $bNSG8.VERSION,\n        \"X-Stainless-OS\": \"Unknown\",\n        \"X-Stainless-Arch\": `other:${EdgeRuntime}`,\n        \"X-Stainless-Runtime\": \"edge\",\n        \"X-Stainless-Runtime-Version\": $hPtJY.version\n    };\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof $hPtJY !== \"undefined\" ? $hPtJY : 0) === \"[object process]\") return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": $bNSG8.VERSION,\n        \"X-Stainless-OS\": $6f288d3a82088e8b$var$normalizePlatform($hPtJY.platform),\n        \"X-Stainless-Arch\": $6f288d3a82088e8b$var$normalizeArch($hPtJY.arch),\n        \"X-Stainless-Runtime\": \"node\",\n        \"X-Stainless-Runtime-Version\": $hPtJY.version\n    };\n    const browserInfo = $6f288d3a82088e8b$var$getBrowserInfo();\n    if (browserInfo) return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": $bNSG8.VERSION,\n        \"X-Stainless-OS\": \"Unknown\",\n        \"X-Stainless-Arch\": \"unknown\",\n        \"X-Stainless-Runtime\": `browser:${browserInfo.browser}`,\n        \"X-Stainless-Runtime-Version\": browserInfo.version\n    };\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": $bNSG8.VERSION,\n        \"X-Stainless-OS\": \"Unknown\",\n        \"X-Stainless-Arch\": \"unknown\",\n        \"X-Stainless-Runtime\": \"unknown\",\n        \"X-Stainless-Runtime-Version\": \"unknown\"\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction $6f288d3a82088e8b$var$getBrowserInfo() {\n    if (typeof navigator === \"undefined\" || !navigator) return null;\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        {\n            key: \"edge\",\n            pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"ie\",\n            pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"ie\",\n            pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"chrome\",\n            pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"firefox\",\n            pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"safari\",\n            pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/\n        }\n    ];\n    // Find the FIRST matching browser\n    for (const { key: key, pattern: pattern } of browserPatterns){\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return {\n                browser: key,\n                version: `${major}.${minor}.${patch}`\n            };\n        }\n    }\n    return null;\n}\nconst $6f288d3a82088e8b$var$normalizeArch = (arch)=>{\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === \"x32\") return \"x32\";\n    if (arch === \"x86_64\" || arch === \"x64\") return \"x64\";\n    if (arch === \"arm\") return \"arm\";\n    if (arch === \"aarch64\" || arch === \"arm64\") return \"arm64\";\n    if (arch) return `other:${arch}`;\n    return \"unknown\";\n};\nconst $6f288d3a82088e8b$var$normalizePlatform = (platform)=>{\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes(\"ios\")) return \"iOS\";\n    if (platform === \"android\") return \"Android\";\n    if (platform === \"darwin\") return \"MacOS\";\n    if (platform === \"win32\") return \"Windows\";\n    if (platform === \"freebsd\") return \"FreeBSD\";\n    if (platform === \"openbsd\") return \"OpenBSD\";\n    if (platform === \"linux\") return \"Linux\";\n    if (platform) return `Other:${platform}`;\n    return \"Unknown\";\n};\nlet $6f288d3a82088e8b$var$_platformHeaders;\nconst $6f288d3a82088e8b$var$getPlatformHeaders = ()=>{\n    return $6f288d3a82088e8b$var$_platformHeaders ?? ($6f288d3a82088e8b$var$_platformHeaders = $6f288d3a82088e8b$var$getPlatformProperties());\n};\nconst $6f288d3a82088e8b$var$safeJSON = (text)=>{\n    try {\n        return JSON.parse(text);\n    } catch (err) {\n        return undefined;\n    }\n};\nmodule.exports.safeJSON = $6f288d3a82088e8b$var$safeJSON;\n// https://stackoverflow.com/a/19709846\nconst $6f288d3a82088e8b$var$startsWithSchemeRegexp = new RegExp(\"^(?:[a-z]+:)?//\", \"i\");\nconst $6f288d3a82088e8b$var$isAbsoluteURL = (url)=>{\n    return $6f288d3a82088e8b$var$startsWithSchemeRegexp.test(url);\n};\nconst $6f288d3a82088e8b$var$sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nmodule.exports.sleep = $6f288d3a82088e8b$var$sleep;\nconst $6f288d3a82088e8b$var$validatePositiveInteger = (name, n)=>{\n    if (typeof n !== \"number\" || !Number.isInteger(n)) throw new $hTt11.OpenAIError(`${name} must be an integer`);\n    if (n < 0) throw new $hTt11.OpenAIError(`${name} must be a positive integer`);\n    return n;\n};\nconst $6f288d3a82088e8b$var$castToError = (err)=>{\n    if (err instanceof Error) return err;\n    if (typeof err === \"object\" && err !== null) try {\n        return new Error(JSON.stringify(err));\n    } catch  {}\n    return new Error(err);\n};\nmodule.exports.castToError = $6f288d3a82088e8b$var$castToError;\nconst $6f288d3a82088e8b$var$ensurePresent = (value)=>{\n    if (value == null) throw new $hTt11.OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\nmodule.exports.ensurePresent = $6f288d3a82088e8b$var$ensurePresent;\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */ const $6f288d3a82088e8b$var$readEnv = (env)=>{\n    if (typeof $hPtJY !== \"undefined\") return $hPtJY.env?.[env]?.trim() ?? undefined;\n    if (typeof Deno !== \"undefined\") return Deno.env?.get?.(env)?.trim();\n    return undefined;\n};\nmodule.exports.readEnv = $6f288d3a82088e8b$var$readEnv;\nconst $6f288d3a82088e8b$var$coerceInteger = (value)=>{\n    if (typeof value === \"number\") return Math.round(value);\n    if (typeof value === \"string\") return parseInt(value, 10);\n    throw new $hTt11.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nmodule.exports.coerceInteger = $6f288d3a82088e8b$var$coerceInteger;\nconst $6f288d3a82088e8b$var$coerceFloat = (value)=>{\n    if (typeof value === \"number\") return value;\n    if (typeof value === \"string\") return parseFloat(value);\n    throw new $hTt11.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nmodule.exports.coerceFloat = $6f288d3a82088e8b$var$coerceFloat;\nconst $6f288d3a82088e8b$var$coerceBoolean = (value)=>{\n    if (typeof value === \"boolean\") return value;\n    if (typeof value === \"string\") return value === \"true\";\n    return Boolean(value);\n};\nmodule.exports.coerceBoolean = $6f288d3a82088e8b$var$coerceBoolean;\nconst $6f288d3a82088e8b$var$maybeCoerceInteger = (value)=>{\n    if (value === undefined) return undefined;\n    return (0, module.exports.coerceInteger)(value);\n};\nmodule.exports.maybeCoerceInteger = $6f288d3a82088e8b$var$maybeCoerceInteger;\nconst $6f288d3a82088e8b$var$maybeCoerceFloat = (value)=>{\n    if (value === undefined) return undefined;\n    return (0, module.exports.coerceFloat)(value);\n};\nmodule.exports.maybeCoerceFloat = $6f288d3a82088e8b$var$maybeCoerceFloat;\nconst $6f288d3a82088e8b$var$maybeCoerceBoolean = (value)=>{\n    if (value === undefined) return undefined;\n    return (0, module.exports.coerceBoolean)(value);\n};\nmodule.exports.maybeCoerceBoolean = $6f288d3a82088e8b$var$maybeCoerceBoolean;\n// https://stackoverflow.com/a/34491287\nfunction $6f288d3a82088e8b$var$isEmptyObj(obj) {\n    if (!obj) return true;\n    for(const _k in obj)return false;\n    return true;\n}\nmodule.exports.isEmptyObj = $6f288d3a82088e8b$var$isEmptyObj;\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction $6f288d3a82088e8b$var$hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nmodule.exports.hasOwn = $6f288d3a82088e8b$var$hasOwn;\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */ function $6f288d3a82088e8b$var$applyHeadersMut(targetHeaders, newHeaders) {\n    for(const k in newHeaders){\n        if (!$6f288d3a82088e8b$var$hasOwn(newHeaders, k)) continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey) continue;\n        const val = newHeaders[k];\n        if (val === null) delete targetHeaders[lowerKey];\n        else if (val !== undefined) targetHeaders[lowerKey] = val;\n    }\n}\nfunction $6f288d3a82088e8b$var$debug(action, ...args) {\n    if (typeof $hPtJY !== \"undefined\" && $hPtJY?.env?.[\"DEBUG\"] === \"true\") console.log(`OpenAI:DEBUG:${action}`, ...args);\n}\nmodule.exports.debug = $6f288d3a82088e8b$var$debug;\n/**\n * https://stackoverflow.com/a/2117523\n */ const $6f288d3a82088e8b$var$uuid4 = ()=>{\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\nconst $6f288d3a82088e8b$var$isRunningInBrowser = ()=>{\n    return(// @ts-ignore\n    typeof window !== \"undefined\" && // @ts-ignore\n    typeof window.document !== \"undefined\" && // @ts-ignore\n    typeof navigator !== \"undefined\");\n};\nmodule.exports.isRunningInBrowser = $6f288d3a82088e8b$var$isRunningInBrowser;\nconst $6f288d3a82088e8b$var$isHeadersProtocol = (headers)=>{\n    return typeof headers?.get === \"function\";\n};\nmodule.exports.isHeadersProtocol = $6f288d3a82088e8b$var$isHeadersProtocol;\nconst $6f288d3a82088e8b$var$getRequiredHeader = (headers, header)=>{\n    const foundHeader = (0, module.exports.getHeader)(headers, header);\n    if (foundHeader === undefined) throw new Error(`Could not find ${header} header`);\n    return foundHeader;\n};\nmodule.exports.getRequiredHeader = $6f288d3a82088e8b$var$getRequiredHeader;\nconst $6f288d3a82088e8b$var$getHeader = (headers, header)=>{\n    const lowerCasedHeader = header.toLowerCase();\n    if ((0, module.exports.isHeadersProtocol)(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2)=>g1 + g2.toUpperCase());\n        for (const key of [\n            header,\n            lowerCasedHeader,\n            header.toUpperCase(),\n            intercapsHeader\n        ]){\n            const value = headers.get(key);\n            if (value) return value;\n        }\n    }\n    for (const [key, value] of Object.entries(headers))if (key.toLowerCase() === lowerCasedHeader) {\n        if (Array.isArray(value)) {\n            if (value.length <= 1) return value[0];\n            console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n            return value[0];\n        }\n        return value;\n    }\n    return undefined;\n};\nmodule.exports.getHeader = $6f288d3a82088e8b$var$getHeader;\n/**\n * Encodes a string to Base64 format.\n */ const $6f288d3a82088e8b$var$toBase64 = (str)=>{\n    if (!str) return \"\";\n    if (typeof $6f288d3a82088e8b$require$Buffer !== \"undefined\") return $6f288d3a82088e8b$require$Buffer.from(str).toString(\"base64\");\n    if (typeof btoa !== \"undefined\") return btoa(str);\n    throw new $hTt11.OpenAIError(\"Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined\");\n};\nmodule.exports.toBase64 = $6f288d3a82088e8b$var$toBase64;\nfunction $6f288d3a82088e8b$var$isObj(obj) {\n    return obj != null && typeof obj === \"object\" && !Array.isArray(obj);\n}\nmodule.exports.isObj = $6f288d3a82088e8b$var$isObj;\n\n});\nparcelRegister(\"6ZWSX\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", () => $51861dfc7ca9d588$export$a143d493d941bafc, (v) => $51861dfc7ca9d588$export$a143d493d941bafc = v);\n$parcel$export(module.exports, \"INSPECT_MAX_BYTES\", () => $51861dfc7ca9d588$export$f99ded8fe4b79145, (v) => $51861dfc7ca9d588$export$f99ded8fe4b79145 = v);\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $51861dfc7ca9d588$export$a143d493d941bafc;\nvar $51861dfc7ca9d588$export$e4cf37d7f6fb9e0a;\nvar $51861dfc7ca9d588$export$f99ded8fe4b79145;\nvar $51861dfc7ca9d588$export$599f31c3813fae4d;\n\"use strict\";\n\nvar $kuxul = parcelRequire(\"kuxul\");\n\nvar $9NvM5 = parcelRequire(\"9NvM5\");\nconst $51861dfc7ca9d588$var$customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" // eslint-disable-line dot-notation\n ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") // eslint-disable-line dot-notation\n : null;\n$51861dfc7ca9d588$export$a143d493d941bafc = $51861dfc7ca9d588$var$Buffer;\n$51861dfc7ca9d588$export$e4cf37d7f6fb9e0a = $51861dfc7ca9d588$var$SlowBuffer;\n$51861dfc7ca9d588$export$f99ded8fe4b79145 = 50;\nconst $51861dfc7ca9d588$var$K_MAX_LENGTH = 0x7fffffff;\n$51861dfc7ca9d588$export$599f31c3813fae4d = $51861dfc7ca9d588$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT = $51861dfc7ca9d588$var$typedArraySupport();\nif (!$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $51861dfc7ca9d588$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, \"parent\", {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, \"offset\", {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $51861dfc7ca9d588$var$createBuffer(length) {\n    if (length > $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $51861dfc7ca9d588$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $51861dfc7ca9d588$var$allocUnsafe(arg);\n    }\n    return $51861dfc7ca9d588$var$from(arg, encodingOrOffset, length);\n}\n$51861dfc7ca9d588$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $51861dfc7ca9d588$var$from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") return $51861dfc7ca9d588$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $51861dfc7ca9d588$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($51861dfc7ca9d588$var$isInstance(value, ArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, ArrayBuffer)) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== \"undefined\" && ($51861dfc7ca9d588$var$isInstance(value, SharedArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, SharedArrayBuffer))) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === \"number\") throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $51861dfc7ca9d588$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $51861dfc7ca9d588$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") return $51861dfc7ca9d588$var$Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $51861dfc7ca9d588$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $51861dfc7ca9d588$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer, Uint8Array);\nfunction $51861dfc7ca9d588$var$assertSize(size) {\n    if (typeof size !== \"number\") throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $51861dfc7ca9d588$var$alloc(size, fill, encoding) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    if (size <= 0) return $51861dfc7ca9d588$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === \"string\" ? $51861dfc7ca9d588$var$createBuffer(size).fill(fill, encoding) : $51861dfc7ca9d588$var$createBuffer(size).fill(fill);\n    return $51861dfc7ca9d588$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $51861dfc7ca9d588$var$Buffer.alloc = function(size, fill, encoding) {\n    return $51861dfc7ca9d588$var$alloc(size, fill, encoding);\n};\nfunction $51861dfc7ca9d588$var$allocUnsafe(size) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    return $51861dfc7ca9d588$var$createBuffer(size < 0 ? 0 : $51861dfc7ca9d588$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $51861dfc7ca9d588$var$Buffer.allocUnsafe = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $51861dfc7ca9d588$var$Buffer.allocUnsafeSlow = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\nfunction $51861dfc7ca9d588$var$fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") encoding = \"utf8\";\n    if (!$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n    const length = $51861dfc7ca9d588$var$byteLength(string, encoding) | 0;\n    let buf = $51861dfc7ca9d588$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $51861dfc7ca9d588$var$checked(array.length) | 0;\n    const buf = $51861dfc7ca9d588$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayView(arrayView) {\n    if ($51861dfc7ca9d588$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $51861dfc7ca9d588$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $51861dfc7ca9d588$var$fromArrayLike(arrayView);\n}\nfunction $51861dfc7ca9d588$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromObject(obj) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(obj)) {\n        const len = $51861dfc7ca9d588$var$checked(obj.length) | 0;\n        const buf = $51861dfc7ca9d588$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== \"number\" || $51861dfc7ca9d588$var$numberIsNaN(obj.length)) return $51861dfc7ca9d588$var$createBuffer(0);\n        return $51861dfc7ca9d588$var$fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) return $51861dfc7ca9d588$var$fromArrayLike(obj.data);\n}\nfunction $51861dfc7ca9d588$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $51861dfc7ca9d588$var$K_MAX_LENGTH.toString(16) + \" bytes\");\n    return length | 0;\n}\nfunction $51861dfc7ca9d588$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $51861dfc7ca9d588$var$Buffer.alloc(+length);\n}\n$51861dfc7ca9d588$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $51861dfc7ca9d588$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$51861dfc7ca9d588$var$Buffer.compare = function compare(a, b) {\n    if ($51861dfc7ca9d588$var$isInstance(a, Uint8Array)) a = $51861dfc7ca9d588$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($51861dfc7ca9d588$var$isInstance(b, Uint8Array)) b = $51861dfc7ca9d588$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(a) || !$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$51861dfc7ca9d588$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $51861dfc7ca9d588$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $51861dfc7ca9d588$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($51861dfc7ca9d588$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) buf = $51861dfc7ca9d588$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $51861dfc7ca9d588$var$byteLength(string, encoding) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $51861dfc7ca9d588$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== \"string\") throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return len;\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8ToBytes(string).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return len * 2;\n        case \"hex\":\n            return len >>> 1;\n        case \"base64\":\n            return $51861dfc7ca9d588$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $51861dfc7ca9d588$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$51861dfc7ca9d588$var$Buffer.byteLength = $51861dfc7ca9d588$var$byteLength;\nfunction $51861dfc7ca9d588$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return \"\";\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return \"\";\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return \"\";\n    if (!encoding) encoding = \"utf8\";\n    while(true)switch(encoding){\n        case \"hex\":\n            return $51861dfc7ca9d588$var$hexSlice(this, start, end);\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8Slice(this, start, end);\n        case \"ascii\":\n            return $51861dfc7ca9d588$var$asciiSlice(this, start, end);\n        case \"latin1\":\n        case \"binary\":\n            return $51861dfc7ca9d588$var$latin1Slice(this, start, end);\n        case \"base64\":\n            return $51861dfc7ca9d588$var$base64Slice(this, start, end);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $51861dfc7ca9d588$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$51861dfc7ca9d588$var$Buffer.prototype._isBuffer = true;\nfunction $51861dfc7ca9d588$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for(let i = 0; i < len; i += 2)$51861dfc7ca9d588$var$swap(this, i, i + 1);\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for(let i = 0; i < len; i += 4){\n        $51861dfc7ca9d588$var$swap(this, i, i + 3);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for(let i = 0; i < len; i += 8){\n        $51861dfc7ca9d588$var$swap(this, i, i + 7);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 6);\n        $51861dfc7ca9d588$var$swap(this, i + 2, i + 5);\n        $51861dfc7ca9d588$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return $51861dfc7ca9d588$var$utf8Slice(this, 0, length);\n    return $51861dfc7ca9d588$var$slowToString.apply(this, arguments);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toLocaleString = $51861dfc7ca9d588$var$Buffer.prototype.toString;\n$51861dfc7ca9d588$var$Buffer.prototype.equals = function equals(b) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return $51861dfc7ca9d588$var$Buffer.compare(this, b) === 0;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.inspect = function inspect() {\n    let str = \"\";\n    const max = $51861dfc7ca9d588$export$f99ded8fe4b79145;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max) str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n};\nif ($51861dfc7ca9d588$var$customInspectSymbol) $51861dfc7ca9d588$var$Buffer.prototype[$51861dfc7ca9d588$var$customInspectSymbol] = $51861dfc7ca9d588$var$Buffer.prototype.inspect;\n$51861dfc7ca9d588$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($51861dfc7ca9d588$var$isInstance(target, Uint8Array)) target = $51861dfc7ca9d588$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError(\"out of range index\");\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $51861dfc7ca9d588$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($51861dfc7ca9d588$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") val = $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction $51861dfc7ca9d588$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $51861dfc7ca9d588$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($51861dfc7ca9d588$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $51861dfc7ca9d588$var$utf8Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$asciiWrite(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$base64Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$ucs2Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$51861dfc7ca9d588$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    if (!encoding) encoding = \"utf8\";\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"hex\":\n            return $51861dfc7ca9d588$var$hexWrite(this, string, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n            return $51861dfc7ca9d588$var$utf8Write(this, string, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return $51861dfc7ca9d588$var$asciiWrite(this, string, offset, length);\n        case \"base64\":\n            // Warning: maxLength not taken into account in base64Write\n            return $51861dfc7ca9d588$var$base64Write(this, string, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $51861dfc7ca9d588$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $51861dfc7ca9d588$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $kuxul.fromByteArray(buf);\n    else return $kuxul.fromByteArray(buf.slice(start, end));\n}\nfunction $51861dfc7ca9d588$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $51861dfc7ca9d588$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $51861dfc7ca9d588$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = \"\";\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $51861dfc7ca9d588$var$asciiSlice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$latin1Slice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = \"\";\n    for(let i = start; i < end; ++i)out += $51861dfc7ca9d588$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $51861dfc7ca9d588$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = \"\";\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $51861dfc7ca9d588$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\n$51861dfc7ca9d588$var$Buffer.prototype.readUintLE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUintBE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint8 = $51861dfc7ca9d588$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $9NvM5.read(this, offset, true, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $9NvM5.read(this, offset, false, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $9NvM5.read(this, offset, true, 52, 8);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $9NvM5.read(this, offset, false, 52, 8);\n};\nfunction $51861dfc7ca9d588$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintLE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintBE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint8 = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $51861dfc7ca9d588$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $51861dfc7ca9d588$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\nfunction $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction $51861dfc7ca9d588$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $9NvM5.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $51861dfc7ca9d588$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $9NvM5.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$51861dfc7ca9d588$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$51861dfc7ca9d588$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") throw new TypeError(\"encoding must be a string\");\n        if (typeof encoding === \"string\" && !$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === \"number\") val = val & 255;\n    else if (typeof val === \"boolean\") val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError(\"Out of range index\");\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === \"number\") for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $51861dfc7ca9d588$var$Buffer.isBuffer(val) ? val : $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $51861dfc7ca9d588$var$errors = {};\nfunction $51861dfc7ca9d588$var$E(sym, getMessage, Base) {\n    $51861dfc7ca9d588$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, \"message\", {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, \"code\", {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$51861dfc7ca9d588$var$E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return \"Attempt to access memory outside buffer bounds\";\n}, RangeError);\n$51861dfc7ca9d588$var$E(\"ERR_INVALID_ARG_TYPE\", function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$51861dfc7ca9d588$var$E(\"ERR_OUT_OF_RANGE\", function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $51861dfc7ca9d588$var$addNumericalSeparator(String(input));\n    else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $51861dfc7ca9d588$var$addNumericalSeparator(received);\n        received += \"n\";\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $51861dfc7ca9d588$var$addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength) {\n    $51861dfc7ca9d588$var$validateNumber(offset, \"offset\");\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $51861dfc7ca9d588$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n    }\n    $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength);\n}\nfunction $51861dfc7ca9d588$var$validateNumber(value, name) {\n    if (typeof value !== \"number\") throw new $51861dfc7ca9d588$var$errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n}\nfunction $51861dfc7ca9d588$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $51861dfc7ca9d588$var$validateNumber(value, type);\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n    }\n    if (length < 0) throw new $51861dfc7ca9d588$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $51861dfc7ca9d588$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $51861dfc7ca9d588$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split(\"=\")[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($51861dfc7ca9d588$var$INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + \"=\";\n    return str;\n}\nfunction $51861dfc7ca9d588$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error(\"Invalid code point\");\n    }\n    return bytes;\n}\nfunction $51861dfc7ca9d588$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$base64ToBytes(str) {\n    return $kuxul.toByteArray($51861dfc7ca9d588$var$base64clean(str));\n}\nfunction $51861dfc7ca9d588$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $51861dfc7ca9d588$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $51861dfc7ca9d588$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $51861dfc7ca9d588$var$hexSliceLookupTable = function() {\n    const alphabet = \"0123456789abcdef\";\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $51861dfc7ca9d588$var$defineBigIntMethod(fn) {\n    return typeof BigInt === \"undefined\" ? $51861dfc7ca9d588$var$BufferBigIntNotDefined : fn;\n}\nfunction $51861dfc7ca9d588$var$BufferBigIntNotDefined() {\n    throw new Error(\"BigInt not supported\");\n}\n\n});\nparcelRegister(\"kuxul\", function(module, exports) {\n\n$parcel$export(module.exports, \"toByteArray\", () => $eeb0961446aae8e3$export$d622b2ad8d90c771, (v) => $eeb0961446aae8e3$export$d622b2ad8d90c771 = v);\n$parcel$export(module.exports, \"fromByteArray\", () => $eeb0961446aae8e3$export$6100ba28696e12de, (v) => $eeb0961446aae8e3$export$6100ba28696e12de = v);\nvar $eeb0961446aae8e3$export$a48f0734ac7c2329;\nvar $eeb0961446aae8e3$export$d622b2ad8d90c771;\nvar $eeb0961446aae8e3$export$6100ba28696e12de;\n\"use strict\";\n$eeb0961446aae8e3$export$a48f0734ac7c2329 = $eeb0961446aae8e3$var$byteLength;\n$eeb0961446aae8e3$export$d622b2ad8d90c771 = $eeb0961446aae8e3$var$toByteArray;\n$eeb0961446aae8e3$export$6100ba28696e12de = $eeb0961446aae8e3$var$fromByteArray;\nvar $eeb0961446aae8e3$var$lookup = [];\nvar $eeb0961446aae8e3$var$revLookup = [];\nvar $eeb0961446aae8e3$var$Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar $eeb0961446aae8e3$var$code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor(var $eeb0961446aae8e3$var$i = 0, $eeb0961446aae8e3$var$len = $eeb0961446aae8e3$var$code.length; $eeb0961446aae8e3$var$i < $eeb0961446aae8e3$var$len; ++$eeb0961446aae8e3$var$i){\n    $eeb0961446aae8e3$var$lookup[$eeb0961446aae8e3$var$i] = $eeb0961446aae8e3$var$code[$eeb0961446aae8e3$var$i];\n    $eeb0961446aae8e3$var$revLookup[$eeb0961446aae8e3$var$code.charCodeAt($eeb0961446aae8e3$var$i)] = $eeb0961446aae8e3$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$eeb0961446aae8e3$var$revLookup[\"-\".charCodeAt(0)] = 62;\n$eeb0961446aae8e3$var$revLookup[\"_\".charCodeAt(0)] = 63;\nfunction $eeb0961446aae8e3$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $eeb0961446aae8e3$var$byteLength(b64) {\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$toByteArray(b64) {\n    var tmp;\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $eeb0961446aae8e3$var$Arr($eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 18 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 2 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 10 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $eeb0961446aae8e3$var$tripletToBase64(num) {\n    return $eeb0961446aae8e3$var$lookup[num >> 18 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 12 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 6 & 0x3F] + $eeb0961446aae8e3$var$lookup[num & 0x3F];\n}\nfunction $eeb0961446aae8e3$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($eeb0961446aae8e3$var$tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction $eeb0961446aae8e3$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($eeb0961446aae8e3$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 2] + $eeb0961446aae8e3$var$lookup[tmp << 4 & 0x3F] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 10] + $eeb0961446aae8e3$var$lookup[tmp >> 4 & 0x3F] + $eeb0961446aae8e3$var$lookup[tmp << 2 & 0x3F] + \"=\");\n    }\n    return parts.join(\"\");\n}\n\n});\n\nparcelRegister(\"9NvM5\", function(module, exports) {\n\n$parcel$export(module.exports, \"read\", () => $7221566bd4d49f44$export$aafa59e2e03f2942, (v) => $7221566bd4d49f44$export$aafa59e2e03f2942 = v);\n$parcel$export(module.exports, \"write\", () => $7221566bd4d49f44$export$68d8715fc104d294, (v) => $7221566bd4d49f44$export$68d8715fc104d294 = v);\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $7221566bd4d49f44$export$aafa59e2e03f2942;\nvar $7221566bd4d49f44$export$68d8715fc104d294;\n$7221566bd4d49f44$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$7221566bd4d49f44$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n});\n\n\nparcelRegister(\"hPtJY\", function(module, exports) {\n// shim for using process in browser\nvar $cfae44f0dfdf62c0$var$process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $cfae44f0dfdf62c0$var$cachedSetTimeout;\nvar $cfae44f0dfdf62c0$var$cachedClearTimeout;\nfunction $cfae44f0dfdf62c0$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $cfae44f0dfdf62c0$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        else $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        else $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    }\n})();\nfunction $cfae44f0dfdf62c0$var$runTimeout(fun) {\n    if ($cfae44f0dfdf62c0$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedSetTimeout === $cfae44f0dfdf62c0$var$defaultSetTimout || !$cfae44f0dfdf62c0$var$cachedSetTimeout) && setTimeout) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $cfae44f0dfdf62c0$var$runClearTimeout(marker) {\n    if ($cfae44f0dfdf62c0$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedClearTimeout === $cfae44f0dfdf62c0$var$defaultClearTimeout || !$cfae44f0dfdf62c0$var$cachedClearTimeout) && clearTimeout) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $cfae44f0dfdf62c0$var$queue = [];\nvar $cfae44f0dfdf62c0$var$draining = false;\nvar $cfae44f0dfdf62c0$var$currentQueue;\nvar $cfae44f0dfdf62c0$var$queueIndex = -1;\nfunction $cfae44f0dfdf62c0$var$cleanUpNextTick() {\n    if (!$cfae44f0dfdf62c0$var$draining || !$cfae44f0dfdf62c0$var$currentQueue) return;\n    $cfae44f0dfdf62c0$var$draining = false;\n    if ($cfae44f0dfdf62c0$var$currentQueue.length) $cfae44f0dfdf62c0$var$queue = $cfae44f0dfdf62c0$var$currentQueue.concat($cfae44f0dfdf62c0$var$queue);\n    else $cfae44f0dfdf62c0$var$queueIndex = -1;\n    if ($cfae44f0dfdf62c0$var$queue.length) $cfae44f0dfdf62c0$var$drainQueue();\n}\nfunction $cfae44f0dfdf62c0$var$drainQueue() {\n    if ($cfae44f0dfdf62c0$var$draining) return;\n    var timeout = $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$cleanUpNextTick);\n    $cfae44f0dfdf62c0$var$draining = true;\n    var len = $cfae44f0dfdf62c0$var$queue.length;\n    while(len){\n        $cfae44f0dfdf62c0$var$currentQueue = $cfae44f0dfdf62c0$var$queue;\n        $cfae44f0dfdf62c0$var$queue = [];\n        while(++$cfae44f0dfdf62c0$var$queueIndex < len)if ($cfae44f0dfdf62c0$var$currentQueue) $cfae44f0dfdf62c0$var$currentQueue[$cfae44f0dfdf62c0$var$queueIndex].run();\n        $cfae44f0dfdf62c0$var$queueIndex = -1;\n        len = $cfae44f0dfdf62c0$var$queue.length;\n    }\n    $cfae44f0dfdf62c0$var$currentQueue = null;\n    $cfae44f0dfdf62c0$var$draining = false;\n    $cfae44f0dfdf62c0$var$runClearTimeout(timeout);\n}\n$cfae44f0dfdf62c0$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $cfae44f0dfdf62c0$var$queue.push(new $cfae44f0dfdf62c0$var$Item(fun, args));\n    if ($cfae44f0dfdf62c0$var$queue.length === 1 && !$cfae44f0dfdf62c0$var$draining) $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $cfae44f0dfdf62c0$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$cfae44f0dfdf62c0$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$cfae44f0dfdf62c0$var$process.title = \"browser\";\n$cfae44f0dfdf62c0$var$process.browser = true;\n$cfae44f0dfdf62c0$var$process.env = {};\n$cfae44f0dfdf62c0$var$process.argv = [];\n$cfae44f0dfdf62c0$var$process.version = \"\"; // empty string to avoid regexp issues\n$cfae44f0dfdf62c0$var$process.versions = {};\nfunction $cfae44f0dfdf62c0$var$noop() {}\n$cfae44f0dfdf62c0$var$process.on = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.addListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.once = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.off = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeAllListeners = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.emit = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependOnceListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.listeners = function(name) {\n    return [];\n};\n$cfae44f0dfdf62c0$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.cwd = function() {\n    return \"/\";\n};\n$cfae44f0dfdf62c0$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.umask = function() {\n    return 0;\n};\n\n});\n\nparcelRegister(\"bNSG8\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.VERSION = void 0;\nmodule.exports.VERSION = \"4.66.1\"; // x-release-please-version\n\n});\n\nparcelRegister(\"9Dbsu\", function(module, exports) {\n\nvar $6ZWSX = parcelRequire(\"6ZWSX\");\nvar $7030a4fbf7735146$require$Buffer = $6ZWSX.Buffer;\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.readableStreamAsyncIterable = module.exports._decodeChunks = module.exports._iterSSEMessages = module.exports.Stream = void 0;\n\nvar $dJFm5 = parcelRequire(\"dJFm5\");\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nvar $hTt11 = parcelRequire(\"hTt11\");\nclass $7030a4fbf7735146$var$Stream {\n    constructor(iterator, controller){\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) throw new Error(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of $7030a4fbf7735146$var$_iterSSEMessages(response, controller)){\n                    if (done) continue;\n                    if (sse.data.startsWith(\"[DONE]\")) {\n                        done = true;\n                        continue;\n                    }\n                    if (sse.event === null) {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        } catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        if (data && data.error) throw new $hTt11.APIError(undefined, data.error, undefined, undefined);\n                        yield data;\n                    } else {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        } catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        // TODO: Is this where the error should be thrown?\n                        if (sse.event == \"error\") throw new $hTt11.APIError(undefined, data.error, data.message, undefined);\n                        yield {\n                            event: sse.event,\n                            data: data\n                        };\n                    }\n                }\n                done = true;\n            } catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === \"AbortError\") return;\n                throw e;\n            } finally{\n                // If the user `break`s, abort the ongoing request.\n                if (!done) controller.abort();\n            }\n        }\n        return new $7030a4fbf7735146$var$Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */ static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new $7030a4fbf7735146$var$LineDecoder();\n            const iter = $7030a4fbf7735146$var$readableStreamAsyncIterable(readableStream);\n            for await (const chunk of iter)for (const line of lineDecoder.decode(chunk))yield line;\n            for (const line of lineDecoder.flush())yield line;\n        }\n        async function* iterator() {\n            if (consumed) throw new Error(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()){\n                    if (done) continue;\n                    if (line) yield JSON.parse(line);\n                }\n                done = true;\n            } catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === \"AbortError\") return;\n                throw e;\n            } finally{\n                // If the user `break`s, abort the ongoing request.\n                if (!done) controller.abort();\n            }\n        }\n        return new $7030a4fbf7735146$var$Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */ tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue)=>{\n            return {\n                next: ()=>{\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                }\n            };\n        };\n        return [\n            new $7030a4fbf7735146$var$Stream(()=>teeIterator(left), this.controller),\n            new $7030a4fbf7735146$var$Stream(()=>teeIterator(right), this.controller)\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */ toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new $dJFm5.ReadableStream({\n            async start () {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull (ctrl) {\n                try {\n                    const { value: value, done: done } = await iter.next();\n                    if (done) return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + \"\\n\");\n                    ctrl.enqueue(bytes);\n                } catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel () {\n                await iter.return?.();\n            }\n        });\n    }\n}\nmodule.exports.Stream = $7030a4fbf7735146$var$Stream;\nasync function* $7030a4fbf7735146$var$_iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new $hTt11.OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new $7030a4fbf7735146$var$SSEDecoder();\n    const lineDecoder = new $7030a4fbf7735146$var$LineDecoder();\n    const iter = $7030a4fbf7735146$var$readableStreamAsyncIterable(response.body);\n    for await (const sseChunk of $7030a4fbf7735146$var$iterSSEChunks(iter))for (const line of lineDecoder.decode(sseChunk)){\n        const sse = sseDecoder.decode(line);\n        if (sse) yield sse;\n    }\n    for (const line of lineDecoder.flush()){\n        const sse = sseDecoder.decode(line);\n        if (sse) yield sse;\n    }\n}\nmodule.exports._iterSSEMessages = $7030a4fbf7735146$var$_iterSSEMessages;\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */ async function* $7030a4fbf7735146$var$iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator){\n        if (chunk == null) continue;\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === \"string\" ? new TextEncoder().encode(chunk) : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while((patternIndex = $7030a4fbf7735146$var$findDoubleNewlineIndex(data)) !== -1){\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) yield data;\n}\nfunction $7030a4fbf7735146$var$findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for(let i = 0; i < buffer.length - 2; i++){\n        if (buffer[i] === newline && buffer[i + 1] === newline) // \\n\\n\n        return i + 2;\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) // \\r\\r\n        return i + 2;\n        if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) // \\r\\n\\r\\n\n        return i + 4;\n    }\n    return -1;\n}\nclass $7030a4fbf7735146$var$SSEDecoder {\n    constructor(){\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith(\"\\r\")) line = line.substring(0, line.length - 1);\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length) return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join(\"\\n\"),\n                raw: this.chunks\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(\":\")) return null;\n        let [fieldname, _, value] = $7030a4fbf7735146$var$partition(line, \":\");\n        if (value.startsWith(\" \")) value = value.substring(1);\n        if (fieldname === \"event\") this.event = value;\n        else if (fieldname === \"data\") this.data.push(value);\n        return null;\n    }\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */ class $7030a4fbf7735146$var$LineDecoder {\n    constructor(){\n        this.buffer = [];\n        this.trailingCR = false;\n    }\n    decode(chunk) {\n        let text = this.decodeText(chunk);\n        if (this.trailingCR) {\n            text = \"\\r\" + text;\n            this.trailingCR = false;\n        }\n        if (text.endsWith(\"\\r\")) {\n            this.trailingCR = true;\n            text = text.slice(0, -1);\n        }\n        if (!text) return [];\n        const trailingNewline = $7030a4fbf7735146$var$LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || \"\");\n        let lines = text.split($7030a4fbf7735146$var$LineDecoder.NEWLINE_REGEXP);\n        // if there is a trailing new line then the last entry will be an empty\n        // string which we don't care about\n        if (trailingNewline) lines.pop();\n        if (lines.length === 1 && !trailingNewline) {\n            this.buffer.push(lines[0]);\n            return [];\n        }\n        if (this.buffer.length > 0) {\n            lines = [\n                this.buffer.join(\"\") + lines[0],\n                ...lines.slice(1)\n            ];\n            this.buffer = [];\n        }\n        if (!trailingNewline) this.buffer = [\n            lines.pop() || \"\"\n        ];\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null) return \"\";\n        if (typeof bytes === \"string\") return bytes;\n        // Node:\n        if (typeof $7030a4fbf7735146$require$Buffer !== \"undefined\") {\n            if (bytes instanceof $7030a4fbf7735146$require$Buffer) return bytes.toString();\n            if (bytes instanceof Uint8Array) return $7030a4fbf7735146$require$Buffer.from(bytes).toString();\n            throw new $hTt11.OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== \"undefined\") {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder(\"utf8\"));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new $hTt11.OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new $hTt11.OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length && !this.trailingCR) return [];\n        const lines = [\n            this.buffer.join(\"\")\n        ];\n        this.buffer = [];\n        this.trailingCR = false;\n        return lines;\n    }\n}\n// prettier-ignore\n$7030a4fbf7735146$var$LineDecoder.NEWLINE_CHARS = new Set([\n    \"\\n\",\n    \"\\r\"\n]);\n$7030a4fbf7735146$var$LineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/** This is an internal helper function that's just used for testing */ function $7030a4fbf7735146$var$_decodeChunks(chunks) {\n    const decoder = new $7030a4fbf7735146$var$LineDecoder();\n    const lines = [];\n    for (const chunk of chunks)lines.push(...decoder.decode(chunk));\n    return lines;\n}\nmodule.exports._decodeChunks = $7030a4fbf7735146$var$_decodeChunks;\nfunction $7030a4fbf7735146$var$partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) return [\n        str.substring(0, index),\n        delimiter,\n        str.substring(index + delimiter.length)\n    ];\n    return [\n        str,\n        \"\",\n        \"\"\n    ];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */ function $7030a4fbf7735146$var$readableStreamAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator]) return stream;\n    const reader = stream.getReader();\n    return {\n        async next () {\n            try {\n                const result = await reader.read();\n                if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            } catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return () {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return {\n                done: true,\n                value: undefined\n            };\n        },\n        [Symbol.asyncIterator] () {\n            return this;\n        }\n    };\n}\nmodule.exports.readableStreamAsyncIterable = $7030a4fbf7735146$var$readableStreamAsyncIterable;\n\n});\nparcelRegister(\"dJFm5\", function(module, exports) {\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */ \nvar $gnmoI = parcelRequire(\"gnmoI\");\n\nvar $7XsUa = parcelRequire(\"7XsUa\");\nif (!$gnmoI.kind) $gnmoI.setShims($7XsUa.getRuntime(), {\n    auto: true\n});\nfor (const property of Object.keys($gnmoI))Object.defineProperty(module.exports, property, {\n    get () {\n        return $gnmoI[property];\n    }\n});\n\n});\nparcelRegister(\"gnmoI\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.setShims = module.exports.isFsReadStream = module.exports.fileFromPath = module.exports.getDefaultAgent = module.exports.getMultipartRequestOptions = module.exports.ReadableStream = module.exports.File = module.exports.Blob = module.exports.FormData = module.exports.Headers = module.exports.Response = module.exports.Request = module.exports.fetch = module.exports.kind = module.exports.auto = void 0;\nmodule.exports.auto = false;\nmodule.exports.kind = undefined;\nmodule.exports.fetch = undefined;\nmodule.exports.Request = undefined;\nmodule.exports.Response = undefined;\nmodule.exports.Headers = undefined;\nmodule.exports.FormData = undefined;\nmodule.exports.Blob = undefined;\nmodule.exports.File = undefined;\nmodule.exports.ReadableStream = undefined;\nmodule.exports.getMultipartRequestOptions = undefined;\nmodule.exports.getDefaultAgent = undefined;\nmodule.exports.fileFromPath = undefined;\nmodule.exports.isFsReadStream = undefined;\nfunction $bec02b01f4bfdff5$var$setShims(shims, options = {\n    auto: false\n}) {\n    if (module.exports.auto) throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n    if (module.exports.kind) throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${module.exports.kind}'\\``);\n    module.exports.auto = options.auto;\n    module.exports.kind = shims.kind;\n    module.exports.fetch = shims.fetch;\n    module.exports.Request = shims.Request;\n    module.exports.Response = shims.Response;\n    module.exports.Headers = shims.Headers;\n    module.exports.FormData = shims.FormData;\n    module.exports.Blob = shims.Blob;\n    module.exports.File = shims.File;\n    module.exports.ReadableStream = shims.ReadableStream;\n    module.exports.getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    module.exports.getDefaultAgent = shims.getDefaultAgent;\n    module.exports.fileFromPath = shims.fileFromPath;\n    module.exports.isFsReadStream = shims.isFsReadStream;\n}\nmodule.exports.setShims = $bec02b01f4bfdff5$var$setShims;\n\n});\n\nparcelRegister(\"7XsUa\", function(module, exports) {\n\"use strict\";\nvar $5cb476ff57f7ce12$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $5cb476ff57f7ce12$var$__exportStar = module.exports && module.exports.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) $5cb476ff57f7ce12$var$__createBinding(exports1, m, p);\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */ $5cb476ff57f7ce12$var$__exportStar((parcelRequire(\"3ovWK\")), module.exports);\n\n});\nparcelRegister(\"3ovWK\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.getRuntime = void 0;\n\nvar $h7UJD = parcelRequire(\"h7UJD\");\nfunction $278c64e52a7e776e$var$getRuntime({ manuallyImported: manuallyImported } = {}) {\n    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \\`import \\u{2026} from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n    let _fetch, _Request, _Response, _Headers;\n    try {\n        // @ts-ignore\n        _fetch = fetch;\n        // @ts-ignore\n        _Request = Request;\n        // @ts-ignore\n        _Response = Response;\n        // @ts-ignore\n        _Headers = Headers;\n    } catch (error) {\n        throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n    }\n    return {\n        kind: \"web\",\n        fetch: _fetch,\n        Request: _Request,\n        Response: _Response,\n        Headers: _Headers,\n        FormData: // @ts-ignore\n        typeof FormData !== \"undefined\" ? FormData : class FormData1 {\n            // @ts-ignore\n            constructor(){\n                throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n            }\n        },\n        Blob: typeof Blob !== \"undefined\" ? Blob : class Blob1 {\n            constructor(){\n                throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n            }\n        },\n        File: // @ts-ignore\n        typeof File !== \"undefined\" ? File : class File1 {\n            // @ts-ignore\n            constructor(){\n                throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n            }\n        },\n        ReadableStream: // @ts-ignore\n        typeof ReadableStream !== \"undefined\" ? ReadableStream : class ReadableStream1 {\n            // @ts-ignore\n            constructor(){\n                throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n            }\n        },\n        getMultipartRequestOptions: async (// @ts-ignore\n        form, opts)=>({\n                ...opts,\n                body: new $h7UJD.MultipartBody(form)\n            }),\n        getDefaultAgent: (url)=>undefined,\n        fileFromPath: ()=>{\n            throw new Error(\"The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads\");\n        },\n        isFsReadStream: (value)=>false\n    };\n}\nmodule.exports.getRuntime = $278c64e52a7e776e$var$getRuntime;\n\n});\nparcelRegister(\"h7UJD\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.MultipartBody = void 0;\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */ class $c77f1980f472f1fb$var$MultipartBody {\n    constructor(body){\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return \"MultipartBody\";\n    }\n}\nmodule.exports.MultipartBody = $c77f1980f472f1fb$var$MultipartBody;\n\n});\n\n\n\n\n\nparcelRegister(\"laDyk\", function(module, exports) {\n\nvar $6ZWSX = parcelRequire(\"6ZWSX\");\nvar $f6993680408976e3$require$Buffer = $6ZWSX.Buffer;\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.createForm = module.exports.multipartFormRequestOptions = module.exports.maybeMultipartFormRequestOptions = module.exports.isMultipartBody = module.exports.toFile = module.exports.isUploadable = module.exports.isBlobLike = module.exports.isFileLike = module.exports.isResponseLike = module.exports.fileFromPath = void 0;\n\nvar $dJFm5 = parcelRequire(\"dJFm5\");\n\nvar $dJFm5 = parcelRequire(\"dJFm5\");\nObject.defineProperty(module.exports, \"fileFromPath\", {\n    enumerable: true,\n    get: function() {\n        return $dJFm5.fileFromPath;\n    }\n});\nconst $f6993680408976e3$var$isResponseLike = (value)=>value != null && typeof value === \"object\" && typeof value.url === \"string\" && typeof value.blob === \"function\";\nmodule.exports.isResponseLike = $f6993680408976e3$var$isResponseLike;\nconst $f6993680408976e3$var$isFileLike = (value)=>value != null && typeof value === \"object\" && typeof value.name === \"string\" && typeof value.lastModified === \"number\" && (0, module.exports.isBlobLike)(value);\nmodule.exports.isFileLike = $f6993680408976e3$var$isFileLike;\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */ const $f6993680408976e3$var$isBlobLike = (value)=>value != null && typeof value === \"object\" && typeof value.size === \"number\" && typeof value.type === \"string\" && typeof value.text === \"function\" && typeof value.slice === \"function\" && typeof value.arrayBuffer === \"function\";\nmodule.exports.isBlobLike = $f6993680408976e3$var$isBlobLike;\nconst $f6993680408976e3$var$isUploadable = (value)=>{\n    return (0, module.exports.isFileLike)(value) || (0, module.exports.isResponseLike)(value) || (0, $dJFm5.isFsReadStream)(value);\n};\nmodule.exports.isUploadable = $f6993680408976e3$var$isUploadable;\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */ async function $f6993680408976e3$var$toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if ((0, module.exports.isFileLike)(value)) return value;\n    if ((0, module.exports.isResponseLike)(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? \"unknown_file\");\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = (0, module.exports.isBlobLike)(blob) ? [\n            await blob.arrayBuffer()\n        ] : [\n            blob\n        ];\n        return new $dJFm5.File(data, name, options);\n    }\n    const bits = await $f6993680408976e3$var$getBytes(value);\n    name || (name = $f6993680408976e3$var$getName(value) ?? \"unknown_file\");\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === \"string\") options = {\n            ...options,\n            type: type\n        };\n    }\n    return new $dJFm5.File(bits, name, options);\n}\nmodule.exports.toFile = $f6993680408976e3$var$toFile;\nasync function $f6993680408976e3$var$getBytes(value) {\n    let parts = [];\n    if (typeof value === \"string\" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer) parts.push(value);\n    else if ((0, module.exports.isBlobLike)(value)) parts.push(await value.arrayBuffer());\n    else if ($f6993680408976e3$var$isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) for await (const chunk of value)parts.push(chunk); // TODO, consider validating?\n    else throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${$f6993680408976e3$var$propsForError(value)}`);\n    return parts;\n}\nfunction $f6993680408976e3$var$propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p)=>`\"${p}\"`).join(\", \")}]`;\n}\nfunction $f6993680408976e3$var$getName(value) {\n    return $f6993680408976e3$var$getStringFromMaybeBuffer(value.name) || $f6993680408976e3$var$getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream\n    $f6993680408976e3$var$getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop();\n}\nconst $f6993680408976e3$var$getStringFromMaybeBuffer = (x)=>{\n    if (typeof x === \"string\") return x;\n    if (typeof $f6993680408976e3$require$Buffer !== \"undefined\" && x instanceof $f6993680408976e3$require$Buffer) return String(x);\n    return undefined;\n};\nconst $f6993680408976e3$var$isAsyncIterableIterator = (value)=>value != null && typeof value === \"object\" && typeof value[Symbol.asyncIterator] === \"function\";\nconst $f6993680408976e3$var$isMultipartBody = (body)=>body && typeof body === \"object\" && body.body && body[Symbol.toStringTag] === \"MultipartBody\";\nmodule.exports.isMultipartBody = $f6993680408976e3$var$isMultipartBody;\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */ const $f6993680408976e3$var$maybeMultipartFormRequestOptions = async (opts)=>{\n    if (!$f6993680408976e3$var$hasUploadableValue(opts.body)) return opts;\n    const form = await (0, module.exports.createForm)(opts.body);\n    return (0, $dJFm5.getMultipartRequestOptions)(form, opts);\n};\nmodule.exports.maybeMultipartFormRequestOptions = $f6993680408976e3$var$maybeMultipartFormRequestOptions;\nconst $f6993680408976e3$var$multipartFormRequestOptions = async (opts)=>{\n    const form = await (0, module.exports.createForm)(opts.body);\n    return (0, $dJFm5.getMultipartRequestOptions)(form, opts);\n};\nmodule.exports.multipartFormRequestOptions = $f6993680408976e3$var$multipartFormRequestOptions;\nconst $f6993680408976e3$var$createForm = async (body)=>{\n    const form = new $dJFm5.FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value])=>$f6993680408976e3$var$addFormValue(form, key, value)));\n    return form;\n};\nmodule.exports.createForm = $f6993680408976e3$var$createForm;\nconst $f6993680408976e3$var$hasUploadableValue = (value)=>{\n    if ((0, module.exports.isUploadable)(value)) return true;\n    if (Array.isArray(value)) return value.some($f6993680408976e3$var$hasUploadableValue);\n    if (value && typeof value === \"object\") for(const k in value){\n        if ($f6993680408976e3$var$hasUploadableValue(value[k])) return true;\n    }\n    return false;\n};\nconst $f6993680408976e3$var$addFormValue = async (form, key, value)=>{\n    if (value === undefined) return;\n    if (value == null) throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    // TODO: make nested formats configurable\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") form.append(key, String(value));\n    else if ((0, module.exports.isUploadable)(value)) {\n        const file = await $f6993680408976e3$var$toFile(value);\n        form.append(key, file);\n    } else if (Array.isArray(value)) await Promise.all(value.map((entry)=>$f6993680408976e3$var$addFormValue(form, key + \"[]\", entry)));\n    else if (typeof value === \"object\") await Promise.all(Object.entries(value).map(([name, prop])=>$f6993680408976e3$var$addFormValue(form, `${key}[${name}]`, prop)));\n    else throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n};\n\n});\n\n\n\nparcelRegister(\"bk3WJ\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.formats = module.exports.stringify = void 0;\n\nvar $324yj = parcelRequire(\"324yj\");\nconst $83e49f994ad17dad$var$formats = {\n    formatters: $324yj.formatters,\n    RFC1738: $324yj.RFC1738,\n    RFC3986: $324yj.RFC3986,\n    default: $324yj.default_format\n};\nmodule.exports.formats = $83e49f994ad17dad$var$formats;\n\nvar $ckmPh = parcelRequire(\"ckmPh\");\nObject.defineProperty(module.exports, \"stringify\", {\n    enumerable: true,\n    get: function() {\n        return $ckmPh.stringify;\n    }\n});\n\n});\nparcelRegister(\"324yj\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.RFC3986 = module.exports.RFC1738 = module.exports.formatters = module.exports.default_format = void 0;\nmodule.exports.default_format = \"RFC3986\";\nmodule.exports.formatters = {\n    RFC1738: (v)=>String(v).replace(/%20/g, \"+\"),\n    RFC3986: (v)=>String(v)\n};\nmodule.exports.RFC1738 = \"RFC1738\";\nmodule.exports.RFC3986 = \"RFC3986\";\n\n});\n\nparcelRegister(\"ckmPh\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.stringify = void 0;\n\nvar $3JE24 = parcelRequire(\"3JE24\");\n\nvar $324yj = parcelRequire(\"324yj\");\nconst $8f990f113c373965$var$has = Object.prototype.hasOwnProperty;\nconst $8f990f113c373965$var$array_prefix_generators = {\n    brackets (prefix) {\n        return String(prefix) + \"[]\";\n    },\n    comma: \"comma\",\n    indices (prefix, key) {\n        return String(prefix) + \"[\" + key + \"]\";\n    },\n    repeat (prefix) {\n        return String(prefix);\n    }\n};\nconst $8f990f113c373965$var$is_array = Array.isArray;\nconst $8f990f113c373965$var$push = Array.prototype.push;\nconst $8f990f113c373965$var$push_to_array = function(arr, value_or_array) {\n    $8f990f113c373965$var$push.apply(arr, $8f990f113c373965$var$is_array(value_or_array) ? value_or_array : [\n        value_or_array\n    ]);\n};\nconst $8f990f113c373965$var$to_ISO = Date.prototype.toISOString;\nconst $8f990f113c373965$var$defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: \"indices\",\n    charset: \"utf-8\",\n    charsetSentinel: false,\n    delimiter: \"&\",\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: $3JE24.encode,\n    encodeValuesOnly: false,\n    format: $324yj.default_format,\n    formatter: $324yj.formatters[$324yj.default_format],\n    /** @deprecated */ indices: false,\n    serializeDate (date) {\n        return $8f990f113c373965$var$to_ISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\nfunction $8f990f113c373965$var$is_non_nullish_primitive(v) {\n    return typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"symbol\" || typeof v === \"bigint\";\n}\nconst $8f990f113c373965$var$sentinel = {};\nfunction $8f990f113c373965$var$inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n    let obj = object;\n    let tmp_sc = sideChannel;\n    let step = 0;\n    let find_flag = false;\n    while((tmp_sc = tmp_sc.get($8f990f113c373965$var$sentinel)) !== void 0 && !find_flag){\n        // Where object last appeared in the ref tree\n        const pos = tmp_sc.get(object);\n        step += 1;\n        if (typeof pos !== \"undefined\") {\n            if (pos === step) throw new RangeError(\"Cyclic object value\");\n            else find_flag = true; // Break while\n        }\n        if (typeof tmp_sc.get($8f990f113c373965$var$sentinel) === \"undefined\") step = 0;\n    }\n    if (typeof filter === \"function\") obj = filter(prefix, obj);\n    else if (obj instanceof Date) obj = serializeDate?.(obj);\n    else if (generateArrayPrefix === \"comma\" && $8f990f113c373965$var$is_array(obj)) obj = (0, $3JE24.maybe_map)(obj, function(value) {\n        if (value instanceof Date) return serializeDate?.(value);\n        return value;\n    });\n    if (obj === null) {\n        if (strictNullHandling) return encoder && !encodeValuesOnly ? // @ts-expect-error\n        encoder(prefix, $8f990f113c373965$var$defaults.encoder, charset, \"key\", format) : prefix;\n        obj = \"\";\n    }\n    if ($8f990f113c373965$var$is_non_nullish_primitive(obj) || (0, $3JE24.is_buffer)(obj)) {\n        if (encoder) {\n            const key_value = encodeValuesOnly ? prefix : encoder(prefix, $8f990f113c373965$var$defaults.encoder, charset, \"key\", format);\n            return [\n                formatter?.(key_value) + \"=\" + // @ts-expect-error\n                formatter?.(encoder(obj, $8f990f113c373965$var$defaults.encoder, charset, \"value\", format))\n            ];\n        }\n        return [\n            formatter?.(prefix) + \"=\" + formatter?.(String(obj))\n        ];\n    }\n    const values = [];\n    if (typeof obj === \"undefined\") return values;\n    let obj_keys;\n    if (generateArrayPrefix === \"comma\" && $8f990f113c373965$var$is_array(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) // @ts-expect-error values only\n        obj = (0, $3JE24.maybe_map)(obj, encoder);\n        obj_keys = [\n            {\n                value: obj.length > 0 ? obj.join(\",\") || null : void 0\n            }\n        ];\n    } else if ($8f990f113c373965$var$is_array(filter)) obj_keys = filter;\n    else {\n        const keys = Object.keys(obj);\n        obj_keys = sort ? keys.sort(sort) : keys;\n    }\n    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, \"%2E\") : String(prefix);\n    const adjusted_prefix = commaRoundTrip && $8f990f113c373965$var$is_array(obj) && obj.length === 1 ? encoded_prefix + \"[]\" : encoded_prefix;\n    if (allowEmptyArrays && $8f990f113c373965$var$is_array(obj) && obj.length === 0) return adjusted_prefix + \"[]\";\n    for(let j = 0; j < obj_keys.length; ++j){\n        const key = obj_keys[j];\n        const value = // @ts-ignore\n        typeof key === \"object\" && typeof key.value !== \"undefined\" ? key.value : obj[key];\n        if (skipNulls && value === null) continue;\n        // @ts-ignore\n        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, \"%2E\") : key;\n        const key_prefix = $8f990f113c373965$var$is_array(obj) ? typeof generateArrayPrefix === \"function\" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? \".\" + encoded_key : \"[\" + encoded_key + \"]\");\n        sideChannel.set(object, step);\n        const valueSideChannel = new WeakMap();\n        valueSideChannel.set($8f990f113c373965$var$sentinel, sideChannel);\n        $8f990f113c373965$var$push_to_array(values, $8f990f113c373965$var$inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, // @ts-ignore\n        generateArrayPrefix === \"comma\" && encodeValuesOnly && $8f990f113c373965$var$is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n    }\n    return values;\n}\nfunction $8f990f113c373965$var$normalize_stringify_options(opts = $8f990f113c373965$var$defaults) {\n    if (typeof opts.allowEmptyArrays !== \"undefined\" && typeof opts.allowEmptyArrays !== \"boolean\") throw new TypeError(\"`allowEmptyArrays` option can only be `true` or `false`, when provided\");\n    if (typeof opts.encodeDotInKeys !== \"undefined\" && typeof opts.encodeDotInKeys !== \"boolean\") throw new TypeError(\"`encodeDotInKeys` option can only be `true` or `false`, when provided\");\n    if (opts.encoder !== null && typeof opts.encoder !== \"undefined\" && typeof opts.encoder !== \"function\") throw new TypeError(\"Encoder has to be a function.\");\n    const charset = opts.charset || $8f990f113c373965$var$defaults.charset;\n    if (typeof opts.charset !== \"undefined\" && opts.charset !== \"utf-8\" && opts.charset !== \"iso-8859-1\") throw new TypeError(\"The charset option must be either utf-8, iso-8859-1, or undefined\");\n    let format = $324yj.default_format;\n    if (typeof opts.format !== \"undefined\") {\n        if (!$8f990f113c373965$var$has.call($324yj.formatters, opts.format)) throw new TypeError(\"Unknown format option provided.\");\n        format = opts.format;\n    }\n    const formatter = $324yj.formatters[format];\n    let filter = $8f990f113c373965$var$defaults.filter;\n    if (typeof opts.filter === \"function\" || $8f990f113c373965$var$is_array(opts.filter)) filter = opts.filter;\n    let arrayFormat;\n    if (opts.arrayFormat && opts.arrayFormat in $8f990f113c373965$var$array_prefix_generators) arrayFormat = opts.arrayFormat;\n    else if (\"indices\" in opts) arrayFormat = opts.indices ? \"indices\" : \"repeat\";\n    else arrayFormat = $8f990f113c373965$var$defaults.arrayFormat;\n    if (\"commaRoundTrip\" in opts && typeof opts.commaRoundTrip !== \"boolean\") throw new TypeError(\"`commaRoundTrip` must be a boolean, or absent\");\n    const allowDots = typeof opts.allowDots === \"undefined\" ? !!opts.encodeDotInKeys === true ? true : $8f990f113c373965$var$defaults.allowDots : !!opts.allowDots;\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === \"boolean\" ? opts.addQueryPrefix : $8f990f113c373965$var$defaults.addQueryPrefix,\n        // @ts-ignore\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === \"boolean\" ? !!opts.allowEmptyArrays : $8f990f113c373965$var$defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === \"boolean\" ? opts.charsetSentinel : $8f990f113c373965$var$defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === \"undefined\" ? $8f990f113c373965$var$defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === \"boolean\" ? opts.encode : $8f990f113c373965$var$defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === \"boolean\" ? opts.encodeDotInKeys : $8f990f113c373965$var$defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === \"function\" ? opts.encoder : $8f990f113c373965$var$defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === \"boolean\" ? opts.encodeValuesOnly : $8f990f113c373965$var$defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === \"function\" ? opts.serializeDate : $8f990f113c373965$var$defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === \"boolean\" ? opts.skipNulls : $8f990f113c373965$var$defaults.skipNulls,\n        // @ts-ignore\n        sort: typeof opts.sort === \"function\" ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === \"boolean\" ? opts.strictNullHandling : $8f990f113c373965$var$defaults.strictNullHandling\n    };\n}\nfunction $8f990f113c373965$var$stringify(object, opts = {}) {\n    let obj = object;\n    const options = $8f990f113c373965$var$normalize_stringify_options(opts);\n    let obj_keys;\n    let filter;\n    if (typeof options.filter === \"function\") {\n        filter = options.filter;\n        obj = filter(\"\", obj);\n    } else if ($8f990f113c373965$var$is_array(options.filter)) {\n        filter = options.filter;\n        obj_keys = filter;\n    }\n    const keys = [];\n    if (typeof obj !== \"object\" || obj === null) return \"\";\n    const generateArrayPrefix = $8f990f113c373965$var$array_prefix_generators[options.arrayFormat];\n    const commaRoundTrip = generateArrayPrefix === \"comma\" && options.commaRoundTrip;\n    if (!obj_keys) obj_keys = Object.keys(obj);\n    if (options.sort) obj_keys.sort(options.sort);\n    const sideChannel = new WeakMap();\n    for(let i = 0; i < obj_keys.length; ++i){\n        const key = obj_keys[i];\n        if (options.skipNulls && obj[key] === null) continue;\n        $8f990f113c373965$var$push_to_array(keys, $8f990f113c373965$var$inner_stringify(obj[key], key, // @ts-expect-error\n        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n    }\n    const joined = keys.join(options.delimiter);\n    let prefix = options.addQueryPrefix === true ? \"?\" : \"\";\n    if (options.charsetSentinel) {\n        if (options.charset === \"iso-8859-1\") // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n        prefix += \"utf8=%26%2310003%3B&\";\n        else // encodeURIComponent('✓')\n        prefix += \"utf8=%E2%9C%93&\";\n    }\n    return joined.length > 0 ? prefix + joined : \"\";\n}\nmodule.exports.stringify = $8f990f113c373965$var$stringify;\n\n});\nparcelRegister(\"3JE24\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.maybe_map = module.exports.combine = module.exports.is_buffer = module.exports.is_regexp = module.exports.compact = module.exports.encode = module.exports.decode = module.exports.assign_single_source = module.exports.merge = void 0;\n\nvar $324yj = parcelRequire(\"324yj\");\nconst $2b84a0a7ef9203e1$var$has = Object.prototype.hasOwnProperty;\nconst $2b84a0a7ef9203e1$var$is_array = Array.isArray;\nconst $2b84a0a7ef9203e1$var$hex_table = (()=>{\n    const array = [];\n    for(let i = 0; i < 256; ++i)array.push(\"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase());\n    return array;\n})();\nfunction $2b84a0a7ef9203e1$var$compact_queue(queue) {\n    while(queue.length > 1){\n        const item = queue.pop();\n        if (!item) continue;\n        const obj = item.obj[item.prop];\n        if ($2b84a0a7ef9203e1$var$is_array(obj)) {\n            const compacted = [];\n            for(let j = 0; j < obj.length; ++j)if (typeof obj[j] !== \"undefined\") compacted.push(obj[j]);\n            // @ts-ignore\n            item.obj[item.prop] = compacted;\n        }\n    }\n}\nfunction $2b84a0a7ef9203e1$var$array_to_object(source, options) {\n    const obj = options && options.plainObjects ? Object.create(null) : {};\n    for(let i = 0; i < source.length; ++i)if (typeof source[i] !== \"undefined\") obj[i] = source[i];\n    return obj;\n}\nfunction $2b84a0a7ef9203e1$var$merge(target, source, options = {}) {\n    if (!source) return target;\n    if (typeof source !== \"object\") {\n        if ($2b84a0a7ef9203e1$var$is_array(target)) target.push(source);\n        else if (target && typeof target === \"object\") {\n            if (options && (options.plainObjects || options.allowPrototypes) || !$2b84a0a7ef9203e1$var$has.call(Object.prototype, source)) target[source] = true;\n        } else return [\n            target,\n            source\n        ];\n        return target;\n    }\n    if (!target || typeof target !== \"object\") return [\n        target\n    ].concat(source);\n    let mergeTarget = target;\n    if ($2b84a0a7ef9203e1$var$is_array(target) && !$2b84a0a7ef9203e1$var$is_array(source)) // @ts-ignore\n    mergeTarget = $2b84a0a7ef9203e1$var$array_to_object(target, options);\n    if ($2b84a0a7ef9203e1$var$is_array(target) && $2b84a0a7ef9203e1$var$is_array(source)) {\n        source.forEach(function(item, i) {\n            if ($2b84a0a7ef9203e1$var$has.call(target, i)) {\n                const targetItem = target[i];\n                if (targetItem && typeof targetItem === \"object\" && item && typeof item === \"object\") target[i] = $2b84a0a7ef9203e1$var$merge(targetItem, item, options);\n                else target.push(item);\n            } else target[i] = item;\n        });\n        return target;\n    }\n    return Object.keys(source).reduce(function(acc, key) {\n        const value = source[key];\n        if ($2b84a0a7ef9203e1$var$has.call(acc, key)) acc[key] = $2b84a0a7ef9203e1$var$merge(acc[key], value, options);\n        else acc[key] = value;\n        return acc;\n    }, mergeTarget);\n}\nmodule.exports.merge = $2b84a0a7ef9203e1$var$merge;\nfunction $2b84a0a7ef9203e1$var$assign_single_source(target, source) {\n    return Object.keys(source).reduce(function(acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n}\nmodule.exports.assign_single_source = $2b84a0a7ef9203e1$var$assign_single_source;\nfunction $2b84a0a7ef9203e1$var$decode(str, _, charset) {\n    const strWithoutPlus = str.replace(/\\+/g, \" \");\n    if (charset === \"iso-8859-1\") // unescape never throws, no try...catch needed:\n    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n}\nmodule.exports.decode = $2b84a0a7ef9203e1$var$decode;\nconst $2b84a0a7ef9203e1$var$limit = 1024;\nconst $2b84a0a7ef9203e1$var$encode = (str, _defaultEncoder, charset, _kind, format)=>{\n    // This code was originally written by Brian White for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) return str;\n    let string = str;\n    if (typeof str === \"symbol\") string = Symbol.prototype.toString.call(str);\n    else if (typeof str !== \"string\") string = String(str);\n    if (charset === \"iso-8859-1\") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {\n        return \"%26%23\" + parseInt($0.slice(2), 16) + \"%3B\";\n    });\n    let out = \"\";\n    for(let j = 0; j < string.length; j += $2b84a0a7ef9203e1$var$limit){\n        const segment = string.length >= $2b84a0a7ef9203e1$var$limit ? string.slice(j, j + $2b84a0a7ef9203e1$var$limit) : string;\n        const arr = [];\n        for(let i = 0; i < segment.length; ++i){\n            let c = segment.charCodeAt(i);\n            if (c === 0x2d || // -\n            c === 0x2e || // .\n            c === 0x5f || // _\n            c === 0x7e || // ~\n            c >= 0x30 && c <= 0x39 || // 0-9\n            c >= 0x41 && c <= 0x5a || // a-z\n            c >= 0x61 && c <= 0x7a || // A-Z\n            format === $324yj.RFC1738 && (c === 0x28 || c === 0x29) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n            if (c < 0x80) {\n                arr[arr.length] = $2b84a0a7ef9203e1$var$hex_table[c];\n                continue;\n            }\n            if (c < 0x800) {\n                arr[arr.length] = $2b84a0a7ef9203e1$var$hex_table[0xc0 | c >> 6] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c & 0x3f];\n                continue;\n            }\n            if (c < 0xd800 || c >= 0xe000) {\n                arr[arr.length] = $2b84a0a7ef9203e1$var$hex_table[0xe0 | c >> 12] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c >> 6 & 0x3f] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c & 0x3f];\n                continue;\n            }\n            i += 1;\n            c = 0x10000 + ((c & 0x3ff) << 10 | segment.charCodeAt(i) & 0x3ff);\n            arr[arr.length] = $2b84a0a7ef9203e1$var$hex_table[0xf0 | c >> 18] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c >> 12 & 0x3f] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c >> 6 & 0x3f] + $2b84a0a7ef9203e1$var$hex_table[0x80 | c & 0x3f];\n        }\n        out += arr.join(\"\");\n    }\n    return out;\n};\nmodule.exports.encode = $2b84a0a7ef9203e1$var$encode;\nfunction $2b84a0a7ef9203e1$var$compact(value) {\n    const queue = [\n        {\n            obj: {\n                o: value\n            },\n            prop: \"o\"\n        }\n    ];\n    const refs = [];\n    for(let i = 0; i < queue.length; ++i){\n        const item = queue[i];\n        // @ts-ignore\n        const obj = item.obj[item.prop];\n        const keys = Object.keys(obj);\n        for(let j = 0; j < keys.length; ++j){\n            const key = keys[j];\n            const val = obj[key];\n            if (typeof val === \"object\" && val !== null && refs.indexOf(val) === -1) {\n                queue.push({\n                    obj: obj,\n                    prop: key\n                });\n                refs.push(val);\n            }\n        }\n    }\n    $2b84a0a7ef9203e1$var$compact_queue(queue);\n    return value;\n}\nmodule.exports.compact = $2b84a0a7ef9203e1$var$compact;\nfunction $2b84a0a7ef9203e1$var$is_regexp(obj) {\n    return Object.prototype.toString.call(obj) === \"[object RegExp]\";\n}\nmodule.exports.is_regexp = $2b84a0a7ef9203e1$var$is_regexp;\nfunction $2b84a0a7ef9203e1$var$is_buffer(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\nmodule.exports.is_buffer = $2b84a0a7ef9203e1$var$is_buffer;\nfunction $2b84a0a7ef9203e1$var$combine(a, b) {\n    return [].concat(a, b);\n}\nmodule.exports.combine = $2b84a0a7ef9203e1$var$combine;\nfunction $2b84a0a7ef9203e1$var$maybe_map(val, fn) {\n    if ($2b84a0a7ef9203e1$var$is_array(val)) {\n        const mapped = [];\n        for(let i = 0; i < val.length; i += 1)mapped.push(fn(val[i]));\n        return mapped;\n    }\n    return fn(val);\n}\nmodule.exports.maybe_map = $2b84a0a7ef9203e1$var$maybe_map;\n\n});\n\n\n\nparcelRegister(\"61UiY\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.CursorPage = module.exports.Page = void 0;\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */ class $463e8316d2b1d31a$var$Page extends $9xH07.AbstractPage {\n    constructor(client, response, body, options){\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.object = body.object;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    /**\n     * This page represents a response that isn't actually paginated at the API level\n     * so there will never be any next page params.\n     */ nextPageParams() {\n        return null;\n    }\n    nextPageInfo() {\n        return null;\n    }\n}\nmodule.exports.Page = $463e8316d2b1d31a$var$Page;\nclass $463e8316d2b1d31a$var$CursorPage extends $9xH07.AbstractPage {\n    constructor(client, response, body, options){\n        super(client, response, body, options);\n        this.data = body.data || [];\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info) return null;\n        if (\"params\" in info) return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length) return null;\n        return params;\n    }\n    nextPageInfo() {\n        const data = this.getPaginatedItems();\n        if (!data.length) return null;\n        const id = data[data.length - 1]?.id;\n        if (!id) return null;\n        return {\n            params: {\n                after: id\n            }\n        };\n    }\n}\nmodule.exports.CursorPage = $463e8316d2b1d31a$var$CursorPage;\n\n});\n\nparcelRegister(\"1X4UA\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $16bf1c80b358adfa$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $16bf1c80b358adfa$var$__exportStar = module.exports && module.exports.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) $16bf1c80b358adfa$var$__createBinding(exports1, m, p);\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Uploads = module.exports.Moderations = module.exports.Models = module.exports.ModelsPage = module.exports.Images = module.exports.FineTuning = module.exports.Files = module.exports.FileObjectsPage = module.exports.Embeddings = module.exports.Completions = module.exports.Beta = module.exports.Batches = module.exports.BatchesPage = module.exports.Audio = void 0;\n\n$16bf1c80b358adfa$var$__exportStar((parcelRequire(\"2vGBU\")), module.exports);\n\n$16bf1c80b358adfa$var$__exportStar((parcelRequire(\"gmxGW\")), module.exports);\n\nvar $ciH5k = parcelRequire(\"ciH5k\");\nObject.defineProperty(module.exports, \"Audio\", {\n    enumerable: true,\n    get: function() {\n        return $ciH5k.Audio;\n    }\n});\n\nvar $g4W1Q = parcelRequire(\"g4W1Q\");\nObject.defineProperty(module.exports, \"BatchesPage\", {\n    enumerable: true,\n    get: function() {\n        return $g4W1Q.BatchesPage;\n    }\n});\nObject.defineProperty(module.exports, \"Batches\", {\n    enumerable: true,\n    get: function() {\n        return $g4W1Q.Batches;\n    }\n});\n\nvar $aWvNl = parcelRequire(\"aWvNl\");\nObject.defineProperty(module.exports, \"Beta\", {\n    enumerable: true,\n    get: function() {\n        return $aWvNl.Beta;\n    }\n});\n\nvar $kSU3b = parcelRequire(\"kSU3b\");\nObject.defineProperty(module.exports, \"Completions\", {\n    enumerable: true,\n    get: function() {\n        return $kSU3b.Completions;\n    }\n});\n\nvar $fowbp = parcelRequire(\"fowbp\");\nObject.defineProperty(module.exports, \"Embeddings\", {\n    enumerable: true,\n    get: function() {\n        return $fowbp.Embeddings;\n    }\n});\n\nvar $beenb = parcelRequire(\"beenb\");\nObject.defineProperty(module.exports, \"FileObjectsPage\", {\n    enumerable: true,\n    get: function() {\n        return $beenb.FileObjectsPage;\n    }\n});\nObject.defineProperty(module.exports, \"Files\", {\n    enumerable: true,\n    get: function() {\n        return $beenb.Files;\n    }\n});\n\nvar $aDo8r = parcelRequire(\"aDo8r\");\nObject.defineProperty(module.exports, \"FineTuning\", {\n    enumerable: true,\n    get: function() {\n        return $aDo8r.FineTuning;\n    }\n});\n\nvar $8tzbZ = parcelRequire(\"8tzbZ\");\nObject.defineProperty(module.exports, \"Images\", {\n    enumerable: true,\n    get: function() {\n        return $8tzbZ.Images;\n    }\n});\n\nvar $aROqG = parcelRequire(\"aROqG\");\nObject.defineProperty(module.exports, \"ModelsPage\", {\n    enumerable: true,\n    get: function() {\n        return $aROqG.ModelsPage;\n    }\n});\nObject.defineProperty(module.exports, \"Models\", {\n    enumerable: true,\n    get: function() {\n        return $aROqG.Models;\n    }\n});\n\nvar $iSJzc = parcelRequire(\"iSJzc\");\nObject.defineProperty(module.exports, \"Moderations\", {\n    enumerable: true,\n    get: function() {\n        return $iSJzc.Moderations;\n    }\n});\n\nvar $eAdos = parcelRequire(\"eAdos\");\nObject.defineProperty(module.exports, \"Uploads\", {\n    enumerable: true,\n    get: function() {\n        return $eAdos.Uploads;\n    }\n});\n\n});\nparcelRegister(\"2vGBU\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Chat = module.exports.Completions = void 0;\n\nvar $fwzPu = parcelRequire(\"fwzPu\");\nObject.defineProperty(module.exports, \"Completions\", {\n    enumerable: true,\n    get: function() {\n        return $fwzPu.Completions;\n    }\n});\n\nvar $9dwab = parcelRequire(\"9dwab\");\nObject.defineProperty(module.exports, \"Chat\", {\n    enumerable: true,\n    get: function() {\n        return $9dwab.Chat;\n    }\n});\n\n});\nparcelRegister(\"fwzPu\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Completions = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\nclass $b4d5a3246a53a142$var$Completions extends $andP1.APIResource {\n    create(body, options) {\n        return this._client.post(\"/chat/completions\", {\n            body: body,\n            ...options,\n            stream: body.stream ?? false\n        });\n    }\n}\nmodule.exports.Completions = $b4d5a3246a53a142$var$Completions;\n$b4d5a3246a53a142$var$Completions = module.exports.Completions || (module.exports.Completions = {});\n\n});\nparcelRegister(\"andP1\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.APIResource = void 0;\nclass $78d6c61deab1c7e6$var$APIResource {\n    constructor(client){\n        this._client = client;\n    }\n}\nmodule.exports.APIResource = $78d6c61deab1c7e6$var$APIResource;\n\n});\n\n\nparcelRegister(\"9dwab\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $6b5e46ec8b6e8e3e$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $6b5e46ec8b6e8e3e$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $6b5e46ec8b6e8e3e$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $6b5e46ec8b6e8e3e$var$__createBinding(result, mod, k);\n    }\n    $6b5e46ec8b6e8e3e$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Chat = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $6b5e46ec8b6e8e3e$var$CompletionsAPI = $6b5e46ec8b6e8e3e$var$__importStar((parcelRequire(\"fwzPu\")));\nclass $6b5e46ec8b6e8e3e$var$Chat extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.completions = new $6b5e46ec8b6e8e3e$var$CompletionsAPI.Completions(this._client);\n    }\n}\nmodule.exports.Chat = $6b5e46ec8b6e8e3e$var$Chat;\n(function(Chat) {\n    Chat.Completions = $6b5e46ec8b6e8e3e$var$CompletionsAPI.Completions;\n})($6b5e46ec8b6e8e3e$var$Chat = module.exports.Chat || (module.exports.Chat = {}));\n\n});\n\n\nparcelRegister(\"gmxGW\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\n\n});\n\nparcelRegister(\"ciH5k\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $8f48963ca32ef6bd$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $8f48963ca32ef6bd$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $8f48963ca32ef6bd$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $8f48963ca32ef6bd$var$__createBinding(result, mod, k);\n    }\n    $8f48963ca32ef6bd$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Audio = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $8f48963ca32ef6bd$var$SpeechAPI = $8f48963ca32ef6bd$var$__importStar((parcelRequire(\"5AiKh\")));\n\nconst $8f48963ca32ef6bd$var$TranscriptionsAPI = $8f48963ca32ef6bd$var$__importStar((parcelRequire(\"7Bvgz\")));\n\nconst $8f48963ca32ef6bd$var$TranslationsAPI = $8f48963ca32ef6bd$var$__importStar((parcelRequire(\"ksjyZ\")));\nclass $8f48963ca32ef6bd$var$Audio extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.transcriptions = new $8f48963ca32ef6bd$var$TranscriptionsAPI.Transcriptions(this._client);\n        this.translations = new $8f48963ca32ef6bd$var$TranslationsAPI.Translations(this._client);\n        this.speech = new $8f48963ca32ef6bd$var$SpeechAPI.Speech(this._client);\n    }\n}\nmodule.exports.Audio = $8f48963ca32ef6bd$var$Audio;\n(function(Audio) {\n    Audio.Transcriptions = $8f48963ca32ef6bd$var$TranscriptionsAPI.Transcriptions;\n    Audio.Translations = $8f48963ca32ef6bd$var$TranslationsAPI.Translations;\n    Audio.Speech = $8f48963ca32ef6bd$var$SpeechAPI.Speech;\n})($8f48963ca32ef6bd$var$Audio = module.exports.Audio || (module.exports.Audio = {}));\n\n});\nparcelRegister(\"5AiKh\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Speech = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\nclass $410edb05c3c553e7$var$Speech extends $andP1.APIResource {\n    /**\n     * Generates audio from the input text.\n     */ create(body, options) {\n        return this._client.post(\"/audio/speech\", {\n            body: body,\n            ...options,\n            __binaryResponse: true\n        });\n    }\n}\nmodule.exports.Speech = $410edb05c3c553e7$var$Speech;\n$410edb05c3c553e7$var$Speech = module.exports.Speech || (module.exports.Speech = {});\n\n});\n\nparcelRegister(\"7Bvgz\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $58943df33a812568$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $58943df33a812568$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $58943df33a812568$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $58943df33a812568$var$__createBinding(result, mod, k);\n    }\n    $58943df33a812568$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Transcriptions = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $58943df33a812568$var$Core = $58943df33a812568$var$__importStar((parcelRequire(\"9xH07\")));\nclass $58943df33a812568$var$Transcriptions extends $andP1.APIResource {\n    create(body, options) {\n        return this._client.post(\"/audio/transcriptions\", $58943df33a812568$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n}\nmodule.exports.Transcriptions = $58943df33a812568$var$Transcriptions;\n$58943df33a812568$var$Transcriptions = module.exports.Transcriptions || (module.exports.Transcriptions = {});\n\n});\n\nparcelRegister(\"ksjyZ\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $ee45990c8945fa08$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $ee45990c8945fa08$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $ee45990c8945fa08$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $ee45990c8945fa08$var$__createBinding(result, mod, k);\n    }\n    $ee45990c8945fa08$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Translations = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $ee45990c8945fa08$var$Core = $ee45990c8945fa08$var$__importStar((parcelRequire(\"9xH07\")));\nclass $ee45990c8945fa08$var$Translations extends $andP1.APIResource {\n    create(body, options) {\n        return this._client.post(\"/audio/translations\", $ee45990c8945fa08$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n}\nmodule.exports.Translations = $ee45990c8945fa08$var$Translations;\n$ee45990c8945fa08$var$Translations = module.exports.Translations || (module.exports.Translations = {});\n\n});\n\n\nparcelRegister(\"g4W1Q\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $bb4a085d0b01c5ea$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $bb4a085d0b01c5ea$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $bb4a085d0b01c5ea$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $bb4a085d0b01c5ea$var$__createBinding(result, mod, k);\n    }\n    $bb4a085d0b01c5ea$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.BatchesPage = module.exports.Batches = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $bb4a085d0b01c5ea$var$BatchesAPI = $bb4a085d0b01c5ea$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $bb4a085d0b01c5ea$var$Batches extends $andP1.APIResource {\n    /**\n     * Creates and executes a batch from an uploaded file of requests\n     */ create(body, options) {\n        return this._client.post(\"/batches\", {\n            body: body,\n            ...options\n        });\n    }\n    /**\n     * Retrieves a batch.\n     */ retrieve(batchId, options) {\n        return this._client.get(`/batches/${batchId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list({}, query);\n        return this._client.getAPIList(\"/batches\", $bb4a085d0b01c5ea$var$BatchesPage, {\n            query: query,\n            ...options\n        });\n    }\n    /**\n     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n     * 10 minutes, before changing to `cancelled`, where it will have partial results\n     * (if any) available in the output file.\n     */ cancel(batchId, options) {\n        return this._client.post(`/batches/${batchId}/cancel`, options);\n    }\n}\nmodule.exports.Batches = $bb4a085d0b01c5ea$var$Batches;\nclass $bb4a085d0b01c5ea$var$BatchesPage extends $61UiY.CursorPage {\n}\nmodule.exports.BatchesPage = $bb4a085d0b01c5ea$var$BatchesPage;\n(function(Batches) {\n    Batches.BatchesPage = $bb4a085d0b01c5ea$var$BatchesAPI.BatchesPage;\n})($bb4a085d0b01c5ea$var$Batches = module.exports.Batches || (module.exports.Batches = {}));\n\n});\n\nparcelRegister(\"aWvNl\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $7f77fbfb5659c119$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $7f77fbfb5659c119$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $7f77fbfb5659c119$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $7f77fbfb5659c119$var$__createBinding(result, mod, k);\n    }\n    $7f77fbfb5659c119$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Beta = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $7f77fbfb5659c119$var$AssistantsAPI = $7f77fbfb5659c119$var$__importStar((parcelRequire(\"eqdkk\")));\n\nconst $7f77fbfb5659c119$var$ChatAPI = $7f77fbfb5659c119$var$__importStar((parcelRequire(\"6UkP2\")));\n\nconst $7f77fbfb5659c119$var$ThreadsAPI = $7f77fbfb5659c119$var$__importStar((parcelRequire(\"hU1vh\")));\n\nconst $7f77fbfb5659c119$var$VectorStoresAPI = $7f77fbfb5659c119$var$__importStar((parcelRequire(\"eLkc3\")));\nclass $7f77fbfb5659c119$var$Beta extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.vectorStores = new $7f77fbfb5659c119$var$VectorStoresAPI.VectorStores(this._client);\n        this.chat = new $7f77fbfb5659c119$var$ChatAPI.Chat(this._client);\n        this.assistants = new $7f77fbfb5659c119$var$AssistantsAPI.Assistants(this._client);\n        this.threads = new $7f77fbfb5659c119$var$ThreadsAPI.Threads(this._client);\n    }\n}\nmodule.exports.Beta = $7f77fbfb5659c119$var$Beta;\n(function(Beta) {\n    Beta.VectorStores = $7f77fbfb5659c119$var$VectorStoresAPI.VectorStores;\n    Beta.VectorStoresPage = $7f77fbfb5659c119$var$VectorStoresAPI.VectorStoresPage;\n    Beta.Chat = $7f77fbfb5659c119$var$ChatAPI.Chat;\n    Beta.Assistants = $7f77fbfb5659c119$var$AssistantsAPI.Assistants;\n    Beta.AssistantsPage = $7f77fbfb5659c119$var$AssistantsAPI.AssistantsPage;\n    Beta.Threads = $7f77fbfb5659c119$var$ThreadsAPI.Threads;\n})($7f77fbfb5659c119$var$Beta = module.exports.Beta || (module.exports.Beta = {}));\n\n});\nparcelRegister(\"eqdkk\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $a7fdd4d1c5f6a35c$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $a7fdd4d1c5f6a35c$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $a7fdd4d1c5f6a35c$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $a7fdd4d1c5f6a35c$var$__createBinding(result, mod, k);\n    }\n    $a7fdd4d1c5f6a35c$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.AssistantsPage = module.exports.Assistants = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $a7fdd4d1c5f6a35c$var$AssistantsAPI = $a7fdd4d1c5f6a35c$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $a7fdd4d1c5f6a35c$var$Assistants extends $andP1.APIResource {\n    /**\n     * Create an assistant with a model and instructions.\n     */ create(body, options) {\n        return this._client.post(\"/assistants\", {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieves an assistant.\n     */ retrieve(assistantId, options) {\n        return this._client.get(`/assistants/${assistantId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Modifies an assistant.\n     */ update(assistantId, body, options) {\n        return this._client.post(`/assistants/${assistantId}`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list({}, query);\n        return this._client.getAPIList(\"/assistants\", $a7fdd4d1c5f6a35c$var$AssistantsPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Delete an assistant.\n     */ del(assistantId, options) {\n        return this._client.delete(`/assistants/${assistantId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n}\nmodule.exports.Assistants = $a7fdd4d1c5f6a35c$var$Assistants;\nclass $a7fdd4d1c5f6a35c$var$AssistantsPage extends $61UiY.CursorPage {\n}\nmodule.exports.AssistantsPage = $a7fdd4d1c5f6a35c$var$AssistantsPage;\n(function(Assistants) {\n    Assistants.AssistantsPage = $a7fdd4d1c5f6a35c$var$AssistantsAPI.AssistantsPage;\n})($a7fdd4d1c5f6a35c$var$Assistants = module.exports.Assistants || (module.exports.Assistants = {}));\n\n});\n\nparcelRegister(\"6UkP2\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $50781fe4b0b1f3c9$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $50781fe4b0b1f3c9$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $50781fe4b0b1f3c9$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $50781fe4b0b1f3c9$var$__createBinding(result, mod, k);\n    }\n    $50781fe4b0b1f3c9$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Chat = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $50781fe4b0b1f3c9$var$CompletionsAPI = $50781fe4b0b1f3c9$var$__importStar((parcelRequire(\"96Lgg\")));\nclass $50781fe4b0b1f3c9$var$Chat extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.completions = new $50781fe4b0b1f3c9$var$CompletionsAPI.Completions(this._client);\n    }\n}\nmodule.exports.Chat = $50781fe4b0b1f3c9$var$Chat;\n(function(Chat) {\n    Chat.Completions = $50781fe4b0b1f3c9$var$CompletionsAPI.Completions;\n})($50781fe4b0b1f3c9$var$Chat = module.exports.Chat || (module.exports.Chat = {}));\n\n});\nparcelRegister(\"96Lgg\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Completions = module.exports.ChatCompletionStream = module.exports.ParsingToolFunction = module.exports.ParsingFunction = module.exports.ChatCompletionStreamingRunner = module.exports.ChatCompletionRunner = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $i4Djk = parcelRequire(\"i4Djk\");\n\nvar $i4Djk = parcelRequire(\"i4Djk\");\nObject.defineProperty(module.exports, \"ChatCompletionRunner\", {\n    enumerable: true,\n    get: function() {\n        return $i4Djk.ChatCompletionRunner;\n    }\n});\n\nvar $6tV2R = parcelRequire(\"6tV2R\");\n\nvar $6tV2R = parcelRequire(\"6tV2R\");\nObject.defineProperty(module.exports, \"ChatCompletionStreamingRunner\", {\n    enumerable: true,\n    get: function() {\n        return $6tV2R.ChatCompletionStreamingRunner;\n    }\n});\n\nvar $ioyPV = parcelRequire(\"ioyPV\");\nObject.defineProperty(module.exports, \"ParsingFunction\", {\n    enumerable: true,\n    get: function() {\n        return $ioyPV.ParsingFunction;\n    }\n});\nObject.defineProperty(module.exports, \"ParsingToolFunction\", {\n    enumerable: true,\n    get: function() {\n        return $ioyPV.ParsingToolFunction;\n    }\n});\n\nvar $2ArjU = parcelRequire(\"2ArjU\");\n\nvar $8TnOx = parcelRequire(\"8TnOx\");\n\nvar $2ArjU = parcelRequire(\"2ArjU\");\nObject.defineProperty(module.exports, \"ChatCompletionStream\", {\n    enumerable: true,\n    get: function() {\n        return $2ArjU.ChatCompletionStream;\n    }\n});\nclass $6a1955b736a9e272$var$Completions extends $andP1.APIResource {\n    parse(body, options) {\n        (0, $8TnOx.validateInputTools)(body.tools);\n        return this._client.chat.completions.create(body, {\n            ...options,\n            headers: {\n                ...options?.headers,\n                \"X-Stainless-Helper-Method\": \"beta.chat.completions.parse\"\n            }\n        })._thenUnwrap((completion)=>(0, $8TnOx.parseChatCompletion)(completion, body));\n    }\n    runFunctions(body, options) {\n        if (body.stream) return $6tV2R.ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n        return $i4Djk.ChatCompletionRunner.runFunctions(this._client, body, options);\n    }\n    runTools(body, options) {\n        if (body.stream) return $6tV2R.ChatCompletionStreamingRunner.runTools(this._client, body, options);\n        return $i4Djk.ChatCompletionRunner.runTools(this._client, body, options);\n    }\n    /**\n     * Creates a chat completion stream\n     */ stream(body, options) {\n        return $2ArjU.ChatCompletionStream.createChatCompletion(this._client, body, options);\n    }\n}\nmodule.exports.Completions = $6a1955b736a9e272$var$Completions;\n\n});\nparcelRegister(\"i4Djk\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ChatCompletionRunner = void 0;\n\nvar $dLYfX = parcelRequire(\"dLYfX\");\n\nvar $lV4f5 = parcelRequire(\"lV4f5\");\nclass $d28718067f0bfb8e$var$ChatCompletionRunner extends $dLYfX.AbstractChatCompletionRunner {\n    /** @deprecated - please use `runTools` instead. */ static runFunctions(client, params, options) {\n        const runner = new $d28718067f0bfb8e$var$ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: {\n                ...options?.headers,\n                \"X-Stainless-Helper-Method\": \"runFunctions\"\n            }\n        };\n        runner._run(()=>runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new $d28718067f0bfb8e$var$ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: {\n                ...options?.headers,\n                \"X-Stainless-Helper-Method\": \"runTools\"\n            }\n        };\n        runner._run(()=>runner._runTools(client, params, opts));\n        return runner;\n    }\n    _addMessage(message, emit = true) {\n        super._addMessage(message, emit);\n        if ((0, $lV4f5.isAssistantMessage)(message) && message.content) this._emit(\"content\", message.content);\n    }\n}\nmodule.exports.ChatCompletionRunner = $d28718067f0bfb8e$var$ChatCompletionRunner;\n\n});\nparcelRegister(\"dLYfX\", function(module, exports) {\n\"use strict\";\nvar $a06e67d568f03f7e$var$__classPrivateFieldGet = module.exports && module.exports.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalContent, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCall, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCallResult, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_calculateTotalUsage, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_validateParams, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_stringifyFunctionCallResult;\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.AbstractChatCompletionRunner = void 0;\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nvar $ioyPV = parcelRequire(\"ioyPV\");\n\nvar $lV4f5 = parcelRequire(\"lV4f5\");\n\nvar $aE86S = parcelRequire(\"aE86S\");\n\nvar $8TnOx = parcelRequire(\"8TnOx\");\nconst $a06e67d568f03f7e$var$DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nclass $a06e67d568f03f7e$var$AbstractChatCompletionRunner extends $aE86S.EventStream {\n    constructor(){\n        super(...arguments);\n        $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances.add(this);\n        this._chatCompletions = [];\n        this.messages = [];\n    }\n    _addChatCompletion(chatCompletion) {\n        this._chatCompletions.push(chatCompletion);\n        this._emit(\"chatCompletion\", chatCompletion);\n        const message = chatCompletion.choices[0]?.message;\n        if (message) this._addMessage(message);\n        return chatCompletion;\n    }\n    _addMessage(message, emit = true) {\n        if (!(\"content\" in message)) message.content = null;\n        this.messages.push(message);\n        if (emit) {\n            this._emit(\"message\", message);\n            if (((0, $lV4f5.isFunctionMessage)(message) || (0, $lV4f5.isToolMessage)(message)) && message.content) // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n            this._emit(\"functionCallResult\", message.content);\n            else if ((0, $lV4f5.isAssistantMessage)(message) && message.function_call) this._emit(\"functionCall\", message.function_call);\n            else if ((0, $lV4f5.isAssistantMessage)(message) && message.tool_calls) {\n                for (const tool_call of message.tool_calls)if (tool_call.type === \"function\") this._emit(\"functionCall\", tool_call.function);\n            }\n        }\n    }\n    /**\n     * @returns a promise that resolves with the final ChatCompletion, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n     */ async finalChatCompletion() {\n        await this.done();\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (!completion) throw new $hTt11.OpenAIError(\"stream ended without producing a ChatCompletion\");\n        return completion;\n    }\n    /**\n     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */ async finalContent() {\n        await this.done();\n        return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalContent).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */ async finalMessage() {\n        await this.done();\n        return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */ async finalFunctionCall() {\n        await this.done();\n        return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    }\n    async finalFunctionCallResult() {\n        await this.done();\n        return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    }\n    async totalUsage() {\n        await this.done();\n        return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n    }\n    allChatCompletions() {\n        return [\n            ...this._chatCompletions\n        ];\n    }\n    _emitFinal() {\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (completion) this._emit(\"finalChatCompletion\", completion);\n        const finalMessage = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage).call(this);\n        if (finalMessage) this._emit(\"finalMessage\", finalMessage);\n        const finalContent = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalContent).call(this);\n        if (finalContent) this._emit(\"finalContent\", finalContent);\n        const finalFunctionCall = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n        if (finalFunctionCall) this._emit(\"finalFunctionCall\", finalFunctionCall);\n        const finalFunctionCallResult = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n        if (finalFunctionCallResult != null) this._emit(\"finalFunctionCallResult\", finalFunctionCallResult);\n        if (this._chatCompletions.some((c)=>c.usage)) this._emit(\"totalUsage\", $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n    }\n    async _createChatCompletion(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_validateParams).call(this, params);\n        const chatCompletion = await client.chat.completions.create({\n            ...params,\n            stream: false\n        }, {\n            ...options,\n            signal: this.controller.signal\n        });\n        this._connected();\n        return this._addChatCompletion((0, $8TnOx.parseChatCompletion)(chatCompletion, params));\n    }\n    async _runChatCompletion(client, params, options) {\n        for (const message of params.messages)this._addMessage(message, false);\n        return await this._createChatCompletion(client, params, options);\n    }\n    async _runFunctions(client, params, options) {\n        const role = \"function\";\n        const { function_call: function_call = \"auto\", stream: stream, ...restParams } = params;\n        const singleFunctionToCall = typeof function_call !== \"string\" && function_call?.name;\n        const { maxChatCompletions: maxChatCompletions = $a06e67d568f03f7e$var$DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        const functionsByName = {};\n        for (const f of params.functions)functionsByName[f.name || f.function.name] = f;\n        const functions = params.functions.map((f)=>({\n                name: f.name || f.function.name,\n                parameters: f.parameters,\n                description: f.description\n            }));\n        for (const message of params.messages)this._addMessage(message, false);\n        for(let i = 0; i < maxChatCompletions; ++i){\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                function_call: function_call,\n                functions: functions,\n                messages: [\n                    ...this.messages\n                ]\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) throw new $hTt11.OpenAIError(`missing message in ChatCompletion response`);\n            if (!message.function_call) return;\n            const { name: name, arguments: args } = message.function_call;\n            const fn = functionsByName[name];\n            if (!fn) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f)=>JSON.stringify(f.name)).join(\", \")}. Please try again`;\n                this._addMessage({\n                    role: role,\n                    name: name,\n                    content: content\n                });\n                continue;\n            } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                this._addMessage({\n                    role: role,\n                    name: name,\n                    content: content\n                });\n                continue;\n            }\n            let parsed;\n            try {\n                parsed = (0, $ioyPV.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n            } catch (error) {\n                this._addMessage({\n                    role: role,\n                    name: name,\n                    content: error instanceof Error ? error.message : String(error)\n                });\n                continue;\n            }\n            // @ts-expect-error it can't rule out `never` type.\n            const rawContent = await fn.function(parsed, this);\n            const content = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n            this._addMessage({\n                role: role,\n                name: name,\n                content: content\n            });\n            if (singleFunctionToCall) return;\n        }\n    }\n    async _runTools(client, params, options) {\n        const role = \"tool\";\n        const { tool_choice: tool_choice = \"auto\", stream: stream, ...restParams } = params;\n        const singleFunctionToCall = typeof tool_choice !== \"string\" && tool_choice?.function?.name;\n        const { maxChatCompletions: maxChatCompletions = $a06e67d568f03f7e$var$DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        // TODO(someday): clean this logic up\n        const inputTools = params.tools.map((tool)=>{\n            if ((0, $8TnOx.isAutoParsableTool)(tool)) {\n                if (!tool.$callback) throw new $hTt11.OpenAIError(\"Tool given to `.runTools()` that does not have an associated function\");\n                return {\n                    type: \"function\",\n                    function: {\n                        function: tool.$callback,\n                        name: tool.function.name,\n                        description: tool.function.description || \"\",\n                        parameters: tool.function.parameters,\n                        parse: tool.$parseRaw,\n                        strict: true\n                    }\n                };\n            }\n            return tool;\n        });\n        const functionsByName = {};\n        for (const f of inputTools)if (f.type === \"function\") functionsByName[f.function.name || f.function.function.name] = f.function;\n        const tools = \"tools\" in params ? inputTools.map((t)=>t.type === \"function\" ? {\n                type: \"function\",\n                function: {\n                    name: t.function.name || t.function.function.name,\n                    parameters: t.function.parameters,\n                    description: t.function.description,\n                    strict: t.function.strict\n                }\n            } : t) : undefined;\n        for (const message of params.messages)this._addMessage(message, false);\n        for(let i = 0; i < maxChatCompletions; ++i){\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                tool_choice: tool_choice,\n                tools: tools,\n                messages: [\n                    ...this.messages\n                ]\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) throw new $hTt11.OpenAIError(`missing message in ChatCompletion response`);\n            if (!message.tool_calls?.length) return;\n            for (const tool_call of message.tool_calls){\n                if (tool_call.type !== \"function\") continue;\n                const tool_call_id = tool_call.id;\n                const { name: name, arguments: args } = tool_call.function;\n                const fn = functionsByName[name];\n                if (!fn) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name)=>JSON.stringify(name)).join(\", \")}. Please try again`;\n                    this._addMessage({\n                        role: role,\n                        tool_call_id: tool_call_id,\n                        content: content\n                    });\n                    continue;\n                } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                    this._addMessage({\n                        role: role,\n                        tool_call_id: tool_call_id,\n                        content: content\n                    });\n                    continue;\n                }\n                let parsed;\n                try {\n                    parsed = (0, $ioyPV.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n                } catch (error) {\n                    const content = error instanceof Error ? error.message : String(error);\n                    this._addMessage({\n                        role: role,\n                        tool_call_id: tool_call_id,\n                        content: content\n                    });\n                    continue;\n                }\n                // @ts-expect-error it can't rule out `never` type.\n                const rawContent = await fn.function(parsed, this);\n                const content = $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                this._addMessage({\n                    role: role,\n                    tool_call_id: tool_call_id,\n                    content: content\n                });\n                if (singleFunctionToCall) return;\n            }\n        }\n        return;\n    }\n}\nmodule.exports.AbstractChatCompletionRunner = $a06e67d568f03f7e$var$AbstractChatCompletionRunner;\n$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances = new WeakSet(), $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n    return $a06e67d568f03f7e$var$__classPrivateFieldGet(this, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances, \"m\", $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n    let i = this.messages.length;\n    while(i-- > 0){\n        const message = this.messages[i];\n        if ((0, $lV4f5.isAssistantMessage)(message)) {\n            const { function_call: function_call, ...rest } = message;\n            const ret = {\n                ...rest,\n                content: message.content ?? null,\n                refusal: message.refusal ?? null\n            };\n            if (function_call) ret.function_call = function_call;\n            return ret;\n        }\n    }\n    throw new $hTt11.OpenAIError(\"stream ended without producing a ChatCompletionMessage with role=assistant\");\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n    for(let i = this.messages.length - 1; i >= 0; i--){\n        const message = this.messages[i];\n        if ((0, $lV4f5.isAssistantMessage)(message) && message?.function_call) return message.function_call;\n        if ((0, $lV4f5.isAssistantMessage)(message) && message?.tool_calls?.length) return message.tool_calls.at(-1)?.function;\n    }\n    return;\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n    for(let i = this.messages.length - 1; i >= 0; i--){\n        const message = this.messages[i];\n        if ((0, $lV4f5.isFunctionMessage)(message) && message.content != null) return message.content;\n        if ((0, $lV4f5.isToolMessage)(message) && message.content != null && typeof message.content === \"string\" && this.messages.some((x)=>x.role === \"assistant\" && x.tool_calls?.some((y)=>y.type === \"function\" && y.id === message.tool_call_id))) return message.content;\n    }\n    return;\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n    const total = {\n        completion_tokens: 0,\n        prompt_tokens: 0,\n        total_tokens: 0\n    };\n    for (const { usage: usage } of this._chatCompletions)if (usage) {\n        total.completion_tokens += usage.completion_tokens;\n        total.prompt_tokens += usage.prompt_tokens;\n        total.total_tokens += usage.total_tokens;\n    }\n    return total;\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n    if (params.n != null && params.n > 1) throw new $hTt11.OpenAIError(\"ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.\");\n}, $a06e67d568f03f7e$var$_AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n    return typeof rawContent === \"string\" ? rawContent : rawContent === undefined ? \"undefined\" : JSON.stringify(rawContent);\n};\n\n});\nparcelRegister(\"ioyPV\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ParsingToolFunction = module.exports.ParsingFunction = module.exports.isRunnableFunctionWithParse = void 0;\nfunction $d6457db50757ff05$var$isRunnableFunctionWithParse(fn) {\n    return typeof fn.parse === \"function\";\n}\nmodule.exports.isRunnableFunctionWithParse = $d6457db50757ff05$var$isRunnableFunctionWithParse;\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */ class $d6457db50757ff05$var$ParsingFunction {\n    constructor(input){\n        this.function = input.function;\n        this.parse = input.parse;\n        this.parameters = input.parameters;\n        this.description = input.description;\n        this.name = input.name;\n    }\n}\nmodule.exports.ParsingFunction = $d6457db50757ff05$var$ParsingFunction;\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */ class $d6457db50757ff05$var$ParsingToolFunction {\n    constructor(input){\n        this.type = \"function\";\n        this.function = input;\n    }\n}\nmodule.exports.ParsingToolFunction = $d6457db50757ff05$var$ParsingToolFunction;\n\n});\n\nparcelRegister(\"lV4f5\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.isPresent = module.exports.isToolMessage = module.exports.isFunctionMessage = module.exports.isAssistantMessage = void 0;\nconst $ff52364279a4c3f6$var$isAssistantMessage = (message)=>{\n    return message?.role === \"assistant\";\n};\nmodule.exports.isAssistantMessage = $ff52364279a4c3f6$var$isAssistantMessage;\nconst $ff52364279a4c3f6$var$isFunctionMessage = (message)=>{\n    return message?.role === \"function\";\n};\nmodule.exports.isFunctionMessage = $ff52364279a4c3f6$var$isFunctionMessage;\nconst $ff52364279a4c3f6$var$isToolMessage = (message)=>{\n    return message?.role === \"tool\";\n};\nmodule.exports.isToolMessage = $ff52364279a4c3f6$var$isToolMessage;\nfunction $ff52364279a4c3f6$var$isPresent(obj) {\n    return obj != null;\n}\nmodule.exports.isPresent = $ff52364279a4c3f6$var$isPresent;\n\n});\n\nparcelRegister(\"aE86S\", function(module, exports) {\n\"use strict\";\nvar $7c03ee430b911abc$var$__classPrivateFieldSet = module.exports && module.exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar $7c03ee430b911abc$var$__classPrivateFieldGet = module.exports && module.exports.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar $7c03ee430b911abc$var$_EventStream_instances, $7c03ee430b911abc$var$_EventStream_connectedPromise, $7c03ee430b911abc$var$_EventStream_resolveConnectedPromise, $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise, $7c03ee430b911abc$var$_EventStream_endPromise, $7c03ee430b911abc$var$_EventStream_resolveEndPromise, $7c03ee430b911abc$var$_EventStream_rejectEndPromise, $7c03ee430b911abc$var$_EventStream_listeners, $7c03ee430b911abc$var$_EventStream_ended, $7c03ee430b911abc$var$_EventStream_errored, $7c03ee430b911abc$var$_EventStream_aborted, $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated, $7c03ee430b911abc$var$_EventStream_handleError;\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.EventStream = void 0;\n\nvar $hTt11 = parcelRequire(\"hTt11\");\nclass $7c03ee430b911abc$var$EventStream {\n    constructor(){\n        $7c03ee430b911abc$var$_EventStream_instances.add(this);\n        this.controller = new AbortController();\n        $7c03ee430b911abc$var$_EventStream_connectedPromise.set(this, void 0);\n        $7c03ee430b911abc$var$_EventStream_resolveConnectedPromise.set(this, ()=>{});\n        $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise.set(this, ()=>{});\n        $7c03ee430b911abc$var$_EventStream_endPromise.set(this, void 0);\n        $7c03ee430b911abc$var$_EventStream_resolveEndPromise.set(this, ()=>{});\n        $7c03ee430b911abc$var$_EventStream_rejectEndPromise.set(this, ()=>{});\n        $7c03ee430b911abc$var$_EventStream_listeners.set(this, {});\n        $7c03ee430b911abc$var$_EventStream_ended.set(this, false);\n        $7c03ee430b911abc$var$_EventStream_errored.set(this, false);\n        $7c03ee430b911abc$var$_EventStream_aborted.set(this, false);\n        $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated.set(this, false);\n        $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_connectedPromise, new Promise((resolve, reject)=>{\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_resolveConnectedPromise, resolve, \"f\");\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_endPromise, new Promise((resolve, reject)=>{\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_resolveEndPromise, resolve, \"f\");\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_connectedPromise, \"f\").catch(()=>{});\n        $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_endPromise, \"f\").catch(()=>{});\n    }\n    _run(executor) {\n        // Unfortunately if we call `executor()` immediately we get runtime errors about\n        // references to `this` before the `super()` constructor call returns.\n        setTimeout(()=>{\n            executor().then(()=>{\n                this._emitFinal();\n                this._emit(\"end\");\n            }, $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_instances, \"m\", $7c03ee430b911abc$var$_EventStream_handleError).bind(this));\n        }, 0);\n    }\n    _connected() {\n        if (this.ended) return;\n        $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_resolveConnectedPromise, \"f\").call(this);\n        this._emit(\"connect\");\n    }\n    get ended() {\n        return $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_ended, \"f\");\n    }\n    get errored() {\n        return $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_errored, \"f\");\n    }\n    get aborted() {\n        return $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */ on(event, listener) {\n        const listeners = $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event] || ($7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event] = []);\n        listeners.push({\n            listener: listener\n        });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */ off(event, listener) {\n        const listeners = $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event];\n        if (!listeners) return this;\n        const index = listeners.findIndex((l)=>l.listener === listener);\n        if (index >= 0) listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */ once(event, listener) {\n        const listeners = $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event] || ($7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event] = []);\n        listeners.push({\n            listener: listener,\n            once: true\n        });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */ emitted(event) {\n        return new Promise((resolve, reject)=>{\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated, true, \"f\");\n            if (event !== \"error\") this.once(\"error\", reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated, true, \"f\");\n        await $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_endPromise, \"f\");\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any events after end\n        if ($7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_ended, \"f\")) return;\n        if (event === \"end\") {\n            $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_ended, true, \"f\");\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event];\n        if (listeners) {\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_listeners, \"f\")[event] = listeners.filter((l)=>!l.once);\n            listeners.forEach(({ listener: listener })=>listener(...args));\n        }\n        if (event === \"abort\") {\n            const error = args[0];\n            if (!$7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) Promise.reject(error);\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit(\"end\");\n            return;\n        }\n        if (event === \"error\") {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!$7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n            // If you are seeing stack traces here, make sure to handle errors via either:\n            // - runner.on('error', () => ...)\n            // - await runner.done()\n            // - await runner.finalChatCompletion()\n            // - etc.\n            Promise.reject(error);\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            $7c03ee430b911abc$var$__classPrivateFieldGet(this, $7c03ee430b911abc$var$_EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit(\"end\");\n        }\n    }\n    _emitFinal() {}\n}\nmodule.exports.EventStream = $7c03ee430b911abc$var$EventStream;\n$7c03ee430b911abc$var$_EventStream_connectedPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_resolveConnectedPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_rejectConnectedPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_endPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_resolveEndPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_rejectEndPromise = new WeakMap(), $7c03ee430b911abc$var$_EventStream_listeners = new WeakMap(), $7c03ee430b911abc$var$_EventStream_ended = new WeakMap(), $7c03ee430b911abc$var$_EventStream_errored = new WeakMap(), $7c03ee430b911abc$var$_EventStream_aborted = new WeakMap(), $7c03ee430b911abc$var$_EventStream_catchingPromiseCreated = new WeakMap(), $7c03ee430b911abc$var$_EventStream_instances = new WeakSet(), $7c03ee430b911abc$var$_EventStream_handleError = function _EventStream_handleError(error) {\n    $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_errored, true, \"f\");\n    if (error instanceof Error && error.name === \"AbortError\") error = new $hTt11.APIUserAbortError();\n    if (error instanceof $hTt11.APIUserAbortError) {\n        $7c03ee430b911abc$var$__classPrivateFieldSet(this, $7c03ee430b911abc$var$_EventStream_aborted, true, \"f\");\n        return this._emit(\"abort\", error);\n    }\n    if (error instanceof $hTt11.OpenAIError) return this._emit(\"error\", error);\n    if (error instanceof Error) {\n        const openAIError = new $hTt11.OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit(\"error\", openAIError);\n    }\n    return this._emit(\"error\", new $hTt11.OpenAIError(String(error)));\n};\n\n});\n\nparcelRegister(\"8TnOx\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateInputTools = module.exports.hasAutoParseableInput = module.exports.shouldParseToolCall = module.exports.parseChatCompletion = module.exports.maybeParseChatCompletion = module.exports.isAutoParsableTool = module.exports.makeParseableTool = module.exports.isAutoParsableResponseFormat = module.exports.makeParseableResponseFormat = void 0;\n\nvar $hTt11 = parcelRequire(\"hTt11\");\nfunction $6795eec1c548472d$var$makeParseableResponseFormat(response_format, parser) {\n    const obj = {\n        ...response_format\n    };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: \"auto-parseable-response-format\",\n            enumerable: false\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false\n        }\n    });\n    return obj;\n}\nmodule.exports.makeParseableResponseFormat = $6795eec1c548472d$var$makeParseableResponseFormat;\nfunction $6795eec1c548472d$var$isAutoParsableResponseFormat(response_format) {\n    return response_format?.[\"$brand\"] === \"auto-parseable-response-format\";\n}\nmodule.exports.isAutoParsableResponseFormat = $6795eec1c548472d$var$isAutoParsableResponseFormat;\nfunction $6795eec1c548472d$var$makeParseableTool(tool, { parser: parser, callback: callback }) {\n    const obj = {\n        ...tool\n    };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: \"auto-parseable-tool\",\n            enumerable: false\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false\n        },\n        $callback: {\n            value: callback,\n            enumerable: false\n        }\n    });\n    return obj;\n}\nmodule.exports.makeParseableTool = $6795eec1c548472d$var$makeParseableTool;\nfunction $6795eec1c548472d$var$isAutoParsableTool(tool) {\n    return tool?.[\"$brand\"] === \"auto-parseable-tool\";\n}\nmodule.exports.isAutoParsableTool = $6795eec1c548472d$var$isAutoParsableTool;\nfunction $6795eec1c548472d$var$maybeParseChatCompletion(completion, params) {\n    if (!params || !$6795eec1c548472d$var$hasAutoParseableInput(params)) return {\n        ...completion,\n        choices: completion.choices.map((choice)=>({\n                ...choice,\n                message: {\n                    ...choice.message,\n                    parsed: null,\n                    tool_calls: choice.message.tool_calls ?? []\n                }\n            }))\n    };\n    return $6795eec1c548472d$var$parseChatCompletion(completion, params);\n}\nmodule.exports.maybeParseChatCompletion = $6795eec1c548472d$var$maybeParseChatCompletion;\nfunction $6795eec1c548472d$var$parseChatCompletion(completion, params) {\n    const choices = completion.choices.map((choice)=>{\n        if (choice.finish_reason === \"length\") throw new $hTt11.LengthFinishReasonError();\n        if (choice.finish_reason === \"content_filter\") throw new $hTt11.ContentFilterFinishReasonError();\n        return {\n            ...choice,\n            message: {\n                ...choice.message,\n                tool_calls: choice.message.tool_calls?.map((toolCall)=>$6795eec1c548472d$var$parseToolCall(params, toolCall)) ?? [],\n                parsed: choice.message.content && !choice.message.refusal ? $6795eec1c548472d$var$parseResponseFormat(params, choice.message.content) : null\n            }\n        };\n    });\n    return {\n        ...completion,\n        choices: choices\n    };\n}\nmodule.exports.parseChatCompletion = $6795eec1c548472d$var$parseChatCompletion;\nfunction $6795eec1c548472d$var$parseResponseFormat(params, content) {\n    if (params.response_format?.type !== \"json_schema\") return null;\n    if (params.response_format?.type === \"json_schema\") {\n        if (\"$parseRaw\" in params.response_format) {\n            const response_format = params.response_format;\n            return response_format.$parseRaw(content);\n        }\n        return JSON.parse(content);\n    }\n    return null;\n}\nfunction $6795eec1c548472d$var$parseToolCall(params, toolCall) {\n    const inputTool = params.tools?.find((inputTool)=>inputTool.function?.name === toolCall.function.name);\n    return {\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            parsed_arguments: $6795eec1c548472d$var$isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null\n        }\n    };\n}\nfunction $6795eec1c548472d$var$shouldParseToolCall(params, toolCall) {\n    if (!params) return false;\n    const inputTool = params.tools?.find((inputTool)=>inputTool.function?.name === toolCall.function.name);\n    return $6795eec1c548472d$var$isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nmodule.exports.shouldParseToolCall = $6795eec1c548472d$var$shouldParseToolCall;\nfunction $6795eec1c548472d$var$hasAutoParseableInput(params) {\n    if ($6795eec1c548472d$var$isAutoParsableResponseFormat(params.response_format)) return true;\n    return params.tools?.some((t)=>$6795eec1c548472d$var$isAutoParsableTool(t) || t.type === \"function\" && t.function.strict === true) ?? false;\n}\nmodule.exports.hasAutoParseableInput = $6795eec1c548472d$var$hasAutoParseableInput;\nfunction $6795eec1c548472d$var$validateInputTools(tools) {\n    for (const tool of tools ?? []){\n        if (tool.type !== \"function\") throw new $hTt11.OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        if (tool.function.strict !== true) throw new $hTt11.OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n}\nmodule.exports.validateInputTools = $6795eec1c548472d$var$validateInputTools;\n\n});\n\n\n\nparcelRegister(\"6tV2R\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ChatCompletionStreamingRunner = void 0;\n\nvar $2ArjU = parcelRequire(\"2ArjU\");\nclass $4b81b37d4a971c7e$var$ChatCompletionStreamingRunner extends $2ArjU.ChatCompletionStream {\n    static fromReadableStream(stream) {\n        const runner = new $4b81b37d4a971c7e$var$ChatCompletionStreamingRunner(null);\n        runner._run(()=>runner._fromReadableStream(stream));\n        return runner;\n    }\n    /** @deprecated - please use `runTools` instead. */ static runFunctions(client, params, options) {\n        const runner = new $4b81b37d4a971c7e$var$ChatCompletionStreamingRunner(null);\n        const opts = {\n            ...options,\n            headers: {\n                ...options?.headers,\n                \"X-Stainless-Helper-Method\": \"runFunctions\"\n            }\n        };\n        runner._run(()=>runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new $4b81b37d4a971c7e$var$ChatCompletionStreamingRunner(// @ts-expect-error TODO these types are incompatible\n        params);\n        const opts = {\n            ...options,\n            headers: {\n                ...options?.headers,\n                \"X-Stainless-Helper-Method\": \"runTools\"\n            }\n        };\n        runner._run(()=>runner._runTools(client, params, opts));\n        return runner;\n    }\n}\nmodule.exports.ChatCompletionStreamingRunner = $4b81b37d4a971c7e$var$ChatCompletionStreamingRunner;\n\n});\nparcelRegister(\"2ArjU\", function(module, exports) {\n\"use strict\";\nvar $1e2422cab6410049$var$__classPrivateFieldSet = module.exports && module.exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar $1e2422cab6410049$var$__classPrivateFieldGet = module.exports && module.exports.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar $1e2422cab6410049$var$_ChatCompletionStream_instances, $1e2422cab6410049$var$_ChatCompletionStream_params, $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, $1e2422cab6410049$var$_ChatCompletionStream_beginRequest, $1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState, $1e2422cab6410049$var$_ChatCompletionStream_addChunk, $1e2422cab6410049$var$_ChatCompletionStream_emitToolCallDoneEvent, $1e2422cab6410049$var$_ChatCompletionStream_emitContentDoneEvents, $1e2422cab6410049$var$_ChatCompletionStream_endRequest, $1e2422cab6410049$var$_ChatCompletionStream_getAutoParseableResponseFormat, $1e2422cab6410049$var$_ChatCompletionStream_accumulateChatCompletion;\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ChatCompletionStream = void 0;\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nvar $dLYfX = parcelRequire(\"dLYfX\");\n\nvar $9Dbsu = parcelRequire(\"9Dbsu\");\n\nvar $8TnOx = parcelRequire(\"8TnOx\");\n\nvar $llclb = parcelRequire(\"llclb\");\nclass $1e2422cab6410049$var$ChatCompletionStream extends $dLYfX.AbstractChatCompletionRunner {\n    constructor(params){\n        super();\n        $1e2422cab6410049$var$_ChatCompletionStream_instances.add(this);\n        $1e2422cab6410049$var$_ChatCompletionStream_params.set(this, void 0);\n        $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates.set(this, void 0);\n        $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n        $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, params, \"f\");\n        $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates, [], \"f\");\n    }\n    get currentChatCompletionSnapshot() {\n        return $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */ static fromReadableStream(stream) {\n        const runner = new $1e2422cab6410049$var$ChatCompletionStream(null);\n        runner._run(()=>runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(client, params, options) {\n        const runner = new $1e2422cab6410049$var$ChatCompletionStream(params);\n        runner._run(()=>runner._runChatCompletion(client, {\n                ...params,\n                stream: true\n            }, {\n                ...options,\n                headers: {\n                    ...options?.headers,\n                    \"X-Stainless-Helper-Method\": \"stream\"\n                }\n            }));\n        return runner;\n    }\n    async _createChatCompletion(client, params, options) {\n        super._createChatCompletion;\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_beginRequest).call(this);\n        const stream = await client.chat.completions.create({\n            ...params,\n            stream: true\n        }, {\n            ...options,\n            signal: this.controller.signal\n        });\n        this._connected();\n        for await (const chunk of stream)$1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_addChunk).call(this, chunk);\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addChatCompletion($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = $9Dbsu.Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream){\n            if (chatId && chatId !== chunk.id) // A new request has been made.\n            this._addChatCompletion($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_endRequest).call(this));\n            $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addChatCompletion($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_endRequest).call(this));\n    }\n    [($1e2422cab6410049$var$_ChatCompletionStream_params = new WeakMap(), $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates = new WeakMap(), $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), $1e2422cab6410049$var$_ChatCompletionStream_instances = new WeakSet(), $1e2422cab6410049$var$_ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended) return;\n        $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, $1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n        let state = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n        if (state) return state;\n        state = {\n            content_done: false,\n            refusal_done: false,\n            logprobs_content_done: false,\n            logprobs_refusal_done: false,\n            done_tool_calls: new Set(),\n            current_tool_call_index: null\n        };\n        $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n        return state;\n    }, $1e2422cab6410049$var$_ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended) return;\n        const completion = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit(\"chunk\", chunk, completion);\n        for (const choice of chunk.choices){\n            const choiceSnapshot = completion.choices[choice.index];\n            if (choice.delta.content != null && choiceSnapshot.message?.role === \"assistant\" && choiceSnapshot.message?.content) {\n                this._emit(\"content\", choice.delta.content, choiceSnapshot.message.content);\n                this._emit(\"content.delta\", {\n                    delta: choice.delta.content,\n                    snapshot: choiceSnapshot.message.content,\n                    parsed: choiceSnapshot.message.parsed\n                });\n            }\n            if (choice.delta.refusal != null && choiceSnapshot.message?.role === \"assistant\" && choiceSnapshot.message?.refusal) this._emit(\"refusal.delta\", {\n                delta: choice.delta.refusal,\n                snapshot: choiceSnapshot.message.refusal\n            });\n            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === \"assistant\") this._emit(\"logprobs.content.delta\", {\n                content: choice.logprobs?.content,\n                snapshot: choiceSnapshot.logprobs?.content ?? []\n            });\n            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === \"assistant\") this._emit(\"logprobs.refusal.delta\", {\n                refusal: choice.logprobs?.refusal,\n                snapshot: choiceSnapshot.logprobs?.refusal ?? []\n            });\n            const state = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n            if (choiceSnapshot.finish_reason) {\n                $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                if (state.current_tool_call_index != null) $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n            }\n            for (const toolCall of choice.delta.tool_calls ?? []){\n                if (state.current_tool_call_index !== toolCall.index) {\n                    $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                    // new tool call started, the previous one is done\n                    if (state.current_tool_call_index != null) $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                }\n                state.current_tool_call_index = toolCall.index;\n            }\n            for (const toolCallDelta of choice.delta.tool_calls ?? []){\n                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                if (!toolCallSnapshot?.type) continue;\n                if (toolCallSnapshot?.type === \"function\") this._emit(\"tool_calls.function.arguments.delta\", {\n                    name: toolCallSnapshot.function?.name,\n                    index: toolCallDelta.index,\n                    arguments: toolCallSnapshot.function.arguments,\n                    parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                    arguments_delta: toolCallDelta.function?.arguments ?? \"\"\n                });\n                else $1e2422cab6410049$var$assertNever(toolCallSnapshot?.type);\n            }\n        }\n    }, $1e2422cab6410049$var$_ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n        const state = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (state.done_tool_calls.has(toolCallIndex)) // we've already fired the done event\n        return;\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n        if (!toolCallSnapshot) throw new Error(\"no tool call snapshot\");\n        if (!toolCallSnapshot.type) throw new Error(\"tool call snapshot missing `type`\");\n        if (toolCallSnapshot.type === \"function\") {\n            const inputTool = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\")?.tools?.find((tool)=>tool.type === \"function\" && tool.function.name === toolCallSnapshot.function.name);\n            this._emit(\"tool_calls.function.arguments.done\", {\n                name: toolCallSnapshot.function.name,\n                index: toolCallIndex,\n                arguments: toolCallSnapshot.function.arguments,\n                parsed_arguments: (0, $8TnOx.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null\n            });\n        } else $1e2422cab6410049$var$assertNever(toolCallSnapshot.type);\n    }, $1e2422cab6410049$var$_ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n        const state = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (choiceSnapshot.message.content && !state.content_done) {\n            state.content_done = true;\n            const responseFormat = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n            this._emit(\"content.done\", {\n                content: choiceSnapshot.message.content,\n                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null\n            });\n        }\n        if (choiceSnapshot.message.refusal && !state.refusal_done) {\n            state.refusal_done = true;\n            this._emit(\"refusal.done\", {\n                refusal: choiceSnapshot.message.refusal\n            });\n        }\n        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n            state.logprobs_content_done = true;\n            this._emit(\"logprobs.content.done\", {\n                content: choiceSnapshot.logprobs.content\n            });\n        }\n        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n            state.logprobs_refusal_done = true;\n            this._emit(\"logprobs.refusal.done\", {\n                refusal: choiceSnapshot.logprobs.refusal\n            });\n        }\n    }, $1e2422cab6410049$var$_ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) throw new $hTt11.OpenAIError(`stream has ended, this shouldn't happen`);\n        const snapshot = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) throw new $hTt11.OpenAIError(`request ended without sending any chunks`);\n        $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates, [], \"f\");\n        return $1e2422cab6410049$var$finalizeChatCompletion(snapshot, $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\"));\n    }, $1e2422cab6410049$var$_ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n        const responseFormat = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\")?.response_format;\n        if ((0, $8TnOx.isAutoParsableResponseFormat)(responseFormat)) return responseFormat;\n        return null;\n    }, $1e2422cab6410049$var$_ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c, _d;\n        let snapshot = $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices: choices, ...rest } = chunk;\n        if (!snapshot) snapshot = $1e2422cab6410049$var$__classPrivateFieldSet(this, $1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot, {\n            ...rest,\n            choices: []\n        }, \"f\");\n        else Object.assign(snapshot, rest);\n        for (const { delta: delta, finish_reason: finish_reason, index: index, logprobs: logprobs = null, ...other } of chunk.choices){\n            let choice = snapshot.choices[index];\n            if (!choice) choice = snapshot.choices[index] = {\n                finish_reason: finish_reason,\n                index: index,\n                message: {},\n                logprobs: logprobs,\n                ...other\n            };\n            if (logprobs) {\n                if (!choice.logprobs) choice.logprobs = Object.assign({}, logprobs);\n                else {\n                    const { content: content, refusal: refusal, ...rest } = logprobs;\n                    $1e2422cab6410049$var$assertIsEmpty(rest);\n                    Object.assign(choice.logprobs, rest);\n                    if (content) {\n                        (_a = choice.logprobs).content ?? (_a.content = []);\n                        choice.logprobs.content.push(...content);\n                    }\n                    if (refusal) {\n                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                        choice.logprobs.refusal.push(...refusal);\n                    }\n                }\n            }\n            if (finish_reason) {\n                choice.finish_reason = finish_reason;\n                if ($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\") && (0, $8TnOx.hasAutoParseableInput)($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\"))) {\n                    if (finish_reason === \"length\") throw new $hTt11.LengthFinishReasonError();\n                    if (finish_reason === \"content_filter\") throw new $hTt11.ContentFilterFinishReasonError();\n                }\n            }\n            Object.assign(choice, other);\n            if (!delta) continue; // Shouldn't happen; just in case.\n            const { content: content, refusal: refusal, function_call: function_call, role: role, tool_calls: tool_calls, ...rest } = delta;\n            $1e2422cab6410049$var$assertIsEmpty(rest);\n            Object.assign(choice.message, rest);\n            if (refusal) choice.message.refusal = (choice.message.refusal || \"\") + refusal;\n            if (role) choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) choice.message.function_call = function_call;\n                else {\n                    if (function_call.name) choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_c = choice.message.function_call).arguments ?? (_c.arguments = \"\");\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (content) {\n                choice.message.content = (choice.message.content || \"\") + content;\n                if (!choice.message.refusal && $1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_instances, \"m\", $1e2422cab6410049$var$_ChatCompletionStream_getAutoParseableResponseFormat).call(this)) choice.message.parsed = (0, $llclb.partialParse)(choice.message.content);\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls) choice.message.tool_calls = [];\n                for (const { index: index, id: id, type: type, function: fn, ...rest } of tool_calls){\n                    const tool_call = (_d = choice.message.tool_calls)[index] ?? (_d[index] = {});\n                    Object.assign(tool_call, rest);\n                    if (id) tool_call.id = id;\n                    if (type) tool_call.type = type;\n                    if (fn) tool_call.function ?? (tool_call.function = {\n                        name: fn.name ?? \"\",\n                        arguments: \"\"\n                    });\n                    if (fn?.name) tool_call.function.name = fn.name;\n                    if (fn?.arguments) {\n                        tool_call.function.arguments += fn.arguments;\n                        if ((0, $8TnOx.shouldParseToolCall)($1e2422cab6410049$var$__classPrivateFieldGet(this, $1e2422cab6410049$var$_ChatCompletionStream_params, \"f\"), tool_call)) tool_call.function.parsed_arguments = (0, $llclb.partialParse)(tool_call.function.arguments);\n                    }\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on(\"chunk\", (chunk)=>{\n            const reader = readQueue.shift();\n            if (reader) reader.resolve(chunk);\n            else pushQueue.push(chunk);\n        });\n        this.on(\"end\", ()=>{\n            done = true;\n            for (const reader of readQueue)reader.resolve(undefined);\n            readQueue.length = 0;\n        });\n        this.on(\"abort\", (err)=>{\n            done = true;\n            for (const reader of readQueue)reader.reject(err);\n            readQueue.length = 0;\n        });\n        this.on(\"error\", (err)=>{\n            done = true;\n            for (const reader of readQueue)reader.reject(err);\n            readQueue.length = 0;\n        });\n        return {\n            next: async ()=>{\n                if (!pushQueue.length) {\n                    if (done) return {\n                        value: undefined,\n                        done: true\n                    };\n                    return new Promise((resolve, reject)=>readQueue.push({\n                            resolve: resolve,\n                            reject: reject\n                        })).then((chunk)=>chunk ? {\n                            value: chunk,\n                            done: false\n                        } : {\n                            value: undefined,\n                            done: true\n                        });\n                }\n                const chunk = pushQueue.shift();\n                return {\n                    value: chunk,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                this.abort();\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    toReadableStream() {\n        const stream = new $9Dbsu.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nmodule.exports.ChatCompletionStream = $1e2422cab6410049$var$ChatCompletionStream;\nfunction $1e2422cab6410049$var$finalizeChatCompletion(snapshot, params) {\n    const { id: id, choices: choices, created: created, model: model, system_fingerprint: system_fingerprint, ...rest } = snapshot;\n    const completion = {\n        ...rest,\n        id: id,\n        choices: choices.map(({ message: message, finish_reason: finish_reason, index: index, logprobs: logprobs, ...choiceRest })=>{\n            if (!finish_reason) throw new $hTt11.OpenAIError(`missing finish_reason for choice ${index}`);\n            const { content: content = null, function_call: function_call, tool_calls: tool_calls, ...messageRest } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role) throw new $hTt11.OpenAIError(`missing role for choice ${index}`);\n            if (function_call) {\n                const { arguments: args, name: name } = function_call;\n                if (args == null) throw new $hTt11.OpenAIError(`missing function_call.arguments for choice ${index}`);\n                if (!name) throw new $hTt11.OpenAIError(`missing function_call.name for choice ${index}`);\n                return {\n                    ...choiceRest,\n                    message: {\n                        content: content,\n                        function_call: {\n                            arguments: args,\n                            name: name\n                        },\n                        role: role,\n                        refusal: message.refusal ?? null\n                    },\n                    finish_reason: finish_reason,\n                    index: index,\n                    logprobs: logprobs\n                };\n            }\n            if (tool_calls) return {\n                ...choiceRest,\n                index: index,\n                finish_reason: finish_reason,\n                logprobs: logprobs,\n                message: {\n                    ...messageRest,\n                    role: role,\n                    content: content,\n                    refusal: message.refusal ?? null,\n                    tool_calls: tool_calls.map((tool_call, i)=>{\n                        const { function: fn, type: type, id: id, ...toolRest } = tool_call;\n                        const { arguments: args, name: name, ...fnRest } = fn || {};\n                        if (id == null) throw new $hTt11.OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${$1e2422cab6410049$var$str(snapshot)}`);\n                        if (type == null) throw new $hTt11.OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${$1e2422cab6410049$var$str(snapshot)}`);\n                        if (name == null) throw new $hTt11.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${$1e2422cab6410049$var$str(snapshot)}`);\n                        if (args == null) throw new $hTt11.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${$1e2422cab6410049$var$str(snapshot)}`);\n                        return {\n                            ...toolRest,\n                            id: id,\n                            type: type,\n                            function: {\n                                ...fnRest,\n                                name: name,\n                                arguments: args\n                            }\n                        };\n                    })\n                }\n            };\n            return {\n                ...choiceRest,\n                message: {\n                    ...messageRest,\n                    content: content,\n                    role: role,\n                    refusal: message.refusal ?? null\n                },\n                finish_reason: finish_reason,\n                index: index,\n                logprobs: logprobs\n            };\n        }),\n        created: created,\n        model: model,\n        object: \"chat.completion\",\n        ...system_fingerprint ? {\n            system_fingerprint: system_fingerprint\n        } : {}\n    };\n    return (0, $8TnOx.maybeParseChatCompletion)(completion, params);\n}\nfunction $1e2422cab6410049$var$str(x) {\n    return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */ function $1e2422cab6410049$var$assertIsEmpty(obj) {\n    return;\n}\nfunction $1e2422cab6410049$var$assertNever(_x) {}\n\n});\nparcelRegister(\"llclb\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.MalformedJSON = module.exports.PartialJSON = module.exports.partialParse = void 0;\nconst $f89521b6a1d718ec$var$STR = 1;\nconst $f89521b6a1d718ec$var$NUM = 2;\nconst $f89521b6a1d718ec$var$ARR = 4;\nconst $f89521b6a1d718ec$var$OBJ = 8;\nconst $f89521b6a1d718ec$var$NULL = 16;\nconst $f89521b6a1d718ec$var$BOOL = 32;\nconst $f89521b6a1d718ec$var$NAN = 64;\nconst $f89521b6a1d718ec$var$INFINITY = 128;\nconst $f89521b6a1d718ec$var$MINUS_INFINITY = 256;\nconst $f89521b6a1d718ec$var$INF = $f89521b6a1d718ec$var$INFINITY | $f89521b6a1d718ec$var$MINUS_INFINITY;\nconst $f89521b6a1d718ec$var$SPECIAL = $f89521b6a1d718ec$var$NULL | $f89521b6a1d718ec$var$BOOL | $f89521b6a1d718ec$var$INF | $f89521b6a1d718ec$var$NAN;\nconst $f89521b6a1d718ec$var$ATOM = $f89521b6a1d718ec$var$STR | $f89521b6a1d718ec$var$NUM | $f89521b6a1d718ec$var$SPECIAL;\nconst $f89521b6a1d718ec$var$COLLECTION = $f89521b6a1d718ec$var$ARR | $f89521b6a1d718ec$var$OBJ;\nconst $f89521b6a1d718ec$var$ALL = $f89521b6a1d718ec$var$ATOM | $f89521b6a1d718ec$var$COLLECTION;\nconst $f89521b6a1d718ec$var$Allow = {\n    STR: $f89521b6a1d718ec$var$STR,\n    NUM: $f89521b6a1d718ec$var$NUM,\n    ARR: $f89521b6a1d718ec$var$ARR,\n    OBJ: $f89521b6a1d718ec$var$OBJ,\n    NULL: $f89521b6a1d718ec$var$NULL,\n    BOOL: $f89521b6a1d718ec$var$BOOL,\n    NAN: $f89521b6a1d718ec$var$NAN,\n    INFINITY: $f89521b6a1d718ec$var$INFINITY,\n    MINUS_INFINITY: $f89521b6a1d718ec$var$MINUS_INFINITY,\n    INF: $f89521b6a1d718ec$var$INF,\n    SPECIAL: $f89521b6a1d718ec$var$SPECIAL,\n    ATOM: $f89521b6a1d718ec$var$ATOM,\n    COLLECTION: $f89521b6a1d718ec$var$COLLECTION,\n    ALL: $f89521b6a1d718ec$var$ALL\n};\n// The JSON string segment was unable to be parsed completely\nclass $f89521b6a1d718ec$var$PartialJSON extends Error {\n}\nmodule.exports.PartialJSON = $f89521b6a1d718ec$var$PartialJSON;\nclass $f89521b6a1d718ec$var$MalformedJSON extends Error {\n}\nmodule.exports.MalformedJSON = $f89521b6a1d718ec$var$MalformedJSON;\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */ function $f89521b6a1d718ec$var$parseJSON(jsonString, allowPartial = $f89521b6a1d718ec$var$Allow.ALL) {\n    if (typeof jsonString !== \"string\") throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    if (!jsonString.trim()) throw new Error(`${jsonString} is empty`);\n    return $f89521b6a1d718ec$var$_parseJSON(jsonString.trim(), allowPartial);\n}\nconst $f89521b6a1d718ec$var$_parseJSON = (jsonString, allow)=>{\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg)=>{\n        throw new $f89521b6a1d718ec$var$PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg)=>{\n        throw new $f89521b6a1d718ec$var$MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = ()=>{\n        skipBlank();\n        if (index >= length) markPartialJSON(\"Unexpected end of input\");\n        if (jsonString[index] === '\"') return parseStr();\n        if (jsonString[index] === \"{\") return parseObj();\n        if (jsonString[index] === \"[\") return parseArr();\n        if (jsonString.substring(index, index + 4) === \"null\" || $f89521b6a1d718ec$var$Allow.NULL & allow && length - index < 4 && \"null\".startsWith(jsonString.substring(index))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === \"true\" || $f89521b6a1d718ec$var$Allow.BOOL & allow && length - index < 4 && \"true\".startsWith(jsonString.substring(index))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === \"false\" || $f89521b6a1d718ec$var$Allow.BOOL & allow && length - index < 5 && \"false\".startsWith(jsonString.substring(index))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === \"Infinity\" || $f89521b6a1d718ec$var$Allow.INFINITY & allow && length - index < 8 && \"Infinity\".startsWith(jsonString.substring(index))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === \"-Infinity\" || $f89521b6a1d718ec$var$Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && \"-Infinity\".startsWith(jsonString.substring(index))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === \"NaN\" || $f89521b6a1d718ec$var$Allow.NAN & allow && length - index < 3 && \"NaN\".startsWith(jsonString.substring(index))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = ()=>{\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while(index < length && (jsonString[index] !== '\"' || escape && jsonString[index - 1] === \"\\\\\")){\n            escape = jsonString[index] === \"\\\\\" ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') try {\n            return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n        } catch (e) {\n            throwMalformedError(String(e));\n        }\n        else if ($f89521b6a1d718ec$var$Allow.STR & allow) try {\n            return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n        } catch (e) {\n            // SyntaxError: Invalid escape sequence\n            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf(\"\\\\\")) + '\"');\n        }\n        markPartialJSON(\"Unterminated string literal\");\n    };\n    const parseObj = ()=>{\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while(jsonString[index] !== \"}\"){\n                skipBlank();\n                if (index >= length && $f89521b6a1d718ec$var$Allow.OBJ & allow) return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                } catch (e) {\n                    if ($f89521b6a1d718ec$var$Allow.OBJ & allow) return obj;\n                    else throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === \",\") index++; // skip comma\n            }\n        } catch (e) {\n            if ($f89521b6a1d718ec$var$Allow.OBJ & allow) return obj;\n            else markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = ()=>{\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while(jsonString[index] !== \"]\"){\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === \",\") index++; // skip comma\n            }\n        } catch (e) {\n            if ($f89521b6a1d718ec$var$Allow.ARR & allow) return arr;\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = ()=>{\n        if (index === 0) {\n            if (jsonString === \"-\" && $f89521b6a1d718ec$var$Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            } catch (e) {\n                if ($f89521b6a1d718ec$var$Allow.NUM & allow) try {\n                    if (\".\" === jsonString[jsonString.length - 1]) return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(\".\")));\n                    return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(\"e\")));\n                } catch (e) {}\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === \"-\") index++;\n        while(jsonString[index] && !\",]}\".includes(jsonString[index]))index++;\n        if (index == length && !($f89521b6a1d718ec$var$Allow.NUM & allow)) markPartialJSON(\"Unterminated number literal\");\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        } catch (e) {\n            if (jsonString.substring(start, index) === \"-\" && $f89521b6a1d718ec$var$Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf(\"e\")));\n            } catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = ()=>{\n        while(index < length && \" \\n\\r\t\".includes(jsonString[index]))index++;\n    };\n    return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst $f89521b6a1d718ec$var$partialParse = (input)=>$f89521b6a1d718ec$var$parseJSON(input, $f89521b6a1d718ec$var$Allow.ALL ^ $f89521b6a1d718ec$var$Allow.NUM);\nmodule.exports.partialParse = $f89521b6a1d718ec$var$partialParse;\n\n});\n\n\n\n\n\nparcelRegister(\"hU1vh\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $035d0bb2680a6aee$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $035d0bb2680a6aee$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $035d0bb2680a6aee$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $035d0bb2680a6aee$var$__createBinding(result, mod, k);\n    }\n    $035d0bb2680a6aee$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Threads = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nvar $bbMZx = parcelRequire(\"bbMZx\");\n\nconst $035d0bb2680a6aee$var$MessagesAPI = $035d0bb2680a6aee$var$__importStar((parcelRequire(\"gLdvG\")));\n\nconst $035d0bb2680a6aee$var$RunsAPI = $035d0bb2680a6aee$var$__importStar((parcelRequire(\"crQct\")));\nclass $035d0bb2680a6aee$var$Threads extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.runs = new $035d0bb2680a6aee$var$RunsAPI.Runs(this._client);\n        this.messages = new $035d0bb2680a6aee$var$MessagesAPI.Messages(this._client);\n    }\n    create(body = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(body)) return this.create({}, body);\n        return this._client.post(\"/threads\", {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieves a thread.\n     */ retrieve(threadId, options) {\n        return this._client.get(`/threads/${threadId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Modifies a thread.\n     */ update(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Delete a thread.\n     */ del(threadId, options) {\n        return this._client.delete(`/threads/${threadId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    createAndRun(body, options) {\n        return this._client.post(\"/threads/runs\", {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            },\n            stream: body.stream ?? false\n        });\n    }\n    /**\n     * A helper to create a thread, start a run and then poll for a terminal state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */ async createAndRunPoll(body, options) {\n        const run = await this.createAndRun(body, options);\n        return await this.runs.poll(run.thread_id, run.id, options);\n    }\n    /**\n     * Create a thread and stream the run back\n     */ createAndRunStream(body, options) {\n        return $bbMZx.AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n    }\n}\nmodule.exports.Threads = $035d0bb2680a6aee$var$Threads;\n(function(Threads) {\n    Threads.Runs = $035d0bb2680a6aee$var$RunsAPI.Runs;\n    Threads.RunsPage = $035d0bb2680a6aee$var$RunsAPI.RunsPage;\n    Threads.Messages = $035d0bb2680a6aee$var$MessagesAPI.Messages;\n    Threads.MessagesPage = $035d0bb2680a6aee$var$MessagesAPI.MessagesPage;\n})($035d0bb2680a6aee$var$Threads = module.exports.Threads || (module.exports.Threads = {}));\n\n});\nparcelRegister(\"bbMZx\", function(module, exports) {\n\"use strict\";\nvar $8256b977bba312d2$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $8256b977bba312d2$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $8256b977bba312d2$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $8256b977bba312d2$var$__createBinding(result, mod, k);\n    }\n    $8256b977bba312d2$var$__setModuleDefault(result, mod);\n    return result;\n};\nvar $8256b977bba312d2$var$__classPrivateFieldGet = module.exports && module.exports.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar $8256b977bba312d2$var$__classPrivateFieldSet = module.exports && module.exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar $8256b977bba312d2$var$_AssistantStream_instances, $8256b977bba312d2$var$_AssistantStream_events, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, $8256b977bba312d2$var$_AssistantStream_messageSnapshots, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, $8256b977bba312d2$var$_AssistantStream_finalRun, $8256b977bba312d2$var$_AssistantStream_currentContentIndex, $8256b977bba312d2$var$_AssistantStream_currentContent, $8256b977bba312d2$var$_AssistantStream_currentToolCallIndex, $8256b977bba312d2$var$_AssistantStream_currentToolCall, $8256b977bba312d2$var$_AssistantStream_currentEvent, $8256b977bba312d2$var$_AssistantStream_currentRunSnapshot, $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot, $8256b977bba312d2$var$_AssistantStream_addEvent, $8256b977bba312d2$var$_AssistantStream_endRequest, $8256b977bba312d2$var$_AssistantStream_handleMessage, $8256b977bba312d2$var$_AssistantStream_handleRunStep, $8256b977bba312d2$var$_AssistantStream_handleEvent, $8256b977bba312d2$var$_AssistantStream_accumulateRunStep, $8256b977bba312d2$var$_AssistantStream_accumulateMessage, $8256b977bba312d2$var$_AssistantStream_accumulateContent, $8256b977bba312d2$var$_AssistantStream_handleRun;\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.AssistantStream = void 0;\n\nconst $8256b977bba312d2$var$Core = $8256b977bba312d2$var$__importStar((parcelRequire(\"9xH07\")));\n\nvar $9Dbsu = parcelRequire(\"9Dbsu\");\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nvar $aE86S = parcelRequire(\"aE86S\");\nclass $8256b977bba312d2$var$AssistantStream extends $aE86S.EventStream {\n    constructor(){\n        super(...arguments);\n        $8256b977bba312d2$var$_AssistantStream_instances.add(this);\n        //Track all events in a single list for reference\n        $8256b977bba312d2$var$_AssistantStream_events.set(this, []);\n        //Used to accumulate deltas\n        //We are accumulating many types so the value here is not strict\n        $8256b977bba312d2$var$_AssistantStream_runStepSnapshots.set(this, {});\n        $8256b977bba312d2$var$_AssistantStream_messageSnapshots.set(this, {});\n        $8256b977bba312d2$var$_AssistantStream_messageSnapshot.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_finalRun.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentContentIndex.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentContent.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentToolCallIndex.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentToolCall.set(this, void 0);\n        //For current snapshot methods\n        $8256b977bba312d2$var$_AssistantStream_currentEvent.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentRunSnapshot.set(this, void 0);\n        $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot.set(this, void 0);\n    }\n    [($8256b977bba312d2$var$_AssistantStream_events = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_runStepSnapshots = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_messageSnapshots = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_messageSnapshot = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_finalRun = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentContentIndex = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentContent = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentToolCallIndex = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentToolCall = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentEvent = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentRunSnapshot = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot = new WeakMap(), $8256b977bba312d2$var$_AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        //Catch all for passing along all events\n        this.on(\"event\", (event)=>{\n            const reader = readQueue.shift();\n            if (reader) reader.resolve(event);\n            else pushQueue.push(event);\n        });\n        this.on(\"end\", ()=>{\n            done = true;\n            for (const reader of readQueue)reader.resolve(undefined);\n            readQueue.length = 0;\n        });\n        this.on(\"abort\", (err)=>{\n            done = true;\n            for (const reader of readQueue)reader.reject(err);\n            readQueue.length = 0;\n        });\n        this.on(\"error\", (err)=>{\n            done = true;\n            for (const reader of readQueue)reader.reject(err);\n            readQueue.length = 0;\n        });\n        return {\n            next: async ()=>{\n                if (!pushQueue.length) {\n                    if (done) return {\n                        value: undefined,\n                        done: true\n                    };\n                    return new Promise((resolve, reject)=>readQueue.push({\n                            resolve: resolve,\n                            reject: reject\n                        })).then((chunk)=>chunk ? {\n                            value: chunk,\n                            done: false\n                        } : {\n                            value: undefined,\n                            done: true\n                        });\n                }\n                const chunk = pushQueue.shift();\n                return {\n                    value: chunk,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                this.abort();\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    static fromReadableStream(stream) {\n        const runner = new $8256b977bba312d2$var$AssistantStream();\n        runner._run(()=>runner._fromReadableStream(stream));\n        return runner;\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        this._connected();\n        const stream = $9Dbsu.Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream)$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_addEvent).call(this, event);\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addRun($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_endRequest).call(this));\n    }\n    toReadableStream() {\n        const stream = new $9Dbsu.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n    static createToolAssistantStream(threadId, runId, runs, params, options) {\n        const runner = new $8256b977bba312d2$var$AssistantStream();\n        runner._run(()=>runner._runToolAssistantStream(threadId, runId, runs, params, {\n                ...options,\n                headers: {\n                    ...options?.headers,\n                    \"X-Stainless-Helper-Method\": \"stream\"\n                }\n            }));\n        return runner;\n    }\n    async _createToolAssistantStream(run, threadId, runId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        const body = {\n            ...params,\n            stream: true\n        };\n        const stream = await run.submitToolOutputs(threadId, runId, body, {\n            ...options,\n            signal: this.controller.signal\n        });\n        this._connected();\n        for await (const event of stream)$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_addEvent).call(this, event);\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addRun($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_endRequest).call(this));\n    }\n    static createThreadAssistantStream(params, thread, options) {\n        const runner = new $8256b977bba312d2$var$AssistantStream();\n        runner._run(()=>runner._threadAssistantStream(params, thread, {\n                ...options,\n                headers: {\n                    ...options?.headers,\n                    \"X-Stainless-Helper-Method\": \"stream\"\n                }\n            }));\n        return runner;\n    }\n    static createAssistantStream(threadId, runs, params, options) {\n        const runner = new $8256b977bba312d2$var$AssistantStream();\n        runner._run(()=>runner._runAssistantStream(threadId, runs, params, {\n                ...options,\n                headers: {\n                    ...options?.headers,\n                    \"X-Stainless-Helper-Method\": \"stream\"\n                }\n            }));\n        return runner;\n    }\n    currentEvent() {\n        return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentEvent, \"f\");\n    }\n    currentRun() {\n        return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentRunSnapshot, \"f\");\n    }\n    currentMessageSnapshot() {\n        return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\");\n    }\n    currentRunStepSnapshot() {\n        return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot, \"f\");\n    }\n    async finalRunSteps() {\n        await this.done();\n        return Object.values($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\"));\n    }\n    async finalMessages() {\n        await this.done();\n        return Object.values($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshots, \"f\"));\n    }\n    async finalRun() {\n        await this.done();\n        if (!$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_finalRun, \"f\")) throw Error(\"Final run was not received.\");\n        return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_finalRun, \"f\");\n    }\n    async _createThreadAssistantStream(thread, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        const body = {\n            ...params,\n            stream: true\n        };\n        const stream = await thread.createAndRun(body, {\n            ...options,\n            signal: this.controller.signal\n        });\n        this._connected();\n        for await (const event of stream)$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_addEvent).call(this, event);\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addRun($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_endRequest).call(this));\n    }\n    async _createAssistantStream(run, threadId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted) this.controller.abort();\n            signal.addEventListener(\"abort\", ()=>this.controller.abort());\n        }\n        const body = {\n            ...params,\n            stream: true\n        };\n        const stream = await run.create(threadId, body, {\n            ...options,\n            signal: this.controller.signal\n        });\n        this._connected();\n        for await (const event of stream)$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_addEvent).call(this, event);\n        if (stream.controller.signal?.aborted) throw new $hTt11.APIUserAbortError();\n        return this._addRun($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_endRequest).call(this));\n    }\n    static accumulateDelta(acc, delta) {\n        for (const [key, deltaValue] of Object.entries(delta)){\n            if (!acc.hasOwnProperty(key)) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            let accValue = acc[key];\n            if (accValue === null || accValue === undefined) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // We don't accumulate these special properties\n            if (key === \"index\" || key === \"type\") {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // Type-specific accumulation logic\n            if (typeof accValue === \"string\" && typeof deltaValue === \"string\") accValue += deltaValue;\n            else if (typeof accValue === \"number\" && typeof deltaValue === \"number\") accValue += deltaValue;\n            else if ($8256b977bba312d2$var$Core.isObj(accValue) && $8256b977bba312d2$var$Core.isObj(deltaValue)) accValue = this.accumulateDelta(accValue, deltaValue);\n            else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                if (accValue.every((x)=>typeof x === \"string\" || typeof x === \"number\")) {\n                    accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                    continue;\n                }\n                for (const deltaEntry of deltaValue){\n                    if (!$8256b977bba312d2$var$Core.isObj(deltaEntry)) throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                    const index = deltaEntry[\"index\"];\n                    if (index == null) {\n                        console.error(deltaEntry);\n                        throw new Error(\"Expected array delta entry to have an `index` property\");\n                    }\n                    if (typeof index !== \"number\") throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                    const accEntry = accValue[index];\n                    if (accEntry == null) accValue.push(deltaEntry);\n                    else accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                }\n                continue;\n            } else throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n            acc[key] = accValue;\n        }\n        return acc;\n    }\n    _addRun(run) {\n        return run;\n    }\n    async _threadAssistantStream(params, thread, options) {\n        return await this._createThreadAssistantStream(thread, params, options);\n    }\n    async _runAssistantStream(threadId, runs, params, options) {\n        return await this._createAssistantStream(runs, threadId, params, options);\n    }\n    async _runToolAssistantStream(threadId, runId, runs, params, options) {\n        return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n    }\n}\nmodule.exports.AssistantStream = $8256b977bba312d2$var$AssistantStream;\n$8256b977bba312d2$var$_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n    if (this.ended) return;\n    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentEvent, event, \"f\");\n    $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_handleEvent).call(this, event);\n    switch(event.event){\n        case \"thread.created\":\n            break;\n        case \"thread.run.created\":\n        case \"thread.run.queued\":\n        case \"thread.run.in_progress\":\n        case \"thread.run.requires_action\":\n        case \"thread.run.completed\":\n        case \"thread.run.failed\":\n        case \"thread.run.cancelling\":\n        case \"thread.run.cancelled\":\n        case \"thread.run.expired\":\n            $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_handleRun).call(this, event);\n            break;\n        case \"thread.run.step.created\":\n        case \"thread.run.step.in_progress\":\n        case \"thread.run.step.delta\":\n        case \"thread.run.step.completed\":\n        case \"thread.run.step.failed\":\n        case \"thread.run.step.cancelled\":\n        case \"thread.run.step.expired\":\n            $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_handleRunStep).call(this, event);\n            break;\n        case \"thread.message.created\":\n        case \"thread.message.in_progress\":\n        case \"thread.message.delta\":\n        case \"thread.message.completed\":\n        case \"thread.message.incomplete\":\n            $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_handleMessage).call(this, event);\n            break;\n        case \"error\":\n            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n            throw new Error(\"Encountered an error event in event processing - errors should be processed earlier\");\n    }\n}, $8256b977bba312d2$var$_AssistantStream_endRequest = function _AssistantStream_endRequest() {\n    if (this.ended) throw new $hTt11.OpenAIError(`stream has ended, this shouldn't happen`);\n    if (!$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_finalRun, \"f\")) throw Error(\"Final run has not been received\");\n    return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_finalRun, \"f\");\n}, $8256b977bba312d2$var$_AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n    const [accumulatedMessage, newContent] = $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_accumulateMessage).call(this, event, $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\"));\n    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n    $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n    for (const content of newContent){\n        const snapshotContent = accumulatedMessage.content[content.index];\n        if (snapshotContent?.type == \"text\") this._emit(\"textCreated\", snapshotContent.text);\n    }\n    switch(event.event){\n        case \"thread.message.created\":\n            this._emit(\"messageCreated\", event.data);\n            break;\n        case \"thread.message.in_progress\":\n            break;\n        case \"thread.message.delta\":\n            this._emit(\"messageDelta\", event.data.delta, accumulatedMessage);\n            if (event.data.delta.content) for (const content of event.data.delta.content){\n                //If it is text delta, emit a text delta event\n                if (content.type == \"text\" && content.text) {\n                    let textDelta = content.text;\n                    let snapshot = accumulatedMessage.content[content.index];\n                    if (snapshot && snapshot.type == \"text\") this._emit(\"textDelta\", textDelta, snapshot.text);\n                    else throw Error(\"The snapshot associated with this text delta is not text or missing\");\n                }\n                if (content.index != $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContentIndex, \"f\")) {\n                    //See if we have in progress content\n                    if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContent, \"f\")) switch($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContent, \"f\").type){\n                        case \"text\":\n                            this._emit(\"textDone\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContent, \"f\").text, $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                        case \"image_file\":\n                            this._emit(\"imageFileDone\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContent, \"f\").image_file, $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                    }\n                    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentContentIndex, content.index, \"f\");\n                }\n                $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n            }\n            break;\n        case \"thread.message.completed\":\n        case \"thread.message.incomplete\":\n            //We emit the latest content we were working on on completion (including incomplete)\n            if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                const currentContent = event.data.content[$8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentContentIndex, \"f\")];\n                if (currentContent) switch(currentContent.type){\n                    case \"image_file\":\n                        this._emit(\"imageFileDone\", currentContent.image_file, $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\"));\n                        break;\n                    case \"text\":\n                        this._emit(\"textDone\", currentContent.text, $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\"));\n                        break;\n                }\n            }\n            if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, \"f\")) this._emit(\"messageDone\", event.data);\n            $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_messageSnapshot, undefined, \"f\");\n    }\n}, $8256b977bba312d2$var$_AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n    const accumulatedRunStep = $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_accumulateRunStep).call(this, event);\n    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n    switch(event.event){\n        case \"thread.run.step.created\":\n            this._emit(\"runStepCreated\", event.data);\n            break;\n        case \"thread.run.step.delta\":\n            const delta = event.data.delta;\n            if (delta.step_details && delta.step_details.type == \"tool_calls\" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == \"tool_calls\") {\n                for (const toolCall of delta.step_details.tool_calls)if (toolCall.index == $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCallIndex, \"f\")) this._emit(\"toolCallDelta\", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                else {\n                    if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\")) this._emit(\"toolCallDone\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\"));\n                    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                    if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\")) this._emit(\"toolCallCreated\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\"));\n                }\n            }\n            this._emit(\"runStepDelta\", event.data.delta, accumulatedRunStep);\n            break;\n        case \"thread.run.step.completed\":\n        case \"thread.run.step.failed\":\n        case \"thread.run.step.cancelled\":\n        case \"thread.run.step.expired\":\n            $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n            const details = event.data.step_details;\n            if (details.type == \"tool_calls\") {\n                if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\")) {\n                    this._emit(\"toolCallDone\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\"));\n                    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, undefined, \"f\");\n                }\n            }\n            this._emit(\"runStepDone\", event.data, accumulatedRunStep);\n            break;\n        case \"thread.run.step.in_progress\":\n            break;\n    }\n}, $8256b977bba312d2$var$_AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n    $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_events, \"f\").push(event);\n    this._emit(\"event\", event);\n}, $8256b977bba312d2$var$_AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n    switch(event.event){\n        case \"thread.run.step.created\":\n            $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            return event.data;\n        case \"thread.run.step.delta\":\n            let snapshot = $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n            if (!snapshot) throw Error(\"Received a RunStepDelta before creation of a snapshot\");\n            let data = event.data;\n            if (data.delta) {\n                const accumulated = $8256b977bba312d2$var$AssistantStream.accumulateDelta(snapshot, data.delta);\n                $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n            }\n            return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n        case \"thread.run.step.completed\":\n        case \"thread.run.step.failed\":\n        case \"thread.run.step.cancelled\":\n        case \"thread.run.step.expired\":\n        case \"thread.run.step.in_progress\":\n            $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            break;\n    }\n    if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id]) return $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    throw new Error(\"No snapshot available\");\n}, $8256b977bba312d2$var$_AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n    let newContent = [];\n    switch(event.event){\n        case \"thread.message.created\":\n            //On creation the snapshot is just the initial message\n            return [\n                event.data,\n                newContent\n            ];\n        case \"thread.message.delta\":\n            if (!snapshot) throw Error(\"Received a delta with no existing snapshot (there should be one from message creation)\");\n            let data = event.data;\n            //If this delta does not have content, nothing to process\n            if (data.delta.content) {\n                for (const contentElement of data.delta.content)if (contentElement.index in snapshot.content) {\n                    let currentContent = snapshot.content[contentElement.index];\n                    snapshot.content[contentElement.index] = $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_instances, \"m\", $8256b977bba312d2$var$_AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                } else {\n                    snapshot.content[contentElement.index] = contentElement;\n                    // This is a new element\n                    newContent.push(contentElement);\n                }\n            }\n            return [\n                snapshot,\n                newContent\n            ];\n        case \"thread.message.in_progress\":\n        case \"thread.message.completed\":\n        case \"thread.message.incomplete\":\n            //No changes on other thread events\n            if (snapshot) return [\n                snapshot,\n                newContent\n            ];\n            else throw Error(\"Received thread message event with no existing snapshot\");\n    }\n    throw Error(\"Tried to accumulate a non-message event\");\n}, $8256b977bba312d2$var$_AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n    return $8256b977bba312d2$var$AssistantStream.accumulateDelta(currentContent, contentElement);\n}, $8256b977bba312d2$var$_AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n    $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentRunSnapshot, event.data, \"f\");\n    switch(event.event){\n        case \"thread.run.created\":\n            break;\n        case \"thread.run.queued\":\n            break;\n        case \"thread.run.in_progress\":\n            break;\n        case \"thread.run.requires_action\":\n        case \"thread.run.cancelled\":\n        case \"thread.run.failed\":\n        case \"thread.run.completed\":\n        case \"thread.run.expired\":\n            $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_finalRun, event.data, \"f\");\n            if ($8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\")) {\n                this._emit(\"toolCallDone\", $8256b977bba312d2$var$__classPrivateFieldGet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, \"f\"));\n                $8256b977bba312d2$var$__classPrivateFieldSet(this, $8256b977bba312d2$var$_AssistantStream_currentToolCall, undefined, \"f\");\n            }\n            break;\n        case \"thread.run.cancelling\":\n            break;\n    }\n};\n\n});\n\nparcelRegister(\"gLdvG\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $c33b83ee882b6150$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $c33b83ee882b6150$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $c33b83ee882b6150$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $c33b83ee882b6150$var$__createBinding(result, mod, k);\n    }\n    $c33b83ee882b6150$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.MessagesPage = module.exports.Messages = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $c33b83ee882b6150$var$MessagesAPI = $c33b83ee882b6150$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $c33b83ee882b6150$var$Messages extends $andP1.APIResource {\n    /**\n     * Create a message.\n     */ create(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieve a message.\n     */ retrieve(threadId, messageId, options) {\n        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Modifies a message.\n     */ update(threadId, messageId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(threadId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list(threadId, {}, query);\n        return this._client.getAPIList(`/threads/${threadId}/messages`, $c33b83ee882b6150$var$MessagesPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Deletes a message.\n     */ del(threadId, messageId, options) {\n        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n}\nmodule.exports.Messages = $c33b83ee882b6150$var$Messages;\nclass $c33b83ee882b6150$var$MessagesPage extends $61UiY.CursorPage {\n}\nmodule.exports.MessagesPage = $c33b83ee882b6150$var$MessagesPage;\n(function(Messages) {\n    Messages.MessagesPage = $c33b83ee882b6150$var$MessagesAPI.MessagesPage;\n})($c33b83ee882b6150$var$Messages = module.exports.Messages || (module.exports.Messages = {}));\n\n});\n\nparcelRegister(\"crQct\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $91007f8527922aa3$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $91007f8527922aa3$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $91007f8527922aa3$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $91007f8527922aa3$var$__createBinding(result, mod, k);\n    }\n    $91007f8527922aa3$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.RunsPage = module.exports.Runs = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nvar $bbMZx = parcelRequire(\"bbMZx\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $91007f8527922aa3$var$RunsAPI = $91007f8527922aa3$var$__importStar(module.exports);\n\nconst $91007f8527922aa3$var$StepsAPI = $91007f8527922aa3$var$__importStar((parcelRequire(\"VEYqQ\")));\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $91007f8527922aa3$var$Runs extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.steps = new $91007f8527922aa3$var$StepsAPI.Steps(this._client);\n    }\n    create(threadId, params, options) {\n        const { include: include, ...body } = params;\n        return this._client.post(`/threads/${threadId}/runs`, {\n            query: {\n                include: include\n            },\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            },\n            stream: params.stream ?? false\n        });\n    }\n    /**\n     * Retrieves a run.\n     */ retrieve(threadId, runId, options) {\n        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Modifies a run.\n     */ update(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(threadId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list(threadId, {}, query);\n        return this._client.getAPIList(`/threads/${threadId}/runs`, $91007f8527922aa3$var$RunsPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Cancels a run that is `in_progress`.\n     */ cancel(threadId, runId, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * A helper to create a run an poll for a terminal state. More information on Run\n     * lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */ async createAndPoll(threadId, body, options) {\n        const run = await this.create(threadId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Create a Run stream\n     *\n     * @deprecated use `stream` instead\n     */ createAndStream(threadId, body, options) {\n        return $bbMZx.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    /**\n     * A helper to poll a run status until it reaches a terminal state. More\n     * information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */ async poll(threadId, runId, options) {\n        const headers = {\n            ...options?.headers,\n            \"X-Stainless-Poll-Helper\": \"true\"\n        };\n        if (options?.pollIntervalMs) headers[\"X-Stainless-Custom-Poll-Interval\"] = options.pollIntervalMs.toString();\n        while(true){\n            const { data: run, response: response } = await this.retrieve(threadId, runId, {\n                ...options,\n                headers: {\n                    ...options?.headers,\n                    ...headers\n                }\n            }).withResponse();\n            switch(run.status){\n                //If we are in any sort of intermediate state we poll\n                case \"queued\":\n                case \"in_progress\":\n                case \"cancelling\":\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;\n                    else {\n                        const headerInterval = response.headers.get(\"openai-poll-after-ms\");\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;\n                        }\n                    }\n                    await (0, $9xH07.sleep)(sleepInterval);\n                    break;\n                //We return the run in any terminal state.\n                case \"requires_action\":\n                case \"incomplete\":\n                case \"cancelled\":\n                case \"completed\":\n                case \"failed\":\n                case \"expired\":\n                    return run;\n            }\n        }\n    }\n    /**\n     * Create a Run stream\n     */ stream(threadId, body, options) {\n        return $bbMZx.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    submitToolOutputs(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            },\n            stream: body.stream ?? false\n        });\n    }\n    /**\n     * A helper to submit a tool output to a run and poll for a terminal run state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */ async submitToolOutputsAndPoll(threadId, runId, body, options) {\n        const run = await this.submitToolOutputs(threadId, runId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Submit the tool outputs from a previous run and stream the run to a terminal\n     * state. More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */ submitToolOutputsStream(threadId, runId, body, options) {\n        return $bbMZx.AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n    }\n}\nmodule.exports.Runs = $91007f8527922aa3$var$Runs;\nclass $91007f8527922aa3$var$RunsPage extends $61UiY.CursorPage {\n}\nmodule.exports.RunsPage = $91007f8527922aa3$var$RunsPage;\n(function(Runs) {\n    Runs.RunsPage = $91007f8527922aa3$var$RunsAPI.RunsPage;\n    Runs.Steps = $91007f8527922aa3$var$StepsAPI.Steps;\n    Runs.RunStepsPage = $91007f8527922aa3$var$StepsAPI.RunStepsPage;\n})($91007f8527922aa3$var$Runs = module.exports.Runs || (module.exports.Runs = {}));\n\n});\nparcelRegister(\"VEYqQ\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $0ad51b82eb11d956$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $0ad51b82eb11d956$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $0ad51b82eb11d956$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $0ad51b82eb11d956$var$__createBinding(result, mod, k);\n    }\n    $0ad51b82eb11d956$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.RunStepsPage = module.exports.Steps = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $0ad51b82eb11d956$var$StepsAPI = $0ad51b82eb11d956$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $0ad51b82eb11d956$var$Steps extends $andP1.APIResource {\n    retrieve(threadId, runId, stepId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.retrieve(threadId, runId, stepId, {}, query);\n        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(threadId, runId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list(threadId, runId, {}, query);\n        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, $0ad51b82eb11d956$var$RunStepsPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n}\nmodule.exports.Steps = $0ad51b82eb11d956$var$Steps;\nclass $0ad51b82eb11d956$var$RunStepsPage extends $61UiY.CursorPage {\n}\nmodule.exports.RunStepsPage = $0ad51b82eb11d956$var$RunStepsPage;\n(function(Steps) {\n    Steps.RunStepsPage = $0ad51b82eb11d956$var$StepsAPI.RunStepsPage;\n})($0ad51b82eb11d956$var$Steps = module.exports.Steps || (module.exports.Steps = {}));\n\n});\n\n\n\nparcelRegister(\"eLkc3\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $abf51e7c56408b48$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $abf51e7c56408b48$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $abf51e7c56408b48$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $abf51e7c56408b48$var$__createBinding(result, mod, k);\n    }\n    $abf51e7c56408b48$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.VectorStoresPage = module.exports.VectorStores = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $abf51e7c56408b48$var$VectorStoresAPI = $abf51e7c56408b48$var$__importStar(module.exports);\n\nconst $abf51e7c56408b48$var$FileBatchesAPI = $abf51e7c56408b48$var$__importStar((parcelRequire(\"bd3vo\")));\n\nconst $abf51e7c56408b48$var$FilesAPI = $abf51e7c56408b48$var$__importStar((parcelRequire(\"lGdWS\")));\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $abf51e7c56408b48$var$VectorStores extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.files = new $abf51e7c56408b48$var$FilesAPI.Files(this._client);\n        this.fileBatches = new $abf51e7c56408b48$var$FileBatchesAPI.FileBatches(this._client);\n    }\n    /**\n     * Create a vector store.\n     */ create(body, options) {\n        return this._client.post(\"/vector_stores\", {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieves a vector store.\n     */ retrieve(vectorStoreId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Modifies a vector store.\n     */ update(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list({}, query);\n        return this._client.getAPIList(\"/vector_stores\", $abf51e7c56408b48$var$VectorStoresPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Delete a vector store.\n     */ del(vectorStoreId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n}\nmodule.exports.VectorStores = $abf51e7c56408b48$var$VectorStores;\nclass $abf51e7c56408b48$var$VectorStoresPage extends $61UiY.CursorPage {\n}\nmodule.exports.VectorStoresPage = $abf51e7c56408b48$var$VectorStoresPage;\n(function(VectorStores) {\n    VectorStores.VectorStoresPage = $abf51e7c56408b48$var$VectorStoresAPI.VectorStoresPage;\n    VectorStores.Files = $abf51e7c56408b48$var$FilesAPI.Files;\n    VectorStores.VectorStoreFilesPage = $abf51e7c56408b48$var$FilesAPI.VectorStoreFilesPage;\n    VectorStores.FileBatches = $abf51e7c56408b48$var$FileBatchesAPI.FileBatches;\n})($abf51e7c56408b48$var$VectorStores = module.exports.VectorStores || (module.exports.VectorStores = {}));\n\n});\nparcelRegister(\"bd3vo\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.VectorStoreFilesPage = module.exports.FileBatches = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nvar $l1v1T = parcelRequire(\"l1v1T\");\n\nvar $lGdWS = parcelRequire(\"lGdWS\");\nObject.defineProperty(module.exports, \"VectorStoreFilesPage\", {\n    enumerable: true,\n    get: function() {\n        return $lGdWS.VectorStoreFilesPage;\n    }\n});\nclass $8293a0b364b2ed94$var$FileBatches extends $andP1.APIResource {\n    /**\n     * Create a vector store file batch.\n     */ create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieves a vector store file batch.\n     */ retrieve(vectorStoreId, batchId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Cancel a vector store file batch. This attempts to cancel the processing of\n     * files in this batch as soon as possible.\n     */ cancel(vectorStoreId, batchId, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Create a vector store batch and poll until all files have been processed.\n     */ async createAndPoll(vectorStoreId, body, options) {\n        const batch = await this.create(vectorStoreId, body);\n        return await this.poll(vectorStoreId, batch.id, options);\n    }\n    listFiles(vectorStoreId, batchId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.listFiles(vectorStoreId, batchId, {}, query);\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, $lGdWS.VectorStoreFilesPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Wait for the given file batch to be processed.\n     *\n     * Note: this will return even if one of the files failed to process, you need to\n     * check batch.file_counts.failed_count to handle this case.\n     */ async poll(vectorStoreId, batchId, options) {\n        const headers = {\n            ...options?.headers,\n            \"X-Stainless-Poll-Helper\": \"true\"\n        };\n        if (options?.pollIntervalMs) headers[\"X-Stainless-Custom-Poll-Interval\"] = options.pollIntervalMs.toString();\n        while(true){\n            const { data: batch, response: response } = await this.retrieve(vectorStoreId, batchId, {\n                ...options,\n                headers: headers\n            }).withResponse();\n            switch(batch.status){\n                case \"in_progress\":\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;\n                    else {\n                        const headerInterval = response.headers.get(\"openai-poll-after-ms\");\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;\n                        }\n                    }\n                    await (0, $9xH07.sleep)(sleepInterval);\n                    break;\n                case \"failed\":\n                case \"cancelled\":\n                case \"completed\":\n                    return batch;\n            }\n        }\n    }\n    /**\n     * Uploads the given files concurrently and then creates a vector store file batch.\n     *\n     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n     */ async uploadAndPoll(vectorStoreId, { files: files, fileIds: fileIds = [] }, options) {\n        if (files == null || files.length == 0) throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n        const configuredConcurrency = options?.maxConcurrency ?? 5;\n        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n        const client = this._client;\n        const fileIterator = files.values();\n        const allFileIds = [\n            ...fileIds\n        ];\n        // This code is based on this design. The libraries don't accommodate our environment limits.\n        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n        async function processFiles(iterator) {\n            for (let item of iterator){\n                const fileObj = await client.files.create({\n                    file: item,\n                    purpose: \"assistants\"\n                }, options);\n                allFileIds.push(fileObj.id);\n            }\n        }\n        // Start workers to process results\n        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n        // Wait for all processing to complete.\n        await (0, $l1v1T.allSettledWithThrow)(workers);\n        return await this.createAndPoll(vectorStoreId, {\n            file_ids: allFileIds\n        });\n    }\n}\nmodule.exports.FileBatches = $8293a0b364b2ed94$var$FileBatches;\n$8293a0b364b2ed94$var$FileBatches = module.exports.FileBatches || (module.exports.FileBatches = {});\n\n});\nparcelRegister(\"l1v1T\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.allSettledWithThrow = void 0;\n/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */ const $f4e1c2cf3a635e16$var$allSettledWithThrow = async (promises)=>{\n    const results = await Promise.allSettled(promises);\n    const rejected = results.filter((result)=>result.status === \"rejected\");\n    if (rejected.length) {\n        for (const result of rejected)console.error(result.reason);\n        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n    }\n    // Note: TS was complaining about using `.filter().map()` here for some reason\n    const values = [];\n    for (const result of results)if (result.status === \"fulfilled\") values.push(result.value);\n    return values;\n};\nmodule.exports.allSettledWithThrow = $f4e1c2cf3a635e16$var$allSettledWithThrow;\n\n});\n\nparcelRegister(\"lGdWS\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $fc885726193f9a8d$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $fc885726193f9a8d$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $fc885726193f9a8d$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $fc885726193f9a8d$var$__createBinding(result, mod, k);\n    }\n    $fc885726193f9a8d$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.VectorStoreFilesPage = module.exports.Files = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $fc885726193f9a8d$var$FilesAPI = $fc885726193f9a8d$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $fc885726193f9a8d$var$Files extends $andP1.APIResource {\n    /**\n     * Create a vector store file by attaching a\n     * [File](https://platform.openai.com/docs/api-reference/files) to a\n     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n     */ create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n            body: body,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Retrieves a vector store file.\n     */ retrieve(vectorStoreId, fileId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    list(vectorStoreId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list(vectorStoreId, {}, query);\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, $fc885726193f9a8d$var$VectorStoreFilesPage, {\n            query: query,\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Delete a vector store file. This will remove the file from the vector store but\n     * the file itself will not be deleted. To delete the file, use the\n     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n     * endpoint.\n     */ del(vectorStoreId, fileId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: {\n                \"OpenAI-Beta\": \"assistants=v2\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Attach a file to the given vector store and wait for it to be processed.\n     */ async createAndPoll(vectorStoreId, body, options) {\n        const file = await this.create(vectorStoreId, body, options);\n        return await this.poll(vectorStoreId, file.id, options);\n    }\n    /**\n     * Wait for the vector store file to finish processing.\n     *\n     * Note: this will return even if the file failed to process, you need to check\n     * file.last_error and file.status to handle these cases\n     */ async poll(vectorStoreId, fileId, options) {\n        const headers = {\n            ...options?.headers,\n            \"X-Stainless-Poll-Helper\": \"true\"\n        };\n        if (options?.pollIntervalMs) headers[\"X-Stainless-Custom-Poll-Interval\"] = options.pollIntervalMs.toString();\n        while(true){\n            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n                ...options,\n                headers: headers\n            }).withResponse();\n            const file = fileResponse.data;\n            switch(file.status){\n                case \"in_progress\":\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) sleepInterval = options.pollIntervalMs;\n                    else {\n                        const headerInterval = fileResponse.response.headers.get(\"openai-poll-after-ms\");\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) sleepInterval = headerIntervalMs;\n                        }\n                    }\n                    await (0, $9xH07.sleep)(sleepInterval);\n                    break;\n                case \"failed\":\n                case \"completed\":\n                    return file;\n            }\n        }\n    }\n    /**\n     * Upload a file to the `files` API and then attach it to the given vector store.\n     *\n     * Note the file will be asynchronously processed (you can use the alternative\n     * polling helper method to wait for processing to complete).\n     */ async upload(vectorStoreId, file, options) {\n        const fileInfo = await this._client.files.create({\n            file: file,\n            purpose: \"assistants\"\n        }, options);\n        return this.create(vectorStoreId, {\n            file_id: fileInfo.id\n        }, options);\n    }\n    /**\n     * Add a file to a vector store and poll until processing is complete.\n     */ async uploadAndPoll(vectorStoreId, file, options) {\n        const fileInfo = await this.upload(vectorStoreId, file, options);\n        return await this.poll(vectorStoreId, fileInfo.id, options);\n    }\n}\nmodule.exports.Files = $fc885726193f9a8d$var$Files;\nclass $fc885726193f9a8d$var$VectorStoreFilesPage extends $61UiY.CursorPage {\n}\nmodule.exports.VectorStoreFilesPage = $fc885726193f9a8d$var$VectorStoreFilesPage;\n(function(Files) {\n    Files.VectorStoreFilesPage = $fc885726193f9a8d$var$FilesAPI.VectorStoreFilesPage;\n})($fc885726193f9a8d$var$Files = module.exports.Files || (module.exports.Files = {}));\n\n});\n\n\n\n\nparcelRegister(\"kSU3b\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Completions = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\nclass $f344543d16f2a799$var$Completions extends $andP1.APIResource {\n    create(body, options) {\n        return this._client.post(\"/completions\", {\n            body: body,\n            ...options,\n            stream: body.stream ?? false\n        });\n    }\n}\nmodule.exports.Completions = $f344543d16f2a799$var$Completions;\n$f344543d16f2a799$var$Completions = module.exports.Completions || (module.exports.Completions = {});\n\n});\n\nparcelRegister(\"fowbp\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Embeddings = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\nclass $b3520fc5ae7a5eb7$var$Embeddings extends $andP1.APIResource {\n    /**\n     * Creates an embedding vector representing the input text.\n     */ create(body, options) {\n        return this._client.post(\"/embeddings\", {\n            body: body,\n            ...options\n        });\n    }\n}\nmodule.exports.Embeddings = $b3520fc5ae7a5eb7$var$Embeddings;\n$b3520fc5ae7a5eb7$var$Embeddings = module.exports.Embeddings || (module.exports.Embeddings = {});\n\n});\n\nparcelRegister(\"beenb\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $82cc26a881878841$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $82cc26a881878841$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $82cc26a881878841$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $82cc26a881878841$var$__createBinding(result, mod, k);\n    }\n    $82cc26a881878841$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.FileObjectsPage = module.exports.Files = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\n\n\nvar $hTt11 = parcelRequire(\"hTt11\");\n\nconst $82cc26a881878841$var$Core = $82cc26a881878841$var$__importStar((parcelRequire(\"9xH07\")));\n\nconst $82cc26a881878841$var$FilesAPI = $82cc26a881878841$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $82cc26a881878841$var$Files extends $andP1.APIResource {\n    /**\n     * Upload a file that can be used across various endpoints. Individual files can be\n     * up to 512 MB, and the size of all files uploaded by one organization can be up\n     * to 100 GB.\n     *\n     * The Assistants API supports files up to 2 million tokens and of specific file\n     * types. See the\n     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n     * details.\n     *\n     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n     * required formats for fine-tuning\n     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n     * models.\n     *\n     * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\n     * has a specific required\n     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n     *\n     * Please [contact us](https://help.openai.com/) if you need to increase these\n     * storage limits.\n     */ create(body, options) {\n        return this._client.post(\"/files\", $82cc26a881878841$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n    /**\n     * Returns information about a specific file.\n     */ retrieve(fileId, options) {\n        return this._client.get(`/files/${fileId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, (parcelRequire(\"9xH07\")).isRequestOptions)(query)) return this.list({}, query);\n        return this._client.getAPIList(\"/files\", $82cc26a881878841$var$FileObjectsPage, {\n            query: query,\n            ...options\n        });\n    }\n    /**\n     * Delete a file.\n     */ del(fileId, options) {\n        return this._client.delete(`/files/${fileId}`, options);\n    }\n    /**\n     * Returns the contents of the specified file.\n     */ content(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            __binaryResponse: true\n        });\n    }\n    /**\n     * Returns the contents of the specified file.\n     *\n     * @deprecated The `.content()` method should be used instead\n     */ retrieveContent(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            headers: {\n                Accept: \"application/json\",\n                ...options?.headers\n            }\n        });\n    }\n    /**\n     * Waits for the given file to be processed, default timeout is 30 mins.\n     */ async waitForProcessing(id, { pollInterval: pollInterval = 5000, maxWait: maxWait = 1800000 } = {}) {\n        const TERMINAL_STATES = new Set([\n            \"processed\",\n            \"error\",\n            \"deleted\"\n        ]);\n        const start = Date.now();\n        let file = await this.retrieve(id);\n        while(!file.status || !TERMINAL_STATES.has(file.status)){\n            await (0, (parcelRequire(\"9xH07\")).sleep)(pollInterval);\n            file = await this.retrieve(id);\n            if (Date.now() - start > maxWait) throw new $hTt11.APIConnectionTimeoutError({\n                message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`\n            });\n        }\n        return file;\n    }\n}\nmodule.exports.Files = $82cc26a881878841$var$Files;\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */ class $82cc26a881878841$var$FileObjectsPage extends $61UiY.Page {\n}\nmodule.exports.FileObjectsPage = $82cc26a881878841$var$FileObjectsPage;\n(function(Files) {\n    Files.FileObjectsPage = $82cc26a881878841$var$FilesAPI.FileObjectsPage;\n})($82cc26a881878841$var$Files = module.exports.Files || (module.exports.Files = {}));\n\n});\n\nparcelRegister(\"aDo8r\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $7be0449f6c209c8e$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $7be0449f6c209c8e$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $7be0449f6c209c8e$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $7be0449f6c209c8e$var$__createBinding(result, mod, k);\n    }\n    $7be0449f6c209c8e$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.FineTuning = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $7be0449f6c209c8e$var$JobsAPI = $7be0449f6c209c8e$var$__importStar((parcelRequire(\"0N4eF\")));\nclass $7be0449f6c209c8e$var$FineTuning extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.jobs = new $7be0449f6c209c8e$var$JobsAPI.Jobs(this._client);\n    }\n}\nmodule.exports.FineTuning = $7be0449f6c209c8e$var$FineTuning;\n(function(FineTuning) {\n    FineTuning.Jobs = $7be0449f6c209c8e$var$JobsAPI.Jobs;\n    FineTuning.FineTuningJobsPage = $7be0449f6c209c8e$var$JobsAPI.FineTuningJobsPage;\n    FineTuning.FineTuningJobEventsPage = $7be0449f6c209c8e$var$JobsAPI.FineTuningJobEventsPage;\n})($7be0449f6c209c8e$var$FineTuning = module.exports.FineTuning || (module.exports.FineTuning = {}));\n\n});\nparcelRegister(\"0N4eF\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $00260ff2d618b7cf$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $00260ff2d618b7cf$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $00260ff2d618b7cf$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $00260ff2d618b7cf$var$__createBinding(result, mod, k);\n    }\n    $00260ff2d618b7cf$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.FineTuningJobEventsPage = module.exports.FineTuningJobsPage = module.exports.Jobs = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $00260ff2d618b7cf$var$JobsAPI = $00260ff2d618b7cf$var$__importStar(module.exports);\n\nconst $00260ff2d618b7cf$var$CheckpointsAPI = $00260ff2d618b7cf$var$__importStar((parcelRequire(\"73mL1\")));\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $00260ff2d618b7cf$var$Jobs extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.checkpoints = new $00260ff2d618b7cf$var$CheckpointsAPI.Checkpoints(this._client);\n    }\n    /**\n     * Creates a fine-tuning job which begins the process of creating a new model from\n     * a given dataset.\n     *\n     * Response includes details of the enqueued job including job status and the name\n     * of the fine-tuned models once complete.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */ create(body, options) {\n        return this._client.post(\"/fine_tuning/jobs\", {\n            body: body,\n            ...options\n        });\n    }\n    /**\n     * Get info about a fine-tuning job.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */ retrieve(fineTuningJobId, options) {\n        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list({}, query);\n        return this._client.getAPIList(\"/fine_tuning/jobs\", $00260ff2d618b7cf$var$FineTuningJobsPage, {\n            query: query,\n            ...options\n        });\n    }\n    /**\n     * Immediately cancel a fine-tune job.\n     */ cancel(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n    }\n    listEvents(fineTuningJobId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.listEvents(fineTuningJobId, {}, query);\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, $00260ff2d618b7cf$var$FineTuningJobEventsPage, {\n            query: query,\n            ...options\n        });\n    }\n}\nmodule.exports.Jobs = $00260ff2d618b7cf$var$Jobs;\nclass $00260ff2d618b7cf$var$FineTuningJobsPage extends $61UiY.CursorPage {\n}\nmodule.exports.FineTuningJobsPage = $00260ff2d618b7cf$var$FineTuningJobsPage;\nclass $00260ff2d618b7cf$var$FineTuningJobEventsPage extends $61UiY.CursorPage {\n}\nmodule.exports.FineTuningJobEventsPage = $00260ff2d618b7cf$var$FineTuningJobEventsPage;\n(function(Jobs) {\n    Jobs.FineTuningJobsPage = $00260ff2d618b7cf$var$JobsAPI.FineTuningJobsPage;\n    Jobs.FineTuningJobEventsPage = $00260ff2d618b7cf$var$JobsAPI.FineTuningJobEventsPage;\n    Jobs.Checkpoints = $00260ff2d618b7cf$var$CheckpointsAPI.Checkpoints;\n    Jobs.FineTuningJobCheckpointsPage = $00260ff2d618b7cf$var$CheckpointsAPI.FineTuningJobCheckpointsPage;\n})($00260ff2d618b7cf$var$Jobs = module.exports.Jobs || (module.exports.Jobs = {}));\n\n});\nparcelRegister(\"73mL1\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $522a77619cda4c6e$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $522a77619cda4c6e$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $522a77619cda4c6e$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $522a77619cda4c6e$var$__createBinding(result, mod, k);\n    }\n    $522a77619cda4c6e$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.FineTuningJobCheckpointsPage = module.exports.Checkpoints = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nvar $9xH07 = parcelRequire(\"9xH07\");\n\nconst $522a77619cda4c6e$var$CheckpointsAPI = $522a77619cda4c6e$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $522a77619cda4c6e$var$Checkpoints extends $andP1.APIResource {\n    list(fineTuningJobId, query = {}, options) {\n        if ((0, $9xH07.isRequestOptions)(query)) return this.list(fineTuningJobId, {}, query);\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, $522a77619cda4c6e$var$FineTuningJobCheckpointsPage, {\n            query: query,\n            ...options\n        });\n    }\n}\nmodule.exports.Checkpoints = $522a77619cda4c6e$var$Checkpoints;\nclass $522a77619cda4c6e$var$FineTuningJobCheckpointsPage extends $61UiY.CursorPage {\n}\nmodule.exports.FineTuningJobCheckpointsPage = $522a77619cda4c6e$var$FineTuningJobCheckpointsPage;\n(function(Checkpoints) {\n    Checkpoints.FineTuningJobCheckpointsPage = $522a77619cda4c6e$var$CheckpointsAPI.FineTuningJobCheckpointsPage;\n})($522a77619cda4c6e$var$Checkpoints = module.exports.Checkpoints || (module.exports.Checkpoints = {}));\n\n});\n\n\n\nparcelRegister(\"8tzbZ\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $62bc54a5a5a16142$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $62bc54a5a5a16142$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $62bc54a5a5a16142$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $62bc54a5a5a16142$var$__createBinding(result, mod, k);\n    }\n    $62bc54a5a5a16142$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Images = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $62bc54a5a5a16142$var$Core = $62bc54a5a5a16142$var$__importStar((parcelRequire(\"9xH07\")));\nclass $62bc54a5a5a16142$var$Images extends $andP1.APIResource {\n    /**\n     * Creates a variation of a given image.\n     */ createVariation(body, options) {\n        return this._client.post(\"/images/variations\", $62bc54a5a5a16142$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n    /**\n     * Creates an edited or extended image given an original image and a prompt.\n     */ edit(body, options) {\n        return this._client.post(\"/images/edits\", $62bc54a5a5a16142$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n    /**\n     * Creates an image given a prompt.\n     */ generate(body, options) {\n        return this._client.post(\"/images/generations\", {\n            body: body,\n            ...options\n        });\n    }\n}\nmodule.exports.Images = $62bc54a5a5a16142$var$Images;\n$62bc54a5a5a16142$var$Images = module.exports.Images || (module.exports.Images = {});\n\n});\n\nparcelRegister(\"aROqG\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $7e95f8de20eb6a16$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $7e95f8de20eb6a16$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $7e95f8de20eb6a16$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $7e95f8de20eb6a16$var$__createBinding(result, mod, k);\n    }\n    $7e95f8de20eb6a16$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ModelsPage = module.exports.Models = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $7e95f8de20eb6a16$var$ModelsAPI = $7e95f8de20eb6a16$var$__importStar(module.exports);\n\nvar $61UiY = parcelRequire(\"61UiY\");\nclass $7e95f8de20eb6a16$var$Models extends $andP1.APIResource {\n    /**\n     * Retrieves a model instance, providing basic information about the model such as\n     * the owner and permissioning.\n     */ retrieve(model, options) {\n        return this._client.get(`/models/${model}`, options);\n    }\n    /**\n     * Lists the currently available models, and provides basic information about each\n     * one such as the owner and availability.\n     */ list(options) {\n        return this._client.getAPIList(\"/models\", $7e95f8de20eb6a16$var$ModelsPage, options);\n    }\n    /**\n     * Delete a fine-tuned model. You must have the Owner role in your organization to\n     * delete a model.\n     */ del(model, options) {\n        return this._client.delete(`/models/${model}`, options);\n    }\n}\nmodule.exports.Models = $7e95f8de20eb6a16$var$Models;\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */ class $7e95f8de20eb6a16$var$ModelsPage extends $61UiY.Page {\n}\nmodule.exports.ModelsPage = $7e95f8de20eb6a16$var$ModelsPage;\n(function(Models) {\n    Models.ModelsPage = $7e95f8de20eb6a16$var$ModelsAPI.ModelsPage;\n})($7e95f8de20eb6a16$var$Models = module.exports.Models || (module.exports.Models = {}));\n\n});\n\nparcelRegister(\"iSJzc\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Moderations = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\nclass $dbf09dc36a05d37e$var$Moderations extends $andP1.APIResource {\n    /**\n     * Classifies if text and/or image inputs are potentially harmful. Learn more in\n     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n     */ create(body, options) {\n        return this._client.post(\"/moderations\", {\n            body: body,\n            ...options\n        });\n    }\n}\nmodule.exports.Moderations = $dbf09dc36a05d37e$var$Moderations;\n$dbf09dc36a05d37e$var$Moderations = module.exports.Moderations || (module.exports.Moderations = {});\n\n});\n\nparcelRegister(\"eAdos\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $a9ded12b19f645b4$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $a9ded12b19f645b4$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $a9ded12b19f645b4$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $a9ded12b19f645b4$var$__createBinding(result, mod, k);\n    }\n    $a9ded12b19f645b4$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Uploads = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $a9ded12b19f645b4$var$PartsAPI = $a9ded12b19f645b4$var$__importStar((parcelRequire(\"wfTl4\")));\nclass $a9ded12b19f645b4$var$Uploads extends $andP1.APIResource {\n    constructor(){\n        super(...arguments);\n        this.parts = new $a9ded12b19f645b4$var$PartsAPI.Parts(this._client);\n    }\n    /**\n     * Creates an intermediate\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n     * that you can add\n     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n     * after you create it.\n     *\n     * Once you complete the Upload, we will create a\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * contains all the parts you uploaded. This File is usable in the rest of our\n     * platform as a regular File object.\n     *\n     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer\n     * to documentation for the supported MIME types for your use case:\n     *\n     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)\n     *\n     * For guidance on the proper filename extensions for each purpose, please follow\n     * the documentation on\n     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n     */ create(body, options) {\n        return this._client.post(\"/uploads\", {\n            body: body,\n            ...options\n        });\n    }\n    /**\n     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n     */ cancel(uploadId, options) {\n        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n    }\n    /**\n     * Completes the\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n     *\n     * Within the returned Upload object, there is a nested\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * is ready to use in the rest of the platform.\n     *\n     * You can specify the order of the Parts by passing in an ordered list of the Part\n     * IDs.\n     *\n     * The number of bytes uploaded upon completion must match the number of bytes\n     * initially specified when creating the Upload object. No Parts may be added after\n     * an Upload is completed.\n     */ complete(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/complete`, {\n            body: body,\n            ...options\n        });\n    }\n}\nmodule.exports.Uploads = $a9ded12b19f645b4$var$Uploads;\n(function(Uploads) {\n    Uploads.Parts = $a9ded12b19f645b4$var$PartsAPI.Parts;\n})($a9ded12b19f645b4$var$Uploads = module.exports.Uploads || (module.exports.Uploads = {}));\n\n});\nparcelRegister(\"wfTl4\", function(module, exports) {\n\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar $060f5101d7f064a7$var$__createBinding = module.exports && module.exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar $060f5101d7f064a7$var$__setModuleDefault = module.exports && module.exports.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar $060f5101d7f064a7$var$__importStar = module.exports && module.exports.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $060f5101d7f064a7$var$__createBinding(result, mod, k);\n    }\n    $060f5101d7f064a7$var$__setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Parts = void 0;\n\nvar $andP1 = parcelRequire(\"andP1\");\n\nconst $060f5101d7f064a7$var$Core = $060f5101d7f064a7$var$__importStar((parcelRequire(\"9xH07\")));\nclass $060f5101d7f064a7$var$Parts extends $andP1.APIResource {\n    /**\n     * Adds a\n     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n     * A Part represents a chunk of bytes from the file you are trying to upload.\n     *\n     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n     * maximum of 8 GB.\n     *\n     * It is possible to add multiple Parts in parallel. You can decide the intended\n     * order of the Parts when you\n     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n     */ create(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/parts`, $060f5101d7f064a7$var$Core.multipartFormRequestOptions({\n            body: body,\n            ...options\n        }));\n    }\n}\nmodule.exports.Parts = $060f5101d7f064a7$var$Parts;\n$060f5101d7f064a7$var$Parts = module.exports.Parts || (module.exports.Parts = {});\n\n});\n\n\n\n\n\nvar $cM6Z0 = parcelRequire(\"cM6Z0\");\n\"use strict\";\nasync function $79440f4aa71907b8$export$848feb93d8f32b9b(messages, apiKey) {\n    const openai = new (0, $cM6Z0.OpenAI)({\n        apiKey: apiKey,\n        dangerouslyAllowBrowser: true\n    });\n    const completion = await openai.chat.completions.create({\n        model: \"gpt-4o-mini\",\n        messages: messages\n    });\n    return completion.choices[0].message.content;\n}\nasync function $79440f4aa71907b8$export$49af0b5dadf7ec11(query, apiKey) {\n    const messages = [\n        {\n            role: \"user\",\n            content: \"Give me a plain text JSON with a simple  English sentence featuring this word. Also tell me the target language with this code. Obey all notes.\"\n        },\n        {\n            role: \"user\",\n            content: '{\"languageCode\": \"zh\", \"word\": \"fruit\", \"difficulty\": \"beginner\", \"notes\": \"ask a question\"}'\n        },\n        {\n            role: \"assistant\",\n            content: '{\"targetLanguage\": \"Chinese\", \"en\": \"What is your favorite fruit to eat?\"}'\n        },\n        {\n            role: \"user\",\n            content: JSON.stringify(query)\n        }\n    ];\n    return await $79440f4aa71907b8$export$848feb93d8f32b9b(messages, apiKey);\n}\nasync function $79440f4aa71907b8$export$9d45e7b0edf3c455(query, apiKey) {\n    const messages = [\n        {\n            role: \"user\",\n            content: \"Give a JSON with my translation attempt and corrections on my attempt. If my attempt is perfect, leave the corrections array empty. Include transliterations if applicable.\"\n        },\n        {\n            role: \"user\",\n            content: '{\"targetLanguage\": \"zh\", \"originalSentence\": \"This dog has brown fur.\", \"attempt\": \"\\u8FD9\\u4E2A\\u72D7\\u6709\\u68D5\\u8272\\u6BDB\\u53D1\"}'\n        },\n        {\n            role: \"assistant\",\n            content: `{\"attempt\": \"\\u{8FD9}\\u{4E2A}\\u{72D7}\\u{6709}\\u{68D5}\\u{8272}\\u{6BDB}\\u{53D1} (zh\\xe8ge g\\u{1D2}u y\\u{1D2}u z\\u{14D}ngs\\xe8 m\\xe1of\\xe0)\", \"correctedAttempt\": \"\\u{8FD9}\\u{53EA}\\u{72D7}\\u{6709}\\u{68D5}\\u{8272}\\u{7684}\\u{6BDB}\\u{53D1}\\u{3002}(zh\\xe8zh\\u{12B} g\\u{1D2}u y\\u{1D2}u z\\u{14D}ngs\\xe8de m\\xe1of\\xe0.)\", \"corrections\": [\"Use \\\\\"\\u{53EA} (zh\\u{12B})\\\\\" instead of \\\\\"\\u{4E2A} (ge)\\\\\" because \\\\\"\\u{53EA}\\\\\" is the measure word for animals.\", \"Insert \\\\\"\\u{7684} (de)\\\\\" into \\\\\"\\u{68D5}\\u{8272}\\u{7684}\\u{6BDB}\\u{53D1} (z\\u{14D}ngs\\xe8de m\\xe1of\\xe0)\\\\\" to connect the adjective to the noun.]}`\n        },\n        {\n            role: \"user\",\n            content: JSON.stringify(query)\n        }\n    ];\n    return await $79440f4aa71907b8$export$848feb93d8f32b9b(messages, apiKey);\n}\n\n\n\"use strict\";\n//setup\nconst $c1ce9d969bfa6909$var$debug = true;\nlet $c1ce9d969bfa6909$var$wordNum = 0;\n//event listeners\ndocument.querySelector(\"#enter-words\").addEventListener(\"click\", $c1ce9d969bfa6909$var$enterWord);\ndocument.querySelector(\"#enter-attempt\").addEventListener(\"click\", $c1ce9d969bfa6909$var$checkAttempt);\ndocument.querySelector(\"#clear-words\").addEventListener(\"click\", $c1ce9d969bfa6909$var$clearWords);\n//main functions\n//generates a new prompt\nasync function $c1ce9d969bfa6909$var$enterWord() {\n    //edge case: words contains only whitespace\n    if (document.querySelector(\"#words\").value.trim().length === 0) {\n        console.log(\"Cannot get sentence: words is empty\");\n        return;\n    }\n    //debug messages\n    if ($c1ce9d969bfa6909$var$debug) {\n        $c1ce9d969bfa6909$var$wordNum++;\n        console.log(\"\\n\\nWord #\" + $c1ce9d969bfa6909$var$wordNum);\n    }\n    //input\n    const apiKey = document.querySelector(\"#api-key\").value;\n    const languageCode = document.querySelector(\"#language-code\").value;\n    if (document.querySelector(\"#words\").value.length < 6 || document.querySelector(\"#words\").value.slice(0, 6) !== \"\\n\\n\\n\\n\\n\\n\") document.querySelector(\"#words\").value = \"\\n\\n\\n\\n\\n\\n\" + document.querySelector(\"#words\").value;\n    const words = document.querySelector(\"#words\").value.split(\"\\n\");\n    let word = words[Math.floor(Math.random() * words.length)];\n    while(word === \"\")word = words[Math.floor(Math.random() * words.length)];\n    const notes = document.querySelector(\"#notes\").value;\n    const query = {\n        languageCode: languageCode,\n        word: word,\n        notes: notes\n    };\n    //output\n    const response = JSON.parse(await (0, $79440f4aa71907b8$export$49af0b5dadf7ec11)(query, apiKey));\n    document.querySelector(\"#en\").textContent = response.en;\n    document.querySelector(\"#target-label\").textContent = response.targetLanguage;\n    //debug messages\n    if ($c1ce9d969bfa6909$var$debug) {\n        console.log(`script.js sent:`);\n        console.log(query);\n        console.log(\"script.js received:\");\n        console.log(response);\n    }\n}\n//grades attempt\nasync function $c1ce9d969bfa6909$var$checkAttempt() {\n    //debug messages\n    if ($c1ce9d969bfa6909$var$debug) console.log(\"\\n\\nAttempt #\" + $c1ce9d969bfa6909$var$wordNum);\n    //input\n    const apiKey = document.querySelector(\"#api-key\").value;\n    const targetLanguage = document.querySelector(\"#language-code\").value;\n    const originalSentence = document.querySelector(\"#en\").textContent;\n    const attempt = document.querySelector(\"#attempt-input\").value;\n    document.querySelector(\"#attempt-input\").value = \"\";\n    const query = {\n        targetLanguage: targetLanguage,\n        originalSentence: originalSentence,\n        attempt: attempt\n    };\n    //output\n    const response = JSON.parse(await (0, $79440f4aa71907b8$export$9d45e7b0edf3c455)(query, apiKey));\n    document.querySelector(\"#attempt-display\").textContent = response.attempt;\n    document.querySelector(\"#corrected-attempt-display\").textContent = response.correctedAttempt;\n    let correctionsStr = \"\";\n    for ([i, correction] of response.corrections.entries())correctionsStr += `${i + 1}. ${correction}\\n\\n`;\n    document.querySelector(\"#corrections-display\").textContent = correctionsStr;\n    //debug messages\n    if ($c1ce9d969bfa6909$var$debug) {\n        console.log(\"script.js sent: \");\n        console.log(query);\n        console.log(\"script.js received: \");\n        console.log(response);\n    }\n}\n//clears words in the textarea\nfunction $c1ce9d969bfa6909$var$clearWords() {\n    document.querySelector(\"#words\").value = \"\";\n}\n\n\n//# sourceMappingURL=index.aed3a654.js.map\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AzureOpenAI = exports.fileFromPath = exports.toFile = exports.UnprocessableEntityError = exports.PermissionDeniedError = exports.InternalServerError = exports.AuthenticationError = exports.BadRequestError = exports.RateLimitError = exports.ConflictError = exports.NotFoundError = exports.APIUserAbortError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIError = exports.OpenAIError = exports.OpenAI = void 0;\nconst Errors = __importStar(require(\"./error.js\"));\nconst Uploads = __importStar(require(\"./uploads.js\"));\nconst qs = __importStar(require(\"./internal/qs/index.js\"));\nconst Core = __importStar(require(\"./core.js\"));\nconst Pagination = __importStar(require(\"./pagination.js\"));\nconst API = __importStar(require(\"./resources/index.js\"));\n/**\n * API Client for interfacing with the OpenAI API.\n */\nclass OpenAI extends Core.APIClient {\n    /**\n     * API Client for interfacing with the OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('OPENAI_API_KEY'), organization = Core.readEnv('OPENAI_ORG_ID') ?? null, project = Core.readEnv('OPENAI_PROJECT_ID') ?? null, ...opts } = {}) {\n        if (apiKey === undefined) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n        }\n        const options = {\n            apiKey,\n            organization,\n            project,\n            ...opts,\n            baseURL: baseURL || `https://api.openai.com/v1`,\n        };\n        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n            throw new Errors.OpenAIError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\");\n        }\n        super({\n            baseURL: options.baseURL,\n            timeout: options.timeout ?? 600000 /* 10 minutes */,\n            httpAgent: options.httpAgent,\n            maxRetries: options.maxRetries,\n            fetch: options.fetch,\n        });\n        this.completions = new API.Completions(this);\n        this.chat = new API.Chat(this);\n        this.embeddings = new API.Embeddings(this);\n        this.files = new API.Files(this);\n        this.images = new API.Images(this);\n        this.audio = new API.Audio(this);\n        this.moderations = new API.Moderations(this);\n        this.models = new API.Models(this);\n        this.fineTuning = new API.FineTuning(this);\n        this.beta = new API.Beta(this);\n        this.batches = new API.Batches(this);\n        this.uploads = new API.Uploads(this);\n        this._options = options;\n        this.apiKey = apiKey;\n        this.organization = organization;\n        this.project = project;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    defaultHeaders(opts) {\n        return {\n            ...super.defaultHeaders(opts),\n            'OpenAI-Organization': this.organization,\n            'OpenAI-Project': this.project,\n            ...this._options.defaultHeaders,\n        };\n    }\n    authHeaders(opts) {\n        return { Authorization: `Bearer ${this.apiKey}` };\n    }\n    stringifyQuery(query) {\n        return qs.stringify(query, { arrayFormat: 'brackets' });\n    }\n}\nexports.OpenAI = OpenAI;\n_a = OpenAI;\nOpenAI.OpenAI = _a;\nOpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes\nOpenAI.OpenAIError = Errors.OpenAIError;\nOpenAI.APIError = Errors.APIError;\nOpenAI.APIConnectionError = Errors.APIConnectionError;\nOpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\nOpenAI.APIUserAbortError = Errors.APIUserAbortError;\nOpenAI.NotFoundError = Errors.NotFoundError;\nOpenAI.ConflictError = Errors.ConflictError;\nOpenAI.RateLimitError = Errors.RateLimitError;\nOpenAI.BadRequestError = Errors.BadRequestError;\nOpenAI.AuthenticationError = Errors.AuthenticationError;\nOpenAI.InternalServerError = Errors.InternalServerError;\nOpenAI.PermissionDeniedError = Errors.PermissionDeniedError;\nOpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;\nOpenAI.toFile = Uploads.toFile;\nOpenAI.fileFromPath = Uploads.fileFromPath;\nexports.OpenAIError = Errors.OpenAIError, exports.APIError = Errors.APIError, exports.APIConnectionError = Errors.APIConnectionError, exports.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError, exports.APIUserAbortError = Errors.APIUserAbortError, exports.NotFoundError = Errors.NotFoundError, exports.ConflictError = Errors.ConflictError, exports.RateLimitError = Errors.RateLimitError, exports.BadRequestError = Errors.BadRequestError, exports.AuthenticationError = Errors.AuthenticationError, exports.InternalServerError = Errors.InternalServerError, exports.PermissionDeniedError = Errors.PermissionDeniedError, exports.UnprocessableEntityError = Errors.UnprocessableEntityError;\nexports.toFile = Uploads.toFile;\nexports.fileFromPath = Uploads.fileFromPath;\n(function (OpenAI) {\n    OpenAI.Page = Pagination.Page;\n    OpenAI.CursorPage = Pagination.CursorPage;\n    OpenAI.Completions = API.Completions;\n    OpenAI.Chat = API.Chat;\n    OpenAI.Embeddings = API.Embeddings;\n    OpenAI.Files = API.Files;\n    OpenAI.FileObjectsPage = API.FileObjectsPage;\n    OpenAI.Images = API.Images;\n    OpenAI.Audio = API.Audio;\n    OpenAI.Moderations = API.Moderations;\n    OpenAI.Models = API.Models;\n    OpenAI.ModelsPage = API.ModelsPage;\n    OpenAI.FineTuning = API.FineTuning;\n    OpenAI.Beta = API.Beta;\n    OpenAI.Batches = API.Batches;\n    OpenAI.BatchesPage = API.BatchesPage;\n    OpenAI.Uploads = API.Uploads;\n})(OpenAI = exports.OpenAI || (exports.OpenAI = {}));\n/** API Client for interfacing with the Azure OpenAI API. */\nclass AzureOpenAI extends OpenAI {\n    /**\n     * API Client for interfacing with the Azure OpenAI API.\n     *\n     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'), apiVersion = Core.readEnv('OPENAI_API_VERSION'), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {\n        if (!apiVersion) {\n            throw new Errors.OpenAIError(\"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\");\n        }\n        if (typeof azureADTokenProvider === 'function') {\n            dangerouslyAllowBrowser = true;\n        }\n        if (!azureADTokenProvider && !apiKey) {\n            throw new Errors.OpenAIError('Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.');\n        }\n        if (azureADTokenProvider && apiKey) {\n            throw new Errors.OpenAIError('The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.');\n        }\n        // define a sentinel value to avoid any typing issues\n        apiKey ?? (apiKey = API_KEY_SENTINEL);\n        opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };\n        if (!baseURL) {\n            if (!endpoint) {\n                endpoint = process.env['AZURE_OPENAI_ENDPOINT'];\n            }\n            if (!endpoint) {\n                throw new Errors.OpenAIError('Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable');\n            }\n            baseURL = `${endpoint}/openai`;\n        }\n        else {\n            if (endpoint) {\n                throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');\n            }\n        }\n        super({\n            apiKey,\n            baseURL,\n            ...opts,\n            ...(dangerouslyAllowBrowser !== undefined ? { dangerouslyAllowBrowser } : {}),\n        });\n        this.apiVersion = '';\n        this._azureADTokenProvider = azureADTokenProvider;\n        this.apiVersion = apiVersion;\n        this._deployment = deployment;\n    }\n    buildRequest(options) {\n        if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {\n            if (!Core.isObj(options.body)) {\n                throw new Error('Expected request body to be an object');\n            }\n            const model = this._deployment || options.body['model'];\n            if (model !== undefined && !this.baseURL.includes('/deployments')) {\n                options.path = `/deployments/${model}${options.path}`;\n            }\n        }\n        return super.buildRequest(options);\n    }\n    async _getAzureADToken() {\n        if (typeof this._azureADTokenProvider === 'function') {\n            const token = await this._azureADTokenProvider();\n            if (!token || typeof token !== 'string') {\n                throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);\n            }\n            return token;\n        }\n        return undefined;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    async prepareOptions(opts) {\n        /**\n         * The user should provide a bearer token provider if they want\n         * to use Azure AD authentication. The user shouldn't set the\n         * Authorization header manually because the header is overwritten\n         * with the Azure AD token if a bearer token provider is provided.\n         */\n        if (opts.headers?.['api-key']) {\n            return super.prepareOptions(opts);\n        }\n        const token = await this._getAzureADToken();\n        opts.headers ?? (opts.headers = {});\n        if (token) {\n            opts.headers['Authorization'] = `Bearer ${token}`;\n        }\n        else if (this.apiKey !== API_KEY_SENTINEL) {\n            opts.headers['api-key'] = this.apiKey;\n        }\n        else {\n            throw new Errors.OpenAIError('Unable to handle auth');\n        }\n        return super.prepareOptions(opts);\n    }\n}\nexports.AzureOpenAI = AzureOpenAI;\nconst _deployments_endpoints = new Set([\n    '/completions',\n    '/chat/completions',\n    '/embeddings',\n    '/audio/transcriptions',\n    '/audio/translations',\n    '/audio/speech',\n    '/images/generations',\n]);\nconst API_KEY_SENTINEL = '<Missing Key>';\n// ---------------------- End Azure ----------------------\nexports = module.exports = OpenAI;\nmodule.exports.AzureOpenAI = AzureOpenAI;\nexports.default = OpenAI;\n//# sourceMappingURL=index.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport * as Errors from './error';\nimport * as Uploads from './uploads';\nimport { type Agent, type RequestInit } from './_shims/index';\nimport * as qs from './internal/qs';\nimport * as Core from './core';\nimport * as Pagination from './pagination';\nimport * as API from './resources/index';\n\nexport interface ClientOptions {\n  /**\n   * Defaults to process.env['OPENAI_API_KEY'].\n   */\n  apiKey?: string | undefined;\n\n  /**\n   * Defaults to process.env['OPENAI_ORG_ID'].\n   */\n  organization?: string | null | undefined;\n\n  /**\n   * Defaults to process.env['OPENAI_PROJECT_ID'].\n   */\n  project?: string | null | undefined;\n\n  /**\n   * Override the default base URL for the API, e.g., \"https://api.example.com/v2/\"\n   *\n   * Defaults to process.env['OPENAI_BASE_URL'].\n   */\n  baseURL?: string | null | undefined;\n\n  /**\n   * The maximum amount of time (in milliseconds) that the client should wait for a response\n   * from the server before timing out a single request.\n   *\n   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait\n   * much longer than this timeout before the promise succeeds or fails.\n   */\n  timeout?: number;\n\n  /**\n   * An HTTP agent used to manage HTTP(S) connections.\n   *\n   * If not provided, an agent will be constructed by default in the Node.js environment,\n   * otherwise no agent is used.\n   */\n  httpAgent?: Agent;\n\n  /**\n   * Specify a custom `fetch` function implementation.\n   *\n   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is\n   * defined globally.\n   */\n  fetch?: Core.Fetch | undefined;\n\n  /**\n   * The maximum number of times that the client will retry a request in case of a\n   * temporary failure, like a network error or a 5XX error from the server.\n   *\n   * @default 2\n   */\n  maxRetries?: number;\n\n  /**\n   * Default headers to include with every request to the API.\n   *\n   * These can be removed in individual requests by explicitly setting the\n   * header to `undefined` or `null` in request options.\n   */\n  defaultHeaders?: Core.Headers;\n\n  /**\n   * Default query parameters to include with every request to the API.\n   *\n   * These can be removed in individual requests by explicitly setting the\n   * param to `undefined` in request options.\n   */\n  defaultQuery?: Core.DefaultQuery;\n\n  /**\n   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.\n   */\n  dangerouslyAllowBrowser?: boolean;\n}\n\n/**\n * API Client for interfacing with the OpenAI API.\n */\nexport class OpenAI extends Core.APIClient {\n  apiKey: string;\n  organization: string | null;\n  project: string | null;\n\n  private _options: ClientOptions;\n\n  /**\n   * API Client for interfacing with the OpenAI API.\n   *\n   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]\n   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]\n   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.\n   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   */\n  constructor({\n    baseURL = Core.readEnv('OPENAI_BASE_URL'),\n    apiKey = Core.readEnv('OPENAI_API_KEY'),\n    organization = Core.readEnv('OPENAI_ORG_ID') ?? null,\n    project = Core.readEnv('OPENAI_PROJECT_ID') ?? null,\n    ...opts\n  }: ClientOptions = {}) {\n    if (apiKey === undefined) {\n      throw new Errors.OpenAIError(\n        \"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\",\n      );\n    }\n\n    const options: ClientOptions = {\n      apiKey,\n      organization,\n      project,\n      ...opts,\n      baseURL: baseURL || `https://api.openai.com/v1`,\n    };\n\n    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n      throw new Errors.OpenAIError(\n        \"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\\n\\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\\n\",\n      );\n    }\n\n    super({\n      baseURL: options.baseURL!,\n      timeout: options.timeout ?? 600000 /* 10 minutes */,\n      httpAgent: options.httpAgent,\n      maxRetries: options.maxRetries,\n      fetch: options.fetch,\n    });\n\n    this._options = options;\n\n    this.apiKey = apiKey;\n    this.organization = organization;\n    this.project = project;\n  }\n\n  completions: API.Completions = new API.Completions(this);\n  chat: API.Chat = new API.Chat(this);\n  embeddings: API.Embeddings = new API.Embeddings(this);\n  files: API.Files = new API.Files(this);\n  images: API.Images = new API.Images(this);\n  audio: API.Audio = new API.Audio(this);\n  moderations: API.Moderations = new API.Moderations(this);\n  models: API.Models = new API.Models(this);\n  fineTuning: API.FineTuning = new API.FineTuning(this);\n  beta: API.Beta = new API.Beta(this);\n  batches: API.Batches = new API.Batches(this);\n  uploads: API.Uploads = new API.Uploads(this);\n\n  protected override defaultQuery(): Core.DefaultQuery | undefined {\n    return this._options.defaultQuery;\n  }\n\n  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {\n    return {\n      ...super.defaultHeaders(opts),\n      'OpenAI-Organization': this.organization,\n      'OpenAI-Project': this.project,\n      ...this._options.defaultHeaders,\n    };\n  }\n\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\n    return { Authorization: `Bearer ${this.apiKey}` };\n  }\n\n  protected override stringifyQuery(query: Record<string, unknown>): string {\n    return qs.stringify(query, { arrayFormat: 'brackets' });\n  }\n\n  static OpenAI = this;\n  static DEFAULT_TIMEOUT = 600000; // 10 minutes\n\n  static OpenAIError = Errors.OpenAIError;\n  static APIError = Errors.APIError;\n  static APIConnectionError = Errors.APIConnectionError;\n  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\n  static APIUserAbortError = Errors.APIUserAbortError;\n  static NotFoundError = Errors.NotFoundError;\n  static ConflictError = Errors.ConflictError;\n  static RateLimitError = Errors.RateLimitError;\n  static BadRequestError = Errors.BadRequestError;\n  static AuthenticationError = Errors.AuthenticationError;\n  static InternalServerError = Errors.InternalServerError;\n  static PermissionDeniedError = Errors.PermissionDeniedError;\n  static UnprocessableEntityError = Errors.UnprocessableEntityError;\n\n  static toFile = Uploads.toFile;\n  static fileFromPath = Uploads.fileFromPath;\n}\n\nexport const {\n  OpenAIError,\n  APIError,\n  APIConnectionError,\n  APIConnectionTimeoutError,\n  APIUserAbortError,\n  NotFoundError,\n  ConflictError,\n  RateLimitError,\n  BadRequestError,\n  AuthenticationError,\n  InternalServerError,\n  PermissionDeniedError,\n  UnprocessableEntityError,\n} = Errors;\n\nexport import toFile = Uploads.toFile;\nexport import fileFromPath = Uploads.fileFromPath;\n\nexport namespace OpenAI {\n  export import RequestOptions = Core.RequestOptions;\n\n  export import Page = Pagination.Page;\n  export import PageResponse = Pagination.PageResponse;\n\n  export import CursorPage = Pagination.CursorPage;\n  export import CursorPageParams = Pagination.CursorPageParams;\n  export import CursorPageResponse = Pagination.CursorPageResponse;\n\n  export import Completions = API.Completions;\n  export import Completion = API.Completion;\n  export import CompletionChoice = API.CompletionChoice;\n  export import CompletionUsage = API.CompletionUsage;\n  export import CompletionCreateParams = API.CompletionCreateParams;\n  export import CompletionCreateParamsNonStreaming = API.CompletionCreateParamsNonStreaming;\n  export import CompletionCreateParamsStreaming = API.CompletionCreateParamsStreaming;\n\n  export import Chat = API.Chat;\n  export import ChatModel = API.ChatModel;\n  export import ChatCompletion = API.ChatCompletion;\n  export import ChatCompletionAssistantMessageParam = API.ChatCompletionAssistantMessageParam;\n  export import ChatCompletionChunk = API.ChatCompletionChunk;\n  export import ChatCompletionContentPart = API.ChatCompletionContentPart;\n  export import ChatCompletionContentPartImage = API.ChatCompletionContentPartImage;\n  export import ChatCompletionContentPartRefusal = API.ChatCompletionContentPartRefusal;\n  export import ChatCompletionContentPartText = API.ChatCompletionContentPartText;\n  export import ChatCompletionFunctionCallOption = API.ChatCompletionFunctionCallOption;\n  export import ChatCompletionFunctionMessageParam = API.ChatCompletionFunctionMessageParam;\n  export import ChatCompletionMessage = API.ChatCompletionMessage;\n  export import ChatCompletionMessageParam = API.ChatCompletionMessageParam;\n  export import ChatCompletionMessageToolCall = API.ChatCompletionMessageToolCall;\n  export import ChatCompletionNamedToolChoice = API.ChatCompletionNamedToolChoice;\n  export import ChatCompletionRole = API.ChatCompletionRole;\n  export import ChatCompletionStreamOptions = API.ChatCompletionStreamOptions;\n  export import ChatCompletionSystemMessageParam = API.ChatCompletionSystemMessageParam;\n  export import ChatCompletionTokenLogprob = API.ChatCompletionTokenLogprob;\n  export import ChatCompletionTool = API.ChatCompletionTool;\n  export import ChatCompletionToolChoiceOption = API.ChatCompletionToolChoiceOption;\n  export import ChatCompletionToolMessageParam = API.ChatCompletionToolMessageParam;\n  export import ChatCompletionUserMessageParam = API.ChatCompletionUserMessageParam;\n  export import ChatCompletionCreateParams = API.ChatCompletionCreateParams;\n  export import ChatCompletionCreateParamsNonStreaming = API.ChatCompletionCreateParamsNonStreaming;\n  export import ChatCompletionCreateParamsStreaming = API.ChatCompletionCreateParamsStreaming;\n\n  export import Embeddings = API.Embeddings;\n  export import CreateEmbeddingResponse = API.CreateEmbeddingResponse;\n  export import Embedding = API.Embedding;\n  export import EmbeddingModel = API.EmbeddingModel;\n  export import EmbeddingCreateParams = API.EmbeddingCreateParams;\n\n  export import Files = API.Files;\n  export import FileContent = API.FileContent;\n  export import FileDeleted = API.FileDeleted;\n  export import FileObject = API.FileObject;\n  export import FilePurpose = API.FilePurpose;\n  export import FileObjectsPage = API.FileObjectsPage;\n  export import FileCreateParams = API.FileCreateParams;\n  export import FileListParams = API.FileListParams;\n\n  export import Images = API.Images;\n  export import Image = API.Image;\n  export import ImageModel = API.ImageModel;\n  export import ImagesResponse = API.ImagesResponse;\n  export import ImageCreateVariationParams = API.ImageCreateVariationParams;\n  export import ImageEditParams = API.ImageEditParams;\n  export import ImageGenerateParams = API.ImageGenerateParams;\n\n  export import Audio = API.Audio;\n  export import AudioModel = API.AudioModel;\n  export import AudioResponseFormat = API.AudioResponseFormat;\n\n  export import Moderations = API.Moderations;\n  export import Moderation = API.Moderation;\n  export import ModerationImageURLInput = API.ModerationImageURLInput;\n  export import ModerationModel = API.ModerationModel;\n  export import ModerationMultiModalInput = API.ModerationMultiModalInput;\n  export import ModerationTextInput = API.ModerationTextInput;\n  export import ModerationCreateResponse = API.ModerationCreateResponse;\n  export import ModerationCreateParams = API.ModerationCreateParams;\n\n  export import Models = API.Models;\n  export import Model = API.Model;\n  export import ModelDeleted = API.ModelDeleted;\n  export import ModelsPage = API.ModelsPage;\n\n  export import FineTuning = API.FineTuning;\n\n  export import Beta = API.Beta;\n\n  export import Batches = API.Batches;\n  export import Batch = API.Batch;\n  export import BatchError = API.BatchError;\n  export import BatchRequestCounts = API.BatchRequestCounts;\n  export import BatchesPage = API.BatchesPage;\n  export import BatchCreateParams = API.BatchCreateParams;\n  export import BatchListParams = API.BatchListParams;\n\n  export import Uploads = API.Uploads;\n  export import Upload = API.Upload;\n  export import UploadCreateParams = API.UploadCreateParams;\n  export import UploadCompleteParams = API.UploadCompleteParams;\n\n  export import ErrorObject = API.ErrorObject;\n  export import FunctionDefinition = API.FunctionDefinition;\n  export import FunctionParameters = API.FunctionParameters;\n  export import ResponseFormatJSONObject = API.ResponseFormatJSONObject;\n  export import ResponseFormatJSONSchema = API.ResponseFormatJSONSchema;\n  export import ResponseFormatText = API.ResponseFormatText;\n}\n\n// ---------------------- Azure ----------------------\n\n/** API Client for interfacing with the Azure OpenAI API. */\nexport interface AzureClientOptions extends ClientOptions {\n  /**\n   * Defaults to process.env['OPENAI_API_VERSION'].\n   */\n  apiVersion?: string | undefined;\n\n  /**\n   * Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n   */\n  endpoint?: string | undefined;\n\n  /**\n   * A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n   * Note: this means you won't be able to use non-deployment endpoints. Not supported with Assistants APIs.\n   */\n  deployment?: string | undefined;\n\n  /**\n   * Defaults to process.env['AZURE_OPENAI_API_KEY'].\n   */\n  apiKey?: string | undefined;\n\n  /**\n   * A function that returns an access token for Microsoft Entra (formerly known as Azure Active Directory),\n   * which will be invoked on every request.\n   */\n  azureADTokenProvider?: (() => Promise<string>) | undefined;\n}\n\n/** API Client for interfacing with the Azure OpenAI API. */\nexport class AzureOpenAI extends OpenAI {\n  private _azureADTokenProvider: (() => Promise<string>) | undefined;\n  private _deployment: string | undefined;\n  apiVersion: string = '';\n  /**\n   * API Client for interfacing with the Azure OpenAI API.\n   *\n   * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]\n   * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`\n   * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]\n   * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.\n   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]\n   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.\n   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   */\n  constructor({\n    baseURL = Core.readEnv('OPENAI_BASE_URL'),\n    apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'),\n    apiVersion = Core.readEnv('OPENAI_API_VERSION'),\n    endpoint,\n    deployment,\n    azureADTokenProvider,\n    dangerouslyAllowBrowser,\n    ...opts\n  }: AzureClientOptions = {}) {\n    if (!apiVersion) {\n      throw new Errors.OpenAIError(\n        \"The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).\",\n      );\n    }\n\n    if (typeof azureADTokenProvider === 'function') {\n      dangerouslyAllowBrowser = true;\n    }\n\n    if (!azureADTokenProvider && !apiKey) {\n      throw new Errors.OpenAIError(\n        'Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.',\n      );\n    }\n\n    if (azureADTokenProvider && apiKey) {\n      throw new Errors.OpenAIError(\n        'The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.',\n      );\n    }\n\n    // define a sentinel value to avoid any typing issues\n    apiKey ??= API_KEY_SENTINEL;\n\n    opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };\n\n    if (!baseURL) {\n      if (!endpoint) {\n        endpoint = process.env['AZURE_OPENAI_ENDPOINT'];\n      }\n\n      if (!endpoint) {\n        throw new Errors.OpenAIError(\n          'Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable',\n        );\n      }\n\n      baseURL = `${endpoint}/openai`;\n    } else {\n      if (endpoint) {\n        throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');\n      }\n    }\n\n    super({\n      apiKey,\n      baseURL,\n      ...opts,\n      ...(dangerouslyAllowBrowser !== undefined ? { dangerouslyAllowBrowser } : {}),\n    });\n\n    this._azureADTokenProvider = azureADTokenProvider;\n    this.apiVersion = apiVersion;\n    this._deployment = deployment;\n  }\n\n  override buildRequest(options: Core.FinalRequestOptions<unknown>): {\n    req: RequestInit;\n    url: string;\n    timeout: number;\n  } {\n    if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {\n      if (!Core.isObj(options.body)) {\n        throw new Error('Expected request body to be an object');\n      }\n      const model = this._deployment || options.body['model'];\n      if (model !== undefined && !this.baseURL.includes('/deployments')) {\n        options.path = `/deployments/${model}${options.path}`;\n      }\n    }\n    return super.buildRequest(options);\n  }\n\n  private async _getAzureADToken(): Promise<string | undefined> {\n    if (typeof this._azureADTokenProvider === 'function') {\n      const token = await this._azureADTokenProvider();\n      if (!token || typeof token !== 'string') {\n        throw new Errors.OpenAIError(\n          `Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`,\n        );\n      }\n      return token;\n    }\n    return undefined;\n  }\n\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\n    return {};\n  }\n\n  protected override async prepareOptions(opts: Core.FinalRequestOptions<unknown>): Promise<void> {\n    /**\n     * The user should provide a bearer token provider if they want\n     * to use Azure AD authentication. The user shouldn't set the\n     * Authorization header manually because the header is overwritten\n     * with the Azure AD token if a bearer token provider is provided.\n     */\n    if (opts.headers?.['api-key']) {\n      return super.prepareOptions(opts);\n    }\n    const token = await this._getAzureADToken();\n    opts.headers ??= {};\n    if (token) {\n      opts.headers['Authorization'] = `Bearer ${token}`;\n    } else if (this.apiKey !== API_KEY_SENTINEL) {\n      opts.headers['api-key'] = this.apiKey;\n    } else {\n      throw new Errors.OpenAIError('Unable to handle auth');\n    }\n    return super.prepareOptions(opts);\n  }\n}\n\nconst _deployments_endpoints = new Set([\n  '/completions',\n  '/chat/completions',\n  '/embeddings',\n  '/audio/transcriptions',\n  '/audio/translations',\n  '/audio/speech',\n  '/images/generations',\n]);\n\nconst API_KEY_SENTINEL = '<Missing Key>';\n\n// ---------------------- End Azure ----------------------\n\nexport default OpenAI;\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentFilterFinishReasonError = exports.LengthFinishReasonError = exports.InternalServerError = exports.RateLimitError = exports.UnprocessableEntityError = exports.ConflictError = exports.NotFoundError = exports.PermissionDeniedError = exports.AuthenticationError = exports.BadRequestError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIUserAbortError = exports.APIError = exports.OpenAIError = void 0;\nconst core_1 = require(\"./core.js\");\nclass OpenAIError extends Error {\n}\nexports.OpenAIError = OpenAIError;\nclass APIError extends OpenAIError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.request_id = headers?.['x-request-id'];\n        const data = error;\n        this.error = data;\n        this.code = data?.['code'];\n        this.param = data?.['param'];\n        this.type = data?.['type'];\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status) {\n            return new APIConnectionError({ message, cause: (0, core_1.castToError)(errorResponse) });\n        }\n        const error = errorResponse?.['error'];\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nexports.APIError = APIError;\nclass APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n        this.status = undefined;\n    }\n}\nexports.APIUserAbortError = APIUserAbortError;\nclass APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        this.status = undefined;\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nexports.APIConnectionError = APIConnectionError;\nclass APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nexports.APIConnectionTimeoutError = APIConnectionTimeoutError;\nclass BadRequestError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 400;\n    }\n}\nexports.BadRequestError = BadRequestError;\nclass AuthenticationError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 401;\n    }\n}\nexports.AuthenticationError = AuthenticationError;\nclass PermissionDeniedError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 403;\n    }\n}\nexports.PermissionDeniedError = PermissionDeniedError;\nclass NotFoundError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 404;\n    }\n}\nexports.NotFoundError = NotFoundError;\nclass ConflictError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 409;\n    }\n}\nexports.ConflictError = ConflictError;\nclass UnprocessableEntityError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 422;\n    }\n}\nexports.UnprocessableEntityError = UnprocessableEntityError;\nclass RateLimitError extends APIError {\n    constructor() {\n        super(...arguments);\n        this.status = 429;\n    }\n}\nexports.RateLimitError = RateLimitError;\nclass InternalServerError extends APIError {\n}\nexports.InternalServerError = InternalServerError;\nclass LengthFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the length limit was reached`);\n    }\n}\nexports.LengthFinishReasonError = LengthFinishReasonError;\nclass ContentFilterFinishReasonError extends OpenAIError {\n    constructor() {\n        super(`Could not parse response content as the request was rejected by the content filter`);\n    }\n}\nexports.ContentFilterFinishReasonError = ContentFilterFinishReasonError;\n//# sourceMappingURL=error.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { castToError, Headers } from './core';\n\nexport class OpenAIError extends Error {}\n\nexport class APIError extends OpenAIError {\n  readonly status: number | undefined;\n  readonly headers: Headers | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  readonly request_id: string | null | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ) {\n    super(`${APIError.makeMessage(status, error, message)}`);\n    this.status = status;\n    this.headers = headers;\n    this.request_id = headers?.['x-request-id'];\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.['code'];\n    this.param = data?.['param'];\n    this.type = data?.['type'];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg =\n      error?.message ?\n        typeof error.message === 'string' ?\n          error.message\n        : JSON.stringify(error.message)\n      : error ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return '(no status code or body)';\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ) {\n    if (!status) {\n      return new APIConnectionError({ message, cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.['error'];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new APIError(status, error, message, headers);\n  }\n}\n\nexport class APIUserAbortError extends APIError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message }: { message?: string } = {}) {\n    super(undefined, undefined, message || 'Request was aborted.', undefined);\n  }\n}\n\nexport class APIConnectionError extends APIError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {\n    super(undefined, undefined, message || 'Connection error.', undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class APIConnectionTimeoutError extends APIConnectionError {\n  constructor({ message }: { message?: string } = {}) {\n    super({ message: message ?? 'Request timed out.' });\n  }\n}\n\nexport class BadRequestError extends APIError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends APIError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends APIError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends APIError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends APIError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends APIError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends APIError {\n  override readonly status: 429 = 429;\n}\n\nexport class InternalServerError extends APIError {}\n\nexport class LengthFinishReasonError extends OpenAIError {\n  constructor() {\n    super(`Could not parse response content as the length limit was reached`);\n  }\n}\n\nexport class ContentFilterFinishReasonError extends OpenAIError {\n  constructor() {\n    super(`Could not parse response content as the request was rejected by the content filter`);\n  }\n}\n","\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isObj = exports.toBase64 = exports.getHeader = exports.getRequiredHeader = exports.isHeadersProtocol = exports.isRunningInBrowser = exports.debug = exports.hasOwn = exports.isEmptyObj = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.readEnv = exports.ensurePresent = exports.castToError = exports.sleep = exports.safeJSON = exports.isRequestOptions = exports.createResponseHeaders = exports.PagePromise = exports.AbstractPage = exports.APIClient = exports.APIPromise = exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = void 0;\nconst version_1 = require(\"./version.js\");\nconst streaming_1 = require(\"./streaming.js\");\nconst error_1 = require(\"./error.js\");\nconst index_1 = require(\"./_shims/index.js\");\nconst uploads_1 = require(\"./uploads.js\");\nvar uploads_2 = require(\"./uploads.js\");\nObject.defineProperty(exports, \"maybeMultipartFormRequestOptions\", { enumerable: true, get: function () { return uploads_2.maybeMultipartFormRequestOptions; } });\nObject.defineProperty(exports, \"multipartFormRequestOptions\", { enumerable: true, get: function () { return uploads_2.multipartFormRequestOptions; } });\nObject.defineProperty(exports, \"createForm\", { enumerable: true, get: function () { return uploads_2.createForm; } });\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return streaming_1.Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const isJSON = contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('x-request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nclass APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props)), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import … from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import … from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('x-request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexports.APIPromise = APIPromise;\nclass APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overridenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overridenFetch ?? index_1.fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && (0, uploads_1.isBlobLike)(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(options, { retryCount = 0 } = {}) {\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : (0, uploads_1.isMultipartBody)(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        const timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? (0, index_1.getDefaultAgent)(url);\n        const minAgentTimeout = timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if ((0, uploads_1.isMultipartBody)(options.body) && index_1.kind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set the retry count header if it was already set or removed by the caller. We check `headers`,\n        // which can contain nulls, instead of `reqHeaders` to account for the removal case.\n        if ((0, exports.getHeader)(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return error_1.APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(exports.castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new error_1.APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new error_1.APIConnectionTimeoutError();\n            }\n            throw new error_1.APIConnectionError({ cause: response });\n        }\n        const responseHeaders = (0, exports.createResponseHeaders)(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => (0, exports.castToError)(e).message);\n            const errJSON = (0, exports.safeJSON)(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new error_1.OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        return (this.getRequestClient()\n            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n            .fetch.call(undefined, url, { signal: controller.signal, ...options })\n            .finally(() => {\n            clearTimeout(timeout);\n        }));\n    }\n    getRequestClient() {\n        return { fetch: this.fetch };\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await (0, exports.sleep)(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${version_1.VERSION}`;\n    }\n}\nexports.APIClient = APIClient;\nclass AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new error_1.OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\nexports.AbstractPage = AbstractPage;\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nclass PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexports.PagePromise = PagePromise;\nconst createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\nexports.createResponseHeaders = createResponseHeaders;\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nconst isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nexports.isRequestOptions = isRequestOptions;\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': version_1.VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': version_1.VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': version_1.VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': version_1.VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': version_1.VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nconst safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\nexports.safeJSON = safeJSON;\n// https://stackoverflow.com/a/19709846\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nexports.sleep = sleep;\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new error_1.OpenAIError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new error_1.OpenAIError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nconst castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\nexports.castToError = castToError;\nconst ensurePresent = (value) => {\n    if (value == null)\n        throw new error_1.OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\nexports.ensurePresent = ensurePresent;\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nconst readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexports.readEnv = readEnv;\nconst coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexports.coerceInteger = coerceInteger;\nconst coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexports.coerceFloat = coerceFloat;\nconst coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexports.coerceBoolean = coerceBoolean;\nconst maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return (0, exports.coerceInteger)(value);\n};\nexports.maybeCoerceInteger = maybeCoerceInteger;\nconst maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return (0, exports.coerceFloat)(value);\n};\nexports.maybeCoerceFloat = maybeCoerceFloat;\nconst maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return (0, exports.coerceBoolean)(value);\n};\nexports.maybeCoerceBoolean = maybeCoerceBoolean;\n// https://stackoverflow.com/a/34491287\nfunction isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\nexports.isEmptyObj = isEmptyObj;\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.hasOwn = hasOwn;\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nfunction debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        console.log(`OpenAI:DEBUG:${action}`, ...args);\n    }\n}\nexports.debug = debug;\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nconst isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexports.isRunningInBrowser = isRunningInBrowser;\nconst isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexports.isHeadersProtocol = isHeadersProtocol;\nconst getRequiredHeader = (headers, header) => {\n    const foundHeader = (0, exports.getHeader)(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexports.getRequiredHeader = getRequiredHeader;\nconst getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if ((0, exports.isHeadersProtocol)(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\nexports.getHeader = getHeader;\n/**\n * Encodes a string to Base64 format.\n */\nconst toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new error_1.OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexports.toBase64 = toBase64;\nfunction isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\nexports.isObj = isObj;\n//# sourceMappingURL=core.js.map","import { VERSION } from './version';\nimport { Stream } from './streaming';\nimport {\n  OpenAIError,\n  APIError,\n  APIConnectionError,\n  APIConnectionTimeoutError,\n  APIUserAbortError,\n} from './error';\nimport {\n  kind as shimsKind,\n  type Readable,\n  getDefaultAgent,\n  type Agent,\n  fetch,\n  type RequestInfo,\n  type RequestInit,\n  type Response,\n  type HeadersInit,\n} from './_shims/index';\nexport { type Response };\nimport { BlobLike, isBlobLike, isMultipartBody } from './uploads';\nexport {\n  maybeMultipartFormRequestOptions,\n  multipartFormRequestOptions,\n  createForm,\n  type Uploadable,\n} from './uploads';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\ntype APIResponseProps = {\n  response: Response;\n  options: FinalRequestOptions;\n  controller: AbortController;\n};\n\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<WithRequestID<T>> {\n  const { response } = props;\n  if (props.options.stream) {\n    debug('response', response.status, response.url, response.headers, response.body);\n\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n\n    if (props.options.__streamClass) {\n      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\n    }\n\n    return Stream.fromSSEResponse(response, props.controller) as any;\n  }\n\n  // fetch refuses to read the body when the status code is 204.\n  if (response.status === 204) {\n    return null as WithRequestID<T>;\n  }\n\n  if (props.options.__binaryResponse) {\n    return response as unknown as WithRequestID<T>;\n  }\n\n  const contentType = response.headers.get('content-type');\n  const isJSON =\n    contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\n  if (isJSON) {\n    const json = await response.json();\n\n    debug('response', response.status, response.url, response.headers, json);\n\n    return _addRequestID(json, response);\n  }\n\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n\n  // TODO handle blob, arraybuffer, other content types, etc.\n  return text as unknown as WithRequestID<T>;\n}\n\ntype WithRequestID<T> =\n  T extends Array<any> | Response | AbstractPage<any> ? T\n  : T extends Record<string, any> ? T & { _request_id?: string | null }\n  : T;\n\nfunction _addRequestID<T>(value: T, response: Response): WithRequestID<T> {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return value as WithRequestID<T>;\n  }\n\n  return Object.defineProperty(value, '_request_id', {\n    value: response.headers.get('x-request-id'),\n    enumerable: false,\n  }) as WithRequestID<T>;\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise<T> extends Promise<WithRequestID<T>> {\n  private parsedPromise: Promise<WithRequestID<T>> | undefined;\n\n  constructor(\n    private responsePromise: Promise<APIResponseProps>,\n    private parseResponse: (\n      props: APIResponseProps,\n    ) => PromiseOrValue<WithRequestID<T>> = defaultParseResponse,\n  ) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  _thenUnwrap<U>(transform: (data: T) => U): APIPromise<U> {\n    return new APIPromise(this.responsePromise, async (props) =>\n      _addRequestID(transform(await this.parseResponse(props)), props.response),\n    );\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   * 👋 Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import … from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n   * returned via the X-Request-ID header which is useful for debugging requests and reporting\n   * issues to OpenAI.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   * 👋 Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import … from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  async withResponse(): Promise<{ data: T; response: Response; request_id: string | null | undefined }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response, request_id: response.headers.get('x-request-id') };\n  }\n\n  private parse(): Promise<WithRequestID<T>> {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse) as any as Promise<WithRequestID<T>>;\n    }\n    return this.parsedPromise;\n  }\n\n  override then<TResult1 = WithRequestID<T>, TResult2 = never>(\n    onfulfilled?: ((value: WithRequestID<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<WithRequestID<T> | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<WithRequestID<T>> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport abstract class APIClient {\n  baseURL: string;\n  maxRetries: number;\n  timeout: number;\n  httpAgent: Agent | undefined;\n\n  private fetch: Fetch;\n  protected idempotencyHeader?: string;\n\n  constructor({\n    baseURL,\n    maxRetries = 2,\n    timeout = 600000, // 10 minutes\n    httpAgent,\n    fetch: overridenFetch,\n  }: {\n    baseURL: string;\n    maxRetries?: number | undefined;\n    timeout: number | undefined;\n    httpAgent: Agent | undefined;\n    fetch: Fetch | undefined;\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n\n    this.fetch = overridenFetch ?? fetch;\n  }\n\n  protected authHeaders(opts: FinalRequestOptions): Headers {\n    return {};\n  }\n\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(opts),\n    };\n  }\n\n  protected abstract defaultQuery(): DefaultQuery | undefined;\n\n  /**\n   * Override this to add your own headers validation:\n   */\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\n\n  protected defaultIdempotencyKey(): string {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n\n  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('get', path, opts);\n  }\n\n  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('post', path, opts);\n  }\n\n  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('patch', path, opts);\n  }\n\n  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('put', path, opts);\n  }\n\n  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('delete', path, opts);\n  }\n\n  private methodRequest<Req, Rsp>(\n    method: HTTPMethod,\n    path: string,\n    opts?: PromiseOrValue<RequestOptions<Req>>,\n  ): APIPromise<Rsp> {\n    return this.request(\n      Promise.resolve(opts).then(async (opts) => {\n        const body =\n          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n          : opts?.body instanceof DataView ? opts.body\n          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n          : opts?.body;\n        return { method, path, ...opts, body };\n      }),\n    );\n  }\n\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    path: string,\n    Page: new (...args: any[]) => PageClass,\n    opts?: RequestOptions<any>,\n  ): PagePromise<PageClass, Item> {\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\n  }\n\n  private calculateContentLength(body: unknown): string | null {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    } else if (ArrayBuffer.isView(body)) {\n      return body.byteLength.toString();\n    }\n\n    return null;\n  }\n\n  buildRequest<Req>(\n    options: FinalRequestOptions<Req>,\n    { retryCount = 0 }: { retryCount?: number } = {},\n  ): { req: RequestInit; url: string; timeout: number } {\n    const { method, path, query, headers: headers = {} } = options;\n\n    const body =\n      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n        options.body\n      : isMultipartBody(options.body) ? options.body.body\n      : options.body ? JSON.stringify(options.body, null, 2)\n      : null;\n    const contentLength = this.calculateContentLength(body);\n\n    const url = this.buildURL(path!, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    const timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = timeout + 1000;\n    if (\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\n    ) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      (httpAgent as any).options.timeout = minAgentTimeout;\n    }\n\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n\n    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n\n    const req: RequestInit = {\n      method,\n      ...(body && { body: body as any }),\n      headers: reqHeaders,\n      ...(httpAgent && { agent: httpAgent }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null,\n    };\n\n    return { req, url, timeout };\n  }\n\n  private buildHeaders({\n    options,\n    headers,\n    contentLength,\n    retryCount,\n  }: {\n    options: FinalRequestOptions;\n    headers: Record<string, string | null | undefined>;\n    contentLength: string | null | undefined;\n    retryCount: number;\n  }): Record<string, string> {\n    const reqHeaders: Record<string, string> = {};\n    if (contentLength) {\n      reqHeaders['content-length'] = contentLength;\n    }\n\n    const defaultHeaders = this.defaultHeaders(options);\n    applyHeadersMut(reqHeaders, defaultHeaders);\n    applyHeadersMut(reqHeaders, headers);\n\n    // let builtin fetch set the Content-Type for multipart bodies\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\n      delete reqHeaders['content-type'];\n    }\n\n    // Don't set the retry count header if it was already set or removed by the caller. We check `headers`,\n    // which can contain nulls, instead of `reqHeaders` to account for the removal case.\n    if (getHeader(headers, 'x-stainless-retry-count') === undefined) {\n      reqHeaders['x-stainless-retry-count'] = String(retryCount);\n    }\n\n    this.validateHeaders(reqHeaders, headers);\n\n    return reqHeaders;\n  }\n\n  /**\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\n   */\n  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}\n\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  protected async prepareRequest(\n    request: RequestInit,\n    { url, options }: { url: string; options: FinalRequestOptions },\n  ): Promise<void> {}\n\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\n    return (\n      !headers ? {}\n      : Symbol.iterator in headers ?\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\n      : { ...headers }\n    );\n  }\n\n  protected makeStatusError(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ) {\n    return APIError.generate(status, error, message, headers);\n  }\n\n  request<Req, Rsp>(\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\n    remainingRetries: number | null = null,\n  ): APIPromise<Rsp> {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n\n  private async makeRequest<Req>(\n    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,\n    retriesRemaining: number | null,\n  ): Promise<APIResponseProps> {\n    const options = await optionsInput;\n    const maxRetries = options.maxRetries ?? this.maxRetries;\n    if (retriesRemaining == null) {\n      retriesRemaining = maxRetries;\n    }\n\n    await this.prepareOptions(options);\n\n    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n\n    await this.prepareRequest(req, { url, options });\n\n    debug('request', url, options, req.headers);\n\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n      throw new APIConnectionError({ cause: response });\n    }\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n\n      const errText = await response.text().catch((e) => castToError(e).message);\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n\n    return { response, options, controller };\n  }\n\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n    options: FinalRequestOptions,\n  ): PagePromise<PageClass, Item> {\n    const request = this.makeRequest(options, null);\n    return new PagePromise<PageClass, Item>(this, request, Page);\n  }\n\n  buildURL<Req>(path: string, query: Req | null | undefined): string {\n    const url =\n      isAbsoluteURL(path) ?\n        new URL(path)\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = { ...defaultQuery, ...query } as Req;\n    }\n\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\n      url.search = this.stringifyQuery(query as Record<string, unknown>);\n    }\n\n    return url.toString();\n  }\n\n  protected stringifyQuery(query: Record<string, unknown>): string {\n    return Object.entries(query)\n      .filter(([_, value]) => typeof value !== 'undefined')\n      .map(([key, value]) => {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n        }\n        if (value === null) {\n          return `${encodeURIComponent(key)}=`;\n        }\n        throw new OpenAIError(\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\n        );\n      })\n      .join('&');\n  }\n\n  async fetchWithTimeout(\n    url: RequestInfo,\n    init: RequestInit | undefined,\n    ms: number,\n    controller: AbortController,\n  ): Promise<Response> {\n    const { signal, ...options } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n\n    const timeout = setTimeout(() => controller.abort(), ms);\n\n    return (\n      this.getRequestClient()\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        .fetch.call(undefined, url, { signal: controller.signal as any, ...options })\n        .finally(() => {\n          clearTimeout(timeout);\n        })\n    );\n  }\n\n  protected getRequestClient(): RequestClient {\n    return { fetch: this.fetch };\n  }\n\n  private shouldRetry(response: Response): boolean {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n\n    // Retry on request timeouts.\n    if (response.status === 408) return true;\n\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n\n    return false;\n  }\n\n  private async retryRequest(\n    options: FinalRequestOptions,\n    retriesRemaining: number,\n    responseHeaders?: Headers | undefined,\n  ): Promise<APIResponseProps> {\n    let timeoutMillis: number | undefined;\n\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n    if (retryAfterMillisHeader) {\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\n      if (!Number.isNaN(timeoutMs)) {\n        timeoutMillis = timeoutMs;\n      }\n    }\n\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    const retryAfterHeader = responseHeaders?.['retry-after'];\n    if (retryAfterHeader && !timeoutMillis) {\n      const timeoutSeconds = parseFloat(retryAfterHeader);\n      if (!Number.isNaN(timeoutSeconds)) {\n        timeoutMillis = timeoutSeconds * 1000;\n      } else {\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n      }\n    }\n\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says, but otherwise calculate a default\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n      const maxRetries = options.maxRetries ?? this.maxRetries;\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n    }\n    await sleep(timeoutMillis);\n\n    return this.makeRequest(options, retriesRemaining - 1);\n  }\n\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 8.0;\n\n    const numRetries = maxRetries - retriesRemaining;\n\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n\n    // Apply some jitter, take up to at most 25 percent of the retry time.\n    const jitter = 1 - Math.random() * 0.25;\n\n    return sleepSeconds * jitter * 1000;\n  }\n\n  private getUserAgent(): string {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n}\n\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\n\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\n  #client: APIClient;\n  protected options: FinalRequestOptions;\n\n  protected response: Response;\n  protected body: unknown;\n\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\n    this.#client = client;\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  /**\n   * @deprecated Use nextPageInfo instead\n   */\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\n  abstract nextPageInfo(): PageInfo | null;\n\n  abstract getPaginatedItems(): Item[];\n\n  hasNextPage(): boolean {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n\n  async getNextPage(): Promise<this> {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new OpenAIError(\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\n      );\n    }\n    const nextOptions = { ...this.options };\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value as any);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: AbstractPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise<\n    PageClass extends AbstractPage<Item>,\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\n  >\n  extends APIPromise<PageClass>\n  implements AsyncIterable<Item>\n{\n  constructor(\n    client: APIClient,\n    request: Promise<APIResponseProps>,\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n  ) {\n    super(\n      request,\n      async (props) =>\n        new Page(\n          client,\n          props.response,\n          await defaultParseResponse(props),\n          props.options,\n        ) as WithRequestID<PageClass>,\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport const createResponseHeaders = (\n  headers: Awaited<ReturnType<Fetch>>['headers'],\n): Record<string, string> => {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries(),\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    },\n  );\n};\n\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\n\nexport type RequestClient = { fetch: Fetch };\nexport type Headers = Record<string, string | null | undefined>;\nexport type DefaultQuery = Record<string, string | undefined>;\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\n\nexport type RequestOptions<\n  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,\n> = {\n  method?: HTTPMethod;\n  path?: string;\n  query?: Req | undefined;\n  body?: Req | null | undefined;\n  headers?: Headers | undefined;\n\n  maxRetries?: number;\n  stream?: boolean | undefined;\n  timeout?: number;\n  httpAgent?: Agent;\n  signal?: AbortSignal | undefined | null;\n  idempotencyKey?: string;\n\n  __binaryRequest?: boolean | undefined;\n  __binaryResponse?: boolean | undefined;\n  __streamClass?: typeof Stream;\n};\n\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n\n  __binaryRequest: true,\n  __binaryResponse: true,\n  __streamClass: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\nexport type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =\n  RequestOptions<Req> & {\n    method: HTTPMethod;\n    path: string;\n  };\n\ndeclare const Deno: any;\ndeclare const EdgeRuntime: any;\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\ntype PlatformName =\n  | 'MacOS'\n  | 'Linux'\n  | 'Windows'\n  | 'FreeBSD'\n  | 'OpenBSD'\n  | 'iOS'\n  | 'Android'\n  | `Other:${string}`\n  | 'Unknown';\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\ntype PlatformProperties = {\n  'X-Stainless-Lang': 'js';\n  'X-Stainless-Package-Version': string;\n  'X-Stainless-OS': PlatformName;\n  'X-Stainless-Arch': Arch;\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\n  'X-Stainless-Runtime-Version': string;\n};\nconst getPlatformProperties = (): PlatformProperties => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version':\n        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version,\n    };\n  }\n\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown',\n  };\n};\n\ntype BrowserInfo = {\n  browser: Browser;\n  version: string;\n};\n\ndeclare const navigator: { userAgent: string } | undefined;\n\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo(): BrowserInfo | null {\n  if (typeof navigator === 'undefined' || !navigator) {\n    return null;\n  }\n\n  // NOTE: The order matters here!\n  const browserPatterns = [\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n  ];\n\n  // Find the FIRST matching browser\n  for (const { key, pattern } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n\n      return { browser: key, version: `${major}.${minor}.${patch}` };\n    }\n  }\n\n  return null;\n}\n\nconst normalizeArch = (arch: string): Arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\n\nconst normalizePlatform = (platform: string): PlatformName => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n\n  platform = platform.toLowerCase();\n\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\n\nlet _platformHeaders: PlatformProperties;\nconst getPlatformHeaders = () => {\n  return (_platformHeaders ??= getPlatformProperties());\n};\n\nexport const safeJSON = (text: string) => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\n\n// https://stackoverflow.com/a/19709846\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst isAbsoluteURL = (url: string): boolean => {\n  return startsWithSchemeRegexp.test(url);\n};\n\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst validatePositiveInteger = (name: string, n: unknown): number => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new OpenAIError(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new OpenAIError(`${name} must be a positive integer`);\n  }\n  return n;\n};\n\nexport const castToError = (err: any): Error => {\n  if (err instanceof Error) return err;\n  if (typeof err === 'object' && err !== null) {\n    try {\n      return new Error(JSON.stringify(err));\n    } catch {}\n  }\n  return new Error(err);\n};\n\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\n  if (value == null) throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env: string): string | undefined => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env]?.trim() ?? undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env)?.trim();\n  }\n  return undefined;\n};\n\nexport const coerceInteger = (value: unknown): number => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceFloat = (value: unknown): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceBoolean = (value: unknown): boolean => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\n\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceInteger(value);\n};\n\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceFloat(value);\n};\n\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceBoolean(value);\n};\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {\n  for (const k in newHeaders) {\n    if (!hasOwn(newHeaders, k)) continue;\n    const lowerKey = k.toLowerCase();\n    if (!lowerKey) continue;\n\n    const val = newHeaders[k];\n\n    if (val === null) {\n      delete targetHeaders[lowerKey];\n    } else if (val !== undefined) {\n      targetHeaders[lowerKey] = val;\n    }\n  }\n}\n\nexport function debug(action: string, ...args: any[]) {\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n    console.log(`OpenAI:DEBUG:${action}`, ...args);\n  }\n}\n\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nexport const isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\n\nexport interface HeadersProtocol {\n  get: (header: string) => string | null | undefined;\n}\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\n\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\n  return typeof headers?.get === 'function';\n};\n\nexport const getRequiredHeader = (headers: HeadersLike | Headers, header: string): string => {\n  const foundHeader = getHeader(headers, header);\n  if (foundHeader === undefined) {\n    throw new Error(`Could not find ${header} header`);\n  }\n  return foundHeader;\n};\n\nexport const getHeader = (headers: HeadersLike | Headers, header: string): string | undefined => {\n  const lowerCasedHeader = header.toLowerCase();\n  if (isHeadersProtocol(headers)) {\n    // to deal with the case where the header looks like Stainless-Event-Id\n    const intercapsHeader =\n      header[0]?.toUpperCase() +\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n      const value = headers.get(key);\n      if (value) {\n        return value;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (key.toLowerCase() === lowerCasedHeader) {\n      if (Array.isArray(value)) {\n        if (value.length <= 1) return value[0];\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n        return value[0];\n      }\n      return value;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str: string | null | undefined): string => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n\n  throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n\nexport function isObj(obj: unknown): obj is Record<string, unknown> {\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VERSION = void 0;\nexports.VERSION = '4.66.1'; // x-release-please-version\n//# sourceMappingURL=version.js.map","export const VERSION = '4.66.1'; // x-release-please-version\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readableStreamAsyncIterable = exports._decodeChunks = exports._iterSSEMessages = exports.Stream = void 0;\nconst index_1 = require(\"./_shims/index.js\");\nconst error_1 = require(\"./error.js\");\nconst error_2 = require(\"openai/error\");\nclass Stream {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    static fromSSEResponse(response, controller) {\n        let consumed = false;\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (done)\n                        continue;\n                    if (sse.data.startsWith('[DONE]')) {\n                        done = true;\n                        continue;\n                    }\n                    if (sse.event === null) {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        if (data && data.error) {\n                            throw new error_2.APIError(undefined, data.error, undefined, undefined);\n                        }\n                        yield data;\n                    }\n                    else {\n                        let data;\n                        try {\n                            data = JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            console.error(`Could not parse message into JSON:`, sse.data);\n                            console.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                        // TODO: Is this where the error should be thrown?\n                        if (sse.event == 'error') {\n                            throw new error_2.APIError(undefined, data.error, data.message, undefined);\n                        }\n                        yield { event: sse.event, data: data };\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new LineDecoder();\n            const iter = readableStreamAsyncIterable(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if (e instanceof Error && e.name === 'AbortError')\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller),\n            new Stream(() => teeIterator(right), this.controller),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        const encoder = new TextEncoder();\n        return new index_1.ReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nexports.Stream = Stream;\nasync function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        throw new error_1.OpenAIError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = readableStreamAsyncIterable(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\nexports._iterSSEMessages = _iterSSEMessages;\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nfunction findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 2; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n    constructor() {\n        this.buffer = [];\n        this.trailingCR = false;\n    }\n    decode(chunk) {\n        let text = this.decodeText(chunk);\n        if (this.trailingCR) {\n            text = '\\r' + text;\n            this.trailingCR = false;\n        }\n        if (text.endsWith('\\r')) {\n            this.trailingCR = true;\n            text = text.slice(0, -1);\n        }\n        if (!text) {\n            return [];\n        }\n        const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n        let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n        // if there is a trailing new line then the last entry will be an empty\n        // string which we don't care about\n        if (trailingNewline) {\n            lines.pop();\n        }\n        if (lines.length === 1 && !trailingNewline) {\n            this.buffer.push(lines[0]);\n            return [];\n        }\n        if (this.buffer.length > 0) {\n            lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n            this.buffer = [];\n        }\n        if (!trailingNewline) {\n            this.buffer = [lines.pop() || ''];\n        }\n        return lines;\n    }\n    decodeText(bytes) {\n        if (bytes == null)\n            return '';\n        if (typeof bytes === 'string')\n            return bytes;\n        // Node:\n        if (typeof Buffer !== 'undefined') {\n            if (bytes instanceof Buffer) {\n                return bytes.toString();\n            }\n            if (bytes instanceof Uint8Array) {\n                return Buffer.from(bytes).toString();\n            }\n            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n        }\n        // Browser\n        if (typeof TextDecoder !== 'undefined') {\n            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n                return this.textDecoder.decode(bytes);\n            }\n            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n        }\n        throw new error_1.OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n    }\n    flush() {\n        if (!this.buffer.length && !this.trailingCR) {\n            return [];\n        }\n        const lines = [this.buffer.join('')];\n        this.buffer = [];\n        this.trailingCR = false;\n        return lines;\n    }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/** This is an internal helper function that's just used for testing */\nfunction _decodeChunks(chunks) {\n    const decoder = new LineDecoder();\n    const lines = [];\n    for (const chunk of chunks) {\n        lines.push(...decoder.decode(chunk));\n    }\n    return lines;\n}\nexports._decodeChunks = _decodeChunks;\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nexports.readableStreamAsyncIterable = readableStreamAsyncIterable;\n//# sourceMappingURL=streaming.js.map","import { ReadableStream, type Response } from './_shims/index';\nimport { OpenAIError } from './error';\n\nimport { APIError } from \"./error\";\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(\n    private iterator: () => AsyncIterator<Item>,\n    controller: AbortController,\n  ) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\n    let consumed = false;\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (done) continue;\n\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n\n          if (sse.event === null) {\n            let data;\n\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n\n            if (data && data.error) {\n              throw new APIError(undefined, data.error, undefined, undefined);\n            }\n\n            yield data;\n          } else {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            // TODO: Is this where the error should be thrown?\n            if (sse.event == 'error') {\n              throw new APIError(undefined, data.error, data.message, undefined);\n            }\n            yield { event: sse.event, data: data } as any;\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl: any) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nexport async function* _iterSSEMessages(\n  response: Response,\n  controller: AbortController,\n): AsyncGenerator<ServerSentEvent, void, unknown> {\n  if (!response.body) {\n    controller.abort();\n    throw new OpenAIError(`Attempted to iterate over a response with no body`);\n  }\n\n  const sseDecoder = new SSEDecoder();\n  const lineDecoder = new LineDecoder();\n\n  const iter = readableStreamAsyncIterable<Bytes>(response.body);\n  for await (const sseChunk of iterSSEChunks(iter)) {\n    for (const line of lineDecoder.decode(sseChunk)) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  for (const line of lineDecoder.flush()) {\n    const sse = sseDecoder.decode(line);\n    if (sse) yield sse;\n  }\n}\n\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\n  let data = new Uint8Array();\n\n  for await (const chunk of iterator) {\n    if (chunk == null) {\n      continue;\n    }\n\n    const binaryChunk =\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n      : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n      : chunk;\n\n    let newData = new Uint8Array(data.length + binaryChunk.length);\n    newData.set(data);\n    newData.set(binaryChunk, data.length);\n    data = newData;\n\n    let patternIndex;\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n      yield data.slice(0, patternIndex);\n      data = data.slice(patternIndex);\n    }\n  }\n\n  if (data.length > 0) {\n    yield data;\n  }\n}\n\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n\n  for (let i = 0; i < buffer.length - 2; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (\n      buffer[i] === carriage &&\n      buffer[i + 1] === newline &&\n      i + 3 < buffer.length &&\n      buffer[i + 2] === carriage &&\n      buffer[i + 3] === newline\n    ) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n\n  return -1;\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    // if there is a trailing new line then the last entry will be an empty\n    // string which we don't care about\n    if (trailingNewline) {\n      lines.pop();\n    }\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new OpenAIError(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new OpenAIError(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks: string[]): string[] {\n  const decoder = new LineDecoder();\n  const lines: string[] = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n\n  return lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nconst shims = require('./registry');\nconst auto = require('openai/_shims/auto/runtime');\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\nfor (const property of Object.keys(shims)) {\n  Object.defineProperty(exports, property, {\n    get() {\n      return shims[property];\n    },\n  });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setShims = exports.isFsReadStream = exports.fileFromPath = exports.getDefaultAgent = exports.getMultipartRequestOptions = exports.ReadableStream = exports.File = exports.Blob = exports.FormData = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.kind = exports.auto = void 0;\nexports.auto = false;\nexports.kind = undefined;\nexports.fetch = undefined;\nexports.Request = undefined;\nexports.Response = undefined;\nexports.Headers = undefined;\nexports.FormData = undefined;\nexports.Blob = undefined;\nexports.File = undefined;\nexports.ReadableStream = undefined;\nexports.getMultipartRequestOptions = undefined;\nexports.getDefaultAgent = undefined;\nexports.fileFromPath = undefined;\nexports.isFsReadStream = undefined;\nfunction setShims(shims, options = { auto: false }) {\n    if (exports.auto) {\n        throw new Error(`you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`);\n    }\n    if (exports.kind) {\n        throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${exports.kind}'\\``);\n    }\n    exports.auto = options.auto;\n    exports.kind = shims.kind;\n    exports.fetch = shims.fetch;\n    exports.Request = shims.Request;\n    exports.Response = shims.Response;\n    exports.Headers = shims.Headers;\n    exports.FormData = shims.FormData;\n    exports.Blob = shims.Blob;\n    exports.File = shims.File;\n    exports.ReadableStream = shims.ReadableStream;\n    exports.getMultipartRequestOptions = shims.getMultipartRequestOptions;\n    exports.getDefaultAgent = shims.getDefaultAgent;\n    exports.fileFromPath = shims.fileFromPath;\n    exports.isFsReadStream = shims.isFsReadStream;\n}\nexports.setShims = setShims;\n//# sourceMappingURL=registry.js.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport { type RequestOptions } from '../core';\n\nexport interface Shims {\n  kind: string;\n  fetch: any;\n  Request: any;\n  Response: any;\n  Headers: any;\n  FormData: any;\n  Blob: any;\n  File: any;\n  ReadableStream: any;\n  getMultipartRequestOptions: <T = Record<string, unknown>>(\n    form: Shims['FormData'],\n    opts: RequestOptions<T>,\n  ) => Promise<RequestOptions<T>>;\n  getDefaultAgent: (url: string) => any;\n  fileFromPath:\n    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)\n    | ((path: string, options?: {}) => Promise<Shims['File']>);\n  isFsReadStream: (value: any) => boolean;\n}\n\nexport let auto = false;\nexport let kind: Shims['kind'] | undefined = undefined;\nexport let fetch: Shims['fetch'] | undefined = undefined;\nexport let Request: Shims['Request'] | undefined = undefined;\nexport let Response: Shims['Response'] | undefined = undefined;\nexport let Headers: Shims['Headers'] | undefined = undefined;\nexport let FormData: Shims['FormData'] | undefined = undefined;\nexport let Blob: Shims['Blob'] | undefined = undefined;\nexport let File: Shims['File'] | undefined = undefined;\nexport let ReadableStream: Shims['ReadableStream'] | undefined = undefined;\nexport let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;\nexport let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;\nexport let fileFromPath: Shims['fileFromPath'] | undefined = undefined;\nexport let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;\n\nexport function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {\n  if (auto) {\n    throw new Error(\n      `you must \\`import 'openai/shims/${shims.kind}'\\` before importing anything else from openai`,\n    );\n  }\n  if (kind) {\n    throw new Error(`can't \\`import 'openai/shims/${shims.kind}'\\` after \\`import 'openai/shims/${kind}'\\``);\n  }\n  auto = options.auto;\n  kind = shims.kind;\n  fetch = shims.fetch;\n  Request = shims.Request;\n  Response = shims.Response;\n  Headers = shims.Headers;\n  FormData = shims.FormData;\n  Blob = shims.Blob;\n  File = shims.File;\n  ReadableStream = shims.ReadableStream;\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\n  getDefaultAgent = shims.getDefaultAgent;\n  fileFromPath = shims.fileFromPath;\n  isFsReadStream = shims.isFsReadStream;\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\n__exportStar(require(\"../web-runtime.js\"), exports);\n//# sourceMappingURL=runtime.js.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport * from '../web-runtime';\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRuntime = void 0;\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nconst MultipartBody_1 = require(\"./MultipartBody.js\");\nfunction getRuntime({ manuallyImported } = {}) {\n    const recommendation = manuallyImported ?\n        `You may need to use polyfills`\n        : `Add one of these imports before your first \\`import … from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n    let _fetch, _Request, _Response, _Headers;\n    try {\n        // @ts-ignore\n        _fetch = fetch;\n        // @ts-ignore\n        _Request = Request;\n        // @ts-ignore\n        _Response = Response;\n        // @ts-ignore\n        _Headers = Headers;\n    }\n    catch (error) {\n        throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);\n    }\n    return {\n        kind: 'web',\n        fetch: _fetch,\n        Request: _Request,\n        Response: _Response,\n        Headers: _Headers,\n        FormData: \n        // @ts-ignore\n        typeof FormData !== 'undefined' ? FormData : (class FormData {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);\n            }\n        }),\n        Blob: typeof Blob !== 'undefined' ? Blob : (class Blob {\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);\n            }\n        }),\n        File: \n        // @ts-ignore\n        typeof File !== 'undefined' ? File : (class File {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);\n            }\n        }),\n        ReadableStream: \n        // @ts-ignore\n        typeof ReadableStream !== 'undefined' ? ReadableStream : (class ReadableStream {\n            // @ts-ignore\n            constructor() {\n                throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);\n            }\n        }),\n        getMultipartRequestOptions: async (\n        // @ts-ignore\n        form, opts) => ({\n            ...opts,\n            body: new MultipartBody_1.MultipartBody(form),\n        }),\n        getDefaultAgent: (url) => undefined,\n        fileFromPath: () => {\n            throw new Error('The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads');\n        },\n        isFsReadStream: (value) => false,\n    };\n}\nexports.getRuntime = getRuntime;\n//# sourceMappingURL=web-runtime.js.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport { MultipartBody } from './MultipartBody';\nimport { type RequestOptions } from '../core';\nimport { type Shims } from './registry';\n\nexport function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {\n  const recommendation =\n    manuallyImported ?\n      `You may need to use polyfills`\n    : `Add one of these imports before your first \\`import … from 'openai'\\`:\n- \\`import 'openai/shims/node'\\` (if you're running on Node)\n- \\`import 'openai/shims/web'\\` (otherwise)\n`;\n\n  let _fetch, _Request, _Response, _Headers;\n  try {\n    // @ts-ignore\n    _fetch = fetch;\n    // @ts-ignore\n    _Request = Request;\n    // @ts-ignore\n    _Response = Response;\n    // @ts-ignore\n    _Headers = Headers;\n  } catch (error) {\n    throw new Error(\n      `this environment is missing the following Web Fetch API type: ${\n        (error as any).message\n      }. ${recommendation}`,\n    );\n  }\n\n  return {\n    kind: 'web',\n    fetch: _fetch,\n    Request: _Request,\n    Response: _Response,\n    Headers: _Headers,\n    FormData:\n      // @ts-ignore\n      typeof FormData !== 'undefined' ? FormData : (\n        class FormData {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    Blob:\n      typeof Blob !== 'undefined' ? Blob : (\n        class Blob {\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    File:\n      // @ts-ignore\n      typeof File !== 'undefined' ? File : (\n        class File {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    ReadableStream:\n      // @ts-ignore\n      typeof ReadableStream !== 'undefined' ? ReadableStream : (\n        class ReadableStream {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    getMultipartRequestOptions: async <T = Record<string, unknown>>(\n      // @ts-ignore\n      form: FormData,\n      opts: RequestOptions<T>,\n    ): Promise<RequestOptions<T>> => ({\n      ...opts,\n      body: new MultipartBody(form) as any,\n    }),\n    getDefaultAgent: (url: string) => undefined,\n    fileFromPath: () => {\n      throw new Error(\n        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads',\n      );\n    },\n    isFsReadStream: (value: any) => false,\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultipartBody = void 0;\n/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nclass MultipartBody {\n    constructor(body) {\n        this.body = body;\n    }\n    get [Symbol.toStringTag]() {\n        return 'MultipartBody';\n    }\n}\nexports.MultipartBody = MultipartBody;\n//# sourceMappingURL=MultipartBody.js.map","/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n  constructor(public body: any) {}\n  get [Symbol.toStringTag](): string {\n    return 'MultipartBody';\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isMultipartBody = exports.toFile = exports.isUploadable = exports.isBlobLike = exports.isFileLike = exports.isResponseLike = exports.fileFromPath = void 0;\nconst index_1 = require(\"./_shims/index.js\");\nvar index_2 = require(\"./_shims/index.js\");\nObject.defineProperty(exports, \"fileFromPath\", { enumerable: true, get: function () { return index_2.fileFromPath; } });\nconst isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\nexports.isResponseLike = isResponseLike;\nconst isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    (0, exports.isBlobLike)(value);\nexports.isFileLike = isFileLike;\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\nexports.isBlobLike = isBlobLike;\nconst isUploadable = (value) => {\n    return (0, exports.isFileLike)(value) || (0, exports.isResponseLike)(value) || (0, index_1.isFsReadStream)(value);\n};\nexports.isUploadable = isUploadable;\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options) {\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if ((0, exports.isFileLike)(value)) {\n        return value;\n    }\n    if ((0, exports.isResponseLike)(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n        // we need to convert the `Blob` into an array buffer because the `Blob` class\n        // that `node-fetch` defines is incompatible with the web standard which results\n        // in `new File` interpreting it as a string instead of binary data.\n        const data = (0, exports.isBlobLike)(blob) ? [(await blob.arrayBuffer())] : [blob];\n        return new index_1.File(data, name, options);\n    }\n    const bits = await getBytes(value);\n    name || (name = getName(value) ?? 'unknown_file');\n    if (!options?.type) {\n        const type = bits[0]?.type;\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return new index_1.File(bits, name, options);\n}\nexports.toFile = toFile;\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if ((0, exports.isBlobLike)(value)) {\n        parts.push(await value.arrayBuffer());\n    }\n    else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(chunk); // TODO, consider validating?\n        }\n    }\n    else {\n        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n            ?.name}; props: ${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    const props = Object.getOwnPropertyNames(value);\n    return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n    return (getStringFromMaybeBuffer(value.name) ||\n        getStringFromMaybeBuffer(value.filename) ||\n        // For fs.ReadStream\n        getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = (x) => {\n    if (typeof x === 'string')\n        return x;\n    if (typeof Buffer !== 'undefined' && x instanceof Buffer)\n        return String(x);\n    return undefined;\n};\nconst isAsyncIterableIterator = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nconst isMultipartBody = (body) => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\nexports.isMultipartBody = isMultipartBody;\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nconst maybeMultipartFormRequestOptions = async (opts) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    const form = await (0, exports.createForm)(opts.body);\n    return (0, index_1.getMultipartRequestOptions)(form, opts);\n};\nexports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;\nconst multipartFormRequestOptions = async (opts) => {\n    const form = await (0, exports.createForm)(opts.body);\n    return (0, index_1.getMultipartRequestOptions)(form, opts);\n};\nexports.multipartFormRequestOptions = multipartFormRequestOptions;\nconst createForm = async (body) => {\n    const form = new index_1.FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\nexports.createForm = createForm;\nconst hasUploadableValue = (value) => {\n    if ((0, exports.isUploadable)(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if ((0, exports.isUploadable)(value)) {\n        const file = await toFile(value);\n        form.append(key, file);\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.js.map","import { type RequestOptions } from './core';\nimport {\n  FormData,\n  File,\n  type Blob,\n  type FilePropertyBag,\n  getMultipartRequestOptions,\n  type FsReadStream,\n  isFsReadStream,\n} from './_shims/index';\nimport { MultipartBody } from './_shims/MultipartBody';\nexport { fileFromPath } from './_shims/index';\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\n\n/**\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\n */\nexport interface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\n}\n\n/**\n * Intended to match web.File, node.File, node-fetch.File, etc.\n */\nexport interface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name: string;\n}\n\n/**\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nexport const isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport const isFileLike = (value: any): value is FileLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\nexport const isUploadable = (value: any): value is Uploadable => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options?: FilePropertyBag | undefined,\n): Promise<FileLike> {\n  // If it's a promise, resolve it.\n  value = await value;\n\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    return value;\n  }\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\n\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\n    // that `node-fetch` defines is incompatible with the web standard which results\n    // in `new File` interpreting it as a string instead of binary data.\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\n\n    return new File(data, name, options);\n  }\n\n  const bits = await getBytes(value);\n\n  name ||= getName(value) ?? 'unknown_file';\n\n  if (!options?.type) {\n    const type = (bits[0] as any)?.type;\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk as BlobPart); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n        ?.name}; props: ${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: any): string {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value: any): string | undefined {\n  return (\n    getStringFromMaybeBuffer(value.name) ||\n    getStringFromMaybeBuffer(value.filename) ||\n    // For fs.ReadStream\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\n  );\n}\n\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport const isMultipartBody = (body: any): body is MultipartBody =>\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file as File);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formats = exports.stringify = void 0;\nconst formats_1 = require(\"./formats.js\");\nconst formats = {\n    formatters: formats_1.formatters,\n    RFC1738: formats_1.RFC1738,\n    RFC3986: formats_1.RFC3986,\n    default: formats_1.default_format,\n};\nexports.formats = formats;\nvar stringify_1 = require(\"./stringify.js\");\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return stringify_1.stringify; } });\n//# sourceMappingURL=index.js.map","import { default_format, formatters, RFC1738, RFC3986 } from './formats';\n\nconst formats = {\n  formatters,\n  RFC1738,\n  RFC3986,\n  default: default_format,\n};\n\nexport { stringify } from './stringify';\nexport { formats };\n\nexport type { DefaultDecoder, DefaultEncoder, Format, ParseOptions, StringifyOptions } from './types';\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RFC3986 = exports.RFC1738 = exports.formatters = exports.default_format = void 0;\nexports.default_format = 'RFC3986';\nexports.formatters = {\n    RFC1738: (v) => String(v).replace(/%20/g, '+'),\n    RFC3986: (v) => String(v),\n};\nexports.RFC1738 = 'RFC1738';\nexports.RFC3986 = 'RFC3986';\n//# sourceMappingURL=formats.js.map","import type { Format } from './types';\n\nexport const default_format: Format = 'RFC3986';\nexport const formatters: Record<Format, (str: PropertyKey) => string> = {\n  RFC1738: (v: PropertyKey) => String(v).replace(/%20/g, '+'),\n  RFC3986: (v: PropertyKey) => String(v),\n};\nexport const RFC1738 = 'RFC1738';\nexport const RFC3986 = 'RFC3986';\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringify = void 0;\nconst utils_1 = require(\"./utils.js\");\nconst formats_1 = require(\"./formats.js\");\nconst has = Object.prototype.hasOwnProperty;\nconst array_prefix_generators = {\n    brackets(prefix) {\n        return String(prefix) + '[]';\n    },\n    comma: 'comma',\n    indices(prefix, key) {\n        return String(prefix) + '[' + key + ']';\n    },\n    repeat(prefix) {\n        return String(prefix);\n    },\n};\nconst is_array = Array.isArray;\nconst push = Array.prototype.push;\nconst push_to_array = function (arr, value_or_array) {\n    push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n};\nconst to_ISO = Date.prototype.toISOString;\nconst defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: utils_1.encode,\n    encodeValuesOnly: false,\n    format: formats_1.default_format,\n    formatter: formats_1.formatters[formats_1.default_format],\n    /** @deprecated */\n    indices: false,\n    serializeDate(date) {\n        return to_ISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false,\n};\nfunction is_non_nullish_primitive(v) {\n    return (typeof v === 'string' ||\n        typeof v === 'number' ||\n        typeof v === 'boolean' ||\n        typeof v === 'symbol' ||\n        typeof v === 'bigint');\n}\nconst sentinel = {};\nfunction inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {\n    let obj = object;\n    let tmp_sc = sideChannel;\n    let step = 0;\n    let find_flag = false;\n    while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n        // Where object last appeared in the ref tree\n        const pos = tmp_sc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            }\n            else {\n                find_flag = true; // Break while\n            }\n        }\n        if (typeof tmp_sc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (obj instanceof Date) {\n        obj = serializeDate?.(obj);\n    }\n    else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        obj = (0, utils_1.maybe_map)(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate?.(value);\n            }\n            return value;\n        });\n    }\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ?\n                // @ts-expect-error\n                encoder(prefix, defaults.encoder, charset, 'key', format)\n                : prefix;\n        }\n        obj = '';\n    }\n    if (is_non_nullish_primitive(obj) || (0, utils_1.is_buffer)(obj)) {\n        if (encoder) {\n            const key_value = encodeValuesOnly ? prefix\n                // @ts-expect-error\n                : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [\n                formatter?.(key_value) +\n                    '=' +\n                    // @ts-expect-error\n                    formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n            ];\n        }\n        return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n    }\n    const values = [];\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n    let obj_keys;\n    if (generateArrayPrefix === 'comma' && is_array(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            // @ts-expect-error values only\n            obj = (0, utils_1.maybe_map)(obj, encoder);\n        }\n        obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    }\n    else if (is_array(filter)) {\n        obj_keys = filter;\n    }\n    else {\n        const keys = Object.keys(obj);\n        obj_keys = sort ? keys.sort(sort) : keys;\n    }\n    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n        return adjusted_prefix + '[]';\n    }\n    for (let j = 0; j < obj_keys.length; ++j) {\n        const key = obj_keys[j];\n        const value = \n        // @ts-ignore\n        typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n        if (skipNulls && value === null) {\n            continue;\n        }\n        // @ts-ignore\n        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\\./g, '%2E') : key;\n        const key_prefix = is_array(obj) ?\n            typeof generateArrayPrefix === 'function' ?\n                generateArrayPrefix(adjusted_prefix, encoded_key)\n                : adjusted_prefix\n            : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n        sideChannel.set(object, step);\n        const valueSideChannel = new WeakMap();\n        valueSideChannel.set(sentinel, sideChannel);\n        push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, \n        // @ts-ignore\n        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));\n    }\n    return values;\n}\nfunction normalize_stringify_options(opts = defaults) {\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n    const charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    let format = formats_1.default_format;\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats_1.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    const formatter = formats_1.formatters[format];\n    let filter = defaults.filter;\n    if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n        filter = opts.filter;\n    }\n    let arrayFormat;\n    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n        arrayFormat = opts.arrayFormat;\n    }\n    else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = defaults.arrayFormat;\n    }\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    const allowDots = typeof opts.allowDots === 'undefined' ?\n        !!opts.encodeDotInKeys === true ?\n            true\n            : defaults.allowDots\n        : !!opts.allowDots;\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        // @ts-ignore\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        // @ts-ignore\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n    };\n}\nfunction stringify(object, opts = {}) {\n    let obj = object;\n    const options = normalize_stringify_options(opts);\n    let obj_keys;\n    let filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (is_array(options.filter)) {\n        filter = options.filter;\n        obj_keys = filter;\n    }\n    const keys = [];\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n    const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n    if (!obj_keys) {\n        obj_keys = Object.keys(obj);\n    }\n    if (options.sort) {\n        obj_keys.sort(options.sort);\n    }\n    const sideChannel = new WeakMap();\n    for (let i = 0; i < obj_keys.length; ++i) {\n        const key = obj_keys[i];\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        push_to_array(keys, inner_stringify(obj[key], key, \n        // @ts-expect-error\n        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));\n    }\n    const joined = keys.join(options.delimiter);\n    let prefix = options.addQueryPrefix === true ? '?' : '';\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        }\n        else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n    return joined.length > 0 ? prefix + joined : '';\n}\nexports.stringify = stringify;\n//# sourceMappingURL=stringify.js.map","import { encode, is_buffer, maybe_map } from './utils';\nimport { default_format, formatters } from './formats';\nimport type { NonNullableProperties, StringifyOptions } from './types';\n\nconst has = Object.prototype.hasOwnProperty;\n\nconst array_prefix_generators = {\n  brackets(prefix: PropertyKey) {\n    return String(prefix) + '[]';\n  },\n  comma: 'comma',\n  indices(prefix: PropertyKey, key: string) {\n    return String(prefix) + '[' + key + ']';\n  },\n  repeat(prefix: PropertyKey) {\n    return String(prefix);\n  },\n};\n\nconst is_array = Array.isArray;\nconst push = Array.prototype.push;\nconst push_to_array = function (arr: any[], value_or_array: any) {\n  push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);\n};\n\nconst to_ISO = Date.prototype.toISOString;\n\nconst defaults = {\n  addQueryPrefix: false,\n  allowDots: false,\n  allowEmptyArrays: false,\n  arrayFormat: 'indices',\n  charset: 'utf-8',\n  charsetSentinel: false,\n  delimiter: '&',\n  encode: true,\n  encodeDotInKeys: false,\n  encoder: encode,\n  encodeValuesOnly: false,\n  format: default_format,\n  formatter: formatters[default_format],\n  /** @deprecated */\n  indices: false,\n  serializeDate(date) {\n    return to_ISO.call(date);\n  },\n  skipNulls: false,\n  strictNullHandling: false,\n} as NonNullableProperties<StringifyOptions & { formatter: (typeof formatters)['RFC1738'] }>;\n\nfunction is_non_nullish_primitive(v: unknown): v is string | number | boolean | symbol | bigint {\n  return (\n    typeof v === 'string' ||\n    typeof v === 'number' ||\n    typeof v === 'boolean' ||\n    typeof v === 'symbol' ||\n    typeof v === 'bigint'\n  );\n}\n\nconst sentinel = {};\n\nfunction inner_stringify(\n  object: any,\n  prefix: PropertyKey,\n  generateArrayPrefix: StringifyOptions['arrayFormat'] | ((prefix: string, key: string) => string),\n  commaRoundTrip: boolean,\n  allowEmptyArrays: boolean,\n  strictNullHandling: boolean,\n  skipNulls: boolean,\n  encodeDotInKeys: boolean,\n  encoder: StringifyOptions['encoder'],\n  filter: StringifyOptions['filter'],\n  sort: StringifyOptions['sort'],\n  allowDots: StringifyOptions['allowDots'],\n  serializeDate: StringifyOptions['serializeDate'],\n  format: StringifyOptions['format'],\n  formatter: StringifyOptions['formatter'],\n  encodeValuesOnly: boolean,\n  charset: StringifyOptions['charset'],\n  sideChannel: WeakMap<any, any>,\n) {\n  let obj = object;\n\n  let tmp_sc = sideChannel;\n  let step = 0;\n  let find_flag = false;\n  while ((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag) {\n    // Where object last appeared in the ref tree\n    const pos = tmp_sc.get(object);\n    step += 1;\n    if (typeof pos !== 'undefined') {\n      if (pos === step) {\n        throw new RangeError('Cyclic object value');\n      } else {\n        find_flag = true; // Break while\n      }\n    }\n    if (typeof tmp_sc.get(sentinel) === 'undefined') {\n      step = 0;\n    }\n  }\n\n  if (typeof filter === 'function') {\n    obj = filter(prefix, obj);\n  } else if (obj instanceof Date) {\n    obj = serializeDate?.(obj);\n  } else if (generateArrayPrefix === 'comma' && is_array(obj)) {\n    obj = maybe_map(obj, function (value) {\n      if (value instanceof Date) {\n        return serializeDate?.(value);\n      }\n      return value;\n    });\n  }\n\n  if (obj === null) {\n    if (strictNullHandling) {\n      return encoder && !encodeValuesOnly ?\n          // @ts-expect-error\n          encoder(prefix, defaults.encoder, charset, 'key', format)\n        : prefix;\n    }\n\n    obj = '';\n  }\n\n  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {\n    if (encoder) {\n      const key_value =\n        encodeValuesOnly ? prefix\n          // @ts-expect-error\n        : encoder(prefix, defaults.encoder, charset, 'key', format);\n      return [\n        formatter?.(key_value) +\n          '=' +\n          // @ts-expect-error\n          formatter?.(encoder(obj, defaults.encoder, charset, 'value', format)),\n      ];\n    }\n    return [formatter?.(prefix) + '=' + formatter?.(String(obj))];\n  }\n\n  const values: string[] = [];\n\n  if (typeof obj === 'undefined') {\n    return values;\n  }\n\n  let obj_keys;\n  if (generateArrayPrefix === 'comma' && is_array(obj)) {\n    // we need to join elements in\n    if (encodeValuesOnly && encoder) {\n      // @ts-expect-error values only\n      obj = maybe_map(obj, encoder);\n    }\n    obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n  } else if (is_array(filter)) {\n    obj_keys = filter;\n  } else {\n    const keys = Object.keys(obj);\n    obj_keys = sort ? keys.sort(sort) : keys;\n  }\n\n  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n\n  const adjusted_prefix =\n    commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;\n\n  if (allowEmptyArrays && is_array(obj) && obj.length === 0) {\n    return adjusted_prefix + '[]';\n  }\n\n  for (let j = 0; j < obj_keys.length; ++j) {\n    const key = obj_keys[j];\n    const value =\n      // @ts-ignore\n      typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key as any];\n\n    if (skipNulls && value === null) {\n      continue;\n    }\n\n    // @ts-ignore\n    const encoded_key = allowDots && encodeDotInKeys ? (key as any).replace(/\\./g, '%2E') : key;\n    const key_prefix =\n      is_array(obj) ?\n        typeof generateArrayPrefix === 'function' ?\n          generateArrayPrefix(adjusted_prefix, encoded_key)\n        : adjusted_prefix\n      : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');\n\n    sideChannel.set(object, step);\n    const valueSideChannel = new WeakMap();\n    valueSideChannel.set(sentinel, sideChannel);\n    push_to_array(\n      values,\n      inner_stringify(\n        value,\n        key_prefix,\n        generateArrayPrefix,\n        commaRoundTrip,\n        allowEmptyArrays,\n        strictNullHandling,\n        skipNulls,\n        encodeDotInKeys,\n        // @ts-ignore\n        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder,\n        filter,\n        sort,\n        allowDots,\n        serializeDate,\n        format,\n        formatter,\n        encodeValuesOnly,\n        charset,\n        valueSideChannel,\n      ),\n    );\n  }\n\n  return values;\n}\n\nfunction normalize_stringify_options(\n  opts: StringifyOptions = defaults,\n): NonNullableProperties<Omit<StringifyOptions, 'indices'>> & { indices?: boolean } {\n  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n  }\n\n  if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n    throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n  }\n\n  if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n    throw new TypeError('Encoder has to be a function.');\n  }\n\n  const charset = opts.charset || defaults.charset;\n  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n  }\n\n  let format = default_format;\n  if (typeof opts.format !== 'undefined') {\n    if (!has.call(formatters, opts.format)) {\n      throw new TypeError('Unknown format option provided.');\n    }\n    format = opts.format;\n  }\n  const formatter = formatters[format];\n\n  let filter = defaults.filter;\n  if (typeof opts.filter === 'function' || is_array(opts.filter)) {\n    filter = opts.filter;\n  }\n\n  let arrayFormat: StringifyOptions['arrayFormat'];\n  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {\n    arrayFormat = opts.arrayFormat;\n  } else if ('indices' in opts) {\n    arrayFormat = opts.indices ? 'indices' : 'repeat';\n  } else {\n    arrayFormat = defaults.arrayFormat;\n  }\n\n  if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n    throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n  }\n\n  const allowDots =\n    typeof opts.allowDots === 'undefined' ?\n      !!opts.encodeDotInKeys === true ?\n        true\n      : defaults.allowDots\n    : !!opts.allowDots;\n\n  return {\n    addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n    // @ts-ignore\n    allowDots: allowDots,\n    allowEmptyArrays:\n      typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n    arrayFormat: arrayFormat,\n    charset: charset,\n    charsetSentinel:\n      typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n    commaRoundTrip: !!opts.commaRoundTrip,\n    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n    encodeDotInKeys:\n      typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n    encodeValuesOnly:\n      typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n    filter: filter,\n    format: format,\n    formatter: formatter,\n    serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n    // @ts-ignore\n    sort: typeof opts.sort === 'function' ? opts.sort : null,\n    strictNullHandling:\n      typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n  };\n}\n\nexport function stringify(object: any, opts: StringifyOptions = {}) {\n  let obj = object;\n  const options = normalize_stringify_options(opts);\n\n  let obj_keys: PropertyKey[] | undefined;\n  let filter;\n\n  if (typeof options.filter === 'function') {\n    filter = options.filter;\n    obj = filter('', obj);\n  } else if (is_array(options.filter)) {\n    filter = options.filter;\n    obj_keys = filter;\n  }\n\n  const keys: string[] = [];\n\n  if (typeof obj !== 'object' || obj === null) {\n    return '';\n  }\n\n  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];\n  const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n\n  if (!obj_keys) {\n    obj_keys = Object.keys(obj);\n  }\n\n  if (options.sort) {\n    obj_keys.sort(options.sort);\n  }\n\n  const sideChannel = new WeakMap();\n  for (let i = 0; i < obj_keys.length; ++i) {\n    const key = obj_keys[i]!;\n\n    if (options.skipNulls && obj[key] === null) {\n      continue;\n    }\n    push_to_array(\n      keys,\n      inner_stringify(\n        obj[key],\n        key,\n        // @ts-expect-error\n        generateArrayPrefix,\n        commaRoundTrip,\n        options.allowEmptyArrays,\n        options.strictNullHandling,\n        options.skipNulls,\n        options.encodeDotInKeys,\n        options.encode ? options.encoder : null,\n        options.filter,\n        options.sort,\n        options.allowDots,\n        options.serializeDate,\n        options.format,\n        options.formatter,\n        options.encodeValuesOnly,\n        options.charset,\n        sideChannel,\n      ),\n    );\n  }\n\n  const joined = keys.join(options.delimiter);\n  let prefix = options.addQueryPrefix === true ? '?' : '';\n\n  if (options.charsetSentinel) {\n    if (options.charset === 'iso-8859-1') {\n      // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n      prefix += 'utf8=%26%2310003%3B&';\n    } else {\n      // encodeURIComponent('✓')\n      prefix += 'utf8=%E2%9C%93&';\n    }\n  }\n\n  return joined.length > 0 ? prefix + joined : '';\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.maybe_map = exports.combine = exports.is_buffer = exports.is_regexp = exports.compact = exports.encode = exports.decode = exports.assign_single_source = exports.merge = void 0;\nconst formats_1 = require(\"./formats.js\");\nconst has = Object.prototype.hasOwnProperty;\nconst is_array = Array.isArray;\nconst hex_table = (() => {\n    const array = [];\n    for (let i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n    return array;\n})();\nfunction compact_queue(queue) {\n    while (queue.length > 1) {\n        const item = queue.pop();\n        if (!item)\n            continue;\n        const obj = item.obj[item.prop];\n        if (is_array(obj)) {\n            const compacted = [];\n            for (let j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n            // @ts-ignore\n            item.obj[item.prop] = compacted;\n        }\n    }\n}\nfunction array_to_object(source, options) {\n    const obj = options && options.plainObjects ? Object.create(null) : {};\n    for (let i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n    return obj;\n}\nfunction merge(target, source, options = {}) {\n    if (!source) {\n        return target;\n    }\n    if (typeof source !== 'object') {\n        if (is_array(target)) {\n            target.push(source);\n        }\n        else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) ||\n                !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        }\n        else {\n            return [target, source];\n        }\n        return target;\n    }\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n    let mergeTarget = target;\n    if (is_array(target) && !is_array(source)) {\n        // @ts-ignore\n        mergeTarget = array_to_object(target, options);\n    }\n    if (is_array(target) && is_array(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                const targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n            else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n    return Object.keys(source).reduce(function (acc, key) {\n        const value = source[key];\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        }\n        else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n}\nexports.merge = merge;\nfunction assign_single_source(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n}\nexports.assign_single_source = assign_single_source;\nfunction decode(str, _, charset) {\n    const strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    }\n    catch (e) {\n        return strWithoutPlus;\n    }\n}\nexports.decode = decode;\nconst limit = 1024;\nconst encode = (str, _defaultEncoder, charset, _kind, format) => {\n    // This code was originally written by Brian White for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n    let string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    }\n    else if (typeof str !== 'string') {\n        string = String(str);\n    }\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n    let out = '';\n    for (let j = 0; j < string.length; j += limit) {\n        const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        const arr = [];\n        for (let i = 0; i < segment.length; ++i) {\n            let c = segment.charCodeAt(i);\n            if (c === 0x2d || // -\n                c === 0x2e || // .\n                c === 0x5f || // _\n                c === 0x7e || // ~\n                (c >= 0x30 && c <= 0x39) || // 0-9\n                (c >= 0x41 && c <= 0x5a) || // a-z\n                (c >= 0x61 && c <= 0x7a) || // A-Z\n                (format === formats_1.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n            if (c < 0x80) {\n                arr[arr.length] = hex_table[c];\n                continue;\n            }\n            if (c < 0x800) {\n                arr[arr.length] = hex_table[0xc0 | (c >> 6)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            if (c < 0xd800 || c >= 0xe000) {\n                arr[arr.length] =\n                    hex_table[0xe0 | (c >> 12)] + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n                continue;\n            }\n            i += 1;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n            arr[arr.length] =\n                hex_table[0xf0 | (c >> 18)] +\n                    hex_table[0x80 | ((c >> 12) & 0x3f)] +\n                    hex_table[0x80 | ((c >> 6) & 0x3f)] +\n                    hex_table[0x80 | (c & 0x3f)];\n        }\n        out += arr.join('');\n    }\n    return out;\n};\nexports.encode = encode;\nfunction compact(value) {\n    const queue = [{ obj: { o: value }, prop: 'o' }];\n    const refs = [];\n    for (let i = 0; i < queue.length; ++i) {\n        const item = queue[i];\n        // @ts-ignore\n        const obj = item.obj[item.prop];\n        const keys = Object.keys(obj);\n        for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n    compact_queue(queue);\n    return value;\n}\nexports.compact = compact;\nfunction is_regexp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nexports.is_regexp = is_regexp;\nfunction is_buffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\nexports.is_buffer = is_buffer;\nfunction combine(a, b) {\n    return [].concat(a, b);\n}\nexports.combine = combine;\nfunction maybe_map(val, fn) {\n    if (is_array(val)) {\n        const mapped = [];\n        for (let i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n}\nexports.maybe_map = maybe_map;\n//# sourceMappingURL=utils.js.map","import { RFC1738 } from './formats';\nimport type { DefaultEncoder, Format } from './types';\n\nconst has = Object.prototype.hasOwnProperty;\nconst is_array = Array.isArray;\n\nconst hex_table = (() => {\n  const array = [];\n  for (let i = 0; i < 256; ++i) {\n    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n  }\n\n  return array;\n})();\n\nfunction compact_queue<T extends Record<string, any>>(queue: Array<{ obj: T; prop: string }>) {\n  while (queue.length > 1) {\n    const item = queue.pop();\n    if (!item) continue;\n\n    const obj = item.obj[item.prop];\n\n    if (is_array(obj)) {\n      const compacted: unknown[] = [];\n\n      for (let j = 0; j < obj.length; ++j) {\n        if (typeof obj[j] !== 'undefined') {\n          compacted.push(obj[j]);\n        }\n      }\n\n      // @ts-ignore\n      item.obj[item.prop] = compacted;\n    }\n  }\n}\n\nfunction array_to_object(source: any[], options: { plainObjects: boolean }) {\n  const obj = options && options.plainObjects ? Object.create(null) : {};\n  for (let i = 0; i < source.length; ++i) {\n    if (typeof source[i] !== 'undefined') {\n      obj[i] = source[i];\n    }\n  }\n\n  return obj;\n}\n\nexport function merge(\n  target: any,\n  source: any,\n  options: { plainObjects?: boolean; allowPrototypes?: boolean } = {},\n) {\n  if (!source) {\n    return target;\n  }\n\n  if (typeof source !== 'object') {\n    if (is_array(target)) {\n      target.push(source);\n    } else if (target && typeof target === 'object') {\n      if (\n        (options && (options.plainObjects || options.allowPrototypes)) ||\n        !has.call(Object.prototype, source)\n      ) {\n        target[source] = true;\n      }\n    } else {\n      return [target, source];\n    }\n\n    return target;\n  }\n\n  if (!target || typeof target !== 'object') {\n    return [target].concat(source);\n  }\n\n  let mergeTarget = target;\n  if (is_array(target) && !is_array(source)) {\n    // @ts-ignore\n    mergeTarget = array_to_object(target, options);\n  }\n\n  if (is_array(target) && is_array(source)) {\n    source.forEach(function (item, i) {\n      if (has.call(target, i)) {\n        const targetItem = target[i];\n        if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n          target[i] = merge(targetItem, item, options);\n        } else {\n          target.push(item);\n        }\n      } else {\n        target[i] = item;\n      }\n    });\n    return target;\n  }\n\n  return Object.keys(source).reduce(function (acc, key) {\n    const value = source[key];\n\n    if (has.call(acc, key)) {\n      acc[key] = merge(acc[key], value, options);\n    } else {\n      acc[key] = value;\n    }\n    return acc;\n  }, mergeTarget);\n}\n\nexport function assign_single_source(target: any, source: any) {\n  return Object.keys(source).reduce(function (acc, key) {\n    acc[key] = source[key];\n    return acc;\n  }, target);\n}\n\nexport function decode(str: string, _: any, charset: string) {\n  const strWithoutPlus = str.replace(/\\+/g, ' ');\n  if (charset === 'iso-8859-1') {\n    // unescape never throws, no try...catch needed:\n    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n  }\n  // utf-8\n  try {\n    return decodeURIComponent(strWithoutPlus);\n  } catch (e) {\n    return strWithoutPlus;\n  }\n}\n\nconst limit = 1024;\n\nexport const encode: (\n  str: any,\n  defaultEncoder: DefaultEncoder,\n  charset: string,\n  type: 'key' | 'value',\n  format: Format,\n) => string = (str, _defaultEncoder, charset, _kind, format: Format) => {\n  // This code was originally written by Brian White for the io.js core querystring library.\n  // It has been adapted here for stricter adherence to RFC 3986\n  if (str.length === 0) {\n    return str;\n  }\n\n  let string = str;\n  if (typeof str === 'symbol') {\n    string = Symbol.prototype.toString.call(str);\n  } else if (typeof str !== 'string') {\n    string = String(str);\n  }\n\n  if (charset === 'iso-8859-1') {\n    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n      return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n    });\n  }\n\n  let out = '';\n  for (let j = 0; j < string.length; j += limit) {\n    const segment = string.length >= limit ? string.slice(j, j + limit) : string;\n    const arr = [];\n\n    for (let i = 0; i < segment.length; ++i) {\n      let c = segment.charCodeAt(i);\n      if (\n        c === 0x2d || // -\n        c === 0x2e || // .\n        c === 0x5f || // _\n        c === 0x7e || // ~\n        (c >= 0x30 && c <= 0x39) || // 0-9\n        (c >= 0x41 && c <= 0x5a) || // a-z\n        (c >= 0x61 && c <= 0x7a) || // A-Z\n        (format === RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n      ) {\n        arr[arr.length] = segment.charAt(i);\n        continue;\n      }\n\n      if (c < 0x80) {\n        arr[arr.length] = hex_table[c];\n        continue;\n      }\n\n      if (c < 0x800) {\n        arr[arr.length] = hex_table[0xc0 | (c >> 6)]! + hex_table[0x80 | (c & 0x3f)];\n        continue;\n      }\n\n      if (c < 0xd800 || c >= 0xe000) {\n        arr[arr.length] =\n          hex_table[0xe0 | (c >> 12)]! + hex_table[0x80 | ((c >> 6) & 0x3f)] + hex_table[0x80 | (c & 0x3f)];\n        continue;\n      }\n\n      i += 1;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));\n\n      arr[arr.length] =\n        hex_table[0xf0 | (c >> 18)]! +\n        hex_table[0x80 | ((c >> 12) & 0x3f)] +\n        hex_table[0x80 | ((c >> 6) & 0x3f)] +\n        hex_table[0x80 | (c & 0x3f)];\n    }\n\n    out += arr.join('');\n  }\n\n  return out;\n};\n\nexport function compact(value: any) {\n  const queue = [{ obj: { o: value }, prop: 'o' }];\n  const refs = [];\n\n  for (let i = 0; i < queue.length; ++i) {\n    const item = queue[i];\n    // @ts-ignore\n    const obj = item.obj[item.prop];\n\n    const keys = Object.keys(obj);\n    for (let j = 0; j < keys.length; ++j) {\n      const key = keys[j]!;\n      const val = obj[key];\n      if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n        queue.push({ obj: obj, prop: key });\n        refs.push(val);\n      }\n    }\n  }\n\n  compact_queue(queue);\n\n  return value;\n}\n\nexport function is_regexp(obj: any) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nexport function is_buffer(obj: any) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n}\n\nexport function combine(a: any, b: any) {\n  return [].concat(a, b);\n}\n\nexport function maybe_map<T>(val: T[], fn: (v: T) => T) {\n  if (is_array(val)) {\n    const mapped = [];\n    for (let i = 0; i < val.length; i += 1) {\n      mapped.push(fn(val[i]!));\n    }\n    return mapped;\n  }\n  return fn(val);\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CursorPage = exports.Page = void 0;\nconst core_1 = require(\"./core.js\");\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nclass Page extends core_1.AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.object = body.object;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    /**\n     * This page represents a response that isn't actually paginated at the API level\n     * so there will never be any next page params.\n     */\n    nextPageParams() {\n        return null;\n    }\n    nextPageInfo() {\n        return null;\n    }\n}\nexports.Page = Page;\nclass CursorPage extends core_1.AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    // @deprecated Please use `nextPageInfo()` instead\n    nextPageParams() {\n        const info = this.nextPageInfo();\n        if (!info)\n            return null;\n        if ('params' in info)\n            return info.params;\n        const params = Object.fromEntries(info.url.searchParams);\n        if (!Object.keys(params).length)\n            return null;\n        return params;\n    }\n    nextPageInfo() {\n        const data = this.getPaginatedItems();\n        if (!data.length) {\n            return null;\n        }\n        const id = data[data.length - 1]?.id;\n        if (!id) {\n            return null;\n        }\n        return { params: { after: id } };\n    }\n}\nexports.CursorPage = CursorPage;\n//# sourceMappingURL=pagination.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { AbstractPage, Response, APIClient, FinalRequestOptions, PageInfo } from './core';\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n}\n\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page<Item> extends AbstractPage<Item> implements PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n\n  constructor(client: APIClient, response: Response, body: PageResponse<Item>, options: FinalRequestOptions) {\n    super(client, response, body, options);\n\n    this.data = body.data || [];\n    this.object = body.object;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  // @deprecated Please use `nextPageInfo()` instead\n  /**\n   * This page represents a response that isn't actually paginated at the API level\n   * so there will never be any next page params.\n   */\n  nextPageParams(): null {\n    return null;\n  }\n\n  nextPageInfo(): null {\n    return null;\n  }\n}\n\nexport interface CursorPageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageParams {\n  after?: string;\n\n  limit?: number;\n}\n\nexport class CursorPage<Item extends { id: string }>\n  extends AbstractPage<Item>\n  implements CursorPageResponse<Item>\n{\n  data: Array<Item>;\n\n  constructor(\n    client: APIClient,\n    response: Response,\n    body: CursorPageResponse<Item>,\n    options: FinalRequestOptions,\n  ) {\n    super(client, response, body, options);\n\n    this.data = body.data || [];\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  // @deprecated Please use `nextPageInfo()` instead\n  nextPageParams(): Partial<CursorPageParams> | null {\n    const info = this.nextPageInfo();\n    if (!info) return null;\n    if ('params' in info) return info.params;\n    const params = Object.fromEntries(info.url.searchParams);\n    if (!Object.keys(params).length) return null;\n    return params;\n  }\n\n  nextPageInfo(): PageInfo | null {\n    const data = this.getPaginatedItems();\n    if (!data.length) {\n      return null;\n    }\n\n    const id = data[data.length - 1]?.id;\n    if (!id) {\n      return null;\n    }\n\n    return { params: { after: id } };\n  }\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Uploads = exports.Moderations = exports.Models = exports.ModelsPage = exports.Images = exports.FineTuning = exports.Files = exports.FileObjectsPage = exports.Embeddings = exports.Completions = exports.Beta = exports.Batches = exports.BatchesPage = exports.Audio = void 0;\n__exportStar(require(\"./chat/index.js\"), exports);\n__exportStar(require(\"./shared.js\"), exports);\nvar audio_1 = require(\"./audio/audio.js\");\nObject.defineProperty(exports, \"Audio\", { enumerable: true, get: function () { return audio_1.Audio; } });\nvar batches_1 = require(\"./batches.js\");\nObject.defineProperty(exports, \"BatchesPage\", { enumerable: true, get: function () { return batches_1.BatchesPage; } });\nObject.defineProperty(exports, \"Batches\", { enumerable: true, get: function () { return batches_1.Batches; } });\nvar beta_1 = require(\"./beta/beta.js\");\nObject.defineProperty(exports, \"Beta\", { enumerable: true, get: function () { return beta_1.Beta; } });\nvar completions_1 = require(\"./completions.js\");\nObject.defineProperty(exports, \"Completions\", { enumerable: true, get: function () { return completions_1.Completions; } });\nvar embeddings_1 = require(\"./embeddings.js\");\nObject.defineProperty(exports, \"Embeddings\", { enumerable: true, get: function () { return embeddings_1.Embeddings; } });\nvar files_1 = require(\"./files.js\");\nObject.defineProperty(exports, \"FileObjectsPage\", { enumerable: true, get: function () { return files_1.FileObjectsPage; } });\nObject.defineProperty(exports, \"Files\", { enumerable: true, get: function () { return files_1.Files; } });\nvar fine_tuning_1 = require(\"./fine-tuning/fine-tuning.js\");\nObject.defineProperty(exports, \"FineTuning\", { enumerable: true, get: function () { return fine_tuning_1.FineTuning; } });\nvar images_1 = require(\"./images.js\");\nObject.defineProperty(exports, \"Images\", { enumerable: true, get: function () { return images_1.Images; } });\nvar models_1 = require(\"./models.js\");\nObject.defineProperty(exports, \"ModelsPage\", { enumerable: true, get: function () { return models_1.ModelsPage; } });\nObject.defineProperty(exports, \"Models\", { enumerable: true, get: function () { return models_1.Models; } });\nvar moderations_1 = require(\"./moderations.js\");\nObject.defineProperty(exports, \"Moderations\", { enumerable: true, get: function () { return moderations_1.Moderations; } });\nvar uploads_1 = require(\"./uploads/uploads.js\");\nObject.defineProperty(exports, \"Uploads\", { enumerable: true, get: function () { return uploads_1.Uploads; } });\n//# sourceMappingURL=index.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nexport * from './chat/index';\nexport * from './shared';\nexport { AudioModel, AudioResponseFormat, Audio } from './audio/audio';\nexport {\n  Batch,\n  BatchError,\n  BatchRequestCounts,\n  BatchCreateParams,\n  BatchListParams,\n  BatchesPage,\n  Batches,\n} from './batches';\nexport { Beta } from './beta/beta';\nexport {\n  Completion,\n  CompletionChoice,\n  CompletionUsage,\n  CompletionCreateParams,\n  CompletionCreateParamsNonStreaming,\n  CompletionCreateParamsStreaming,\n  Completions,\n} from './completions';\nexport {\n  CreateEmbeddingResponse,\n  Embedding,\n  EmbeddingModel,\n  EmbeddingCreateParams,\n  Embeddings,\n} from './embeddings';\nexport {\n  FileContent,\n  FileDeleted,\n  FileObject,\n  FilePurpose,\n  FileCreateParams,\n  FileListParams,\n  FileObjectsPage,\n  Files,\n} from './files';\nexport { FineTuning } from './fine-tuning/fine-tuning';\nexport {\n  Image,\n  ImageModel,\n  ImagesResponse,\n  ImageCreateVariationParams,\n  ImageEditParams,\n  ImageGenerateParams,\n  Images,\n} from './images';\nexport { Model, ModelDeleted, ModelsPage, Models } from './models';\nexport {\n  Moderation,\n  ModerationImageURLInput,\n  ModerationModel,\n  ModerationMultiModalInput,\n  ModerationTextInput,\n  ModerationCreateResponse,\n  ModerationCreateParams,\n  Moderations,\n} from './moderations';\nexport { Upload, UploadCreateParams, UploadCompleteParams, Uploads } from './uploads/uploads';\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chat = exports.Completions = void 0;\nvar completions_1 = require(\"./completions.js\");\nObject.defineProperty(exports, \"Completions\", { enumerable: true, get: function () { return completions_1.Completions; } });\nvar chat_1 = require(\"./chat.js\");\nObject.defineProperty(exports, \"Chat\", { enumerable: true, get: function () { return chat_1.Chat; } });\n//# sourceMappingURL=index.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nexport {\n  ChatCompletion,\n  ChatCompletionAssistantMessageParam,\n  ChatCompletionChunk,\n  ChatCompletionContentPart,\n  ChatCompletionContentPartImage,\n  ChatCompletionContentPartRefusal,\n  ChatCompletionContentPartText,\n  ChatCompletionFunctionCallOption,\n  ChatCompletionFunctionMessageParam,\n  ChatCompletionMessage,\n  ChatCompletionMessageParam,\n  ChatCompletionMessageToolCall,\n  ChatCompletionNamedToolChoice,\n  ChatCompletionRole,\n  ChatCompletionStreamOptions,\n  ChatCompletionSystemMessageParam,\n  ChatCompletionTokenLogprob,\n  ChatCompletionTool,\n  ChatCompletionToolChoiceOption,\n  ChatCompletionToolMessageParam,\n  ChatCompletionUserMessageParam,\n  CreateChatCompletionRequestMessage,\n  ChatCompletionCreateParams,\n  CompletionCreateParams,\n  ChatCompletionCreateParamsNonStreaming,\n  CompletionCreateParamsNonStreaming,\n  ChatCompletionCreateParamsStreaming,\n  CompletionCreateParamsStreaming,\n  Completions,\n} from './completions';\nexport { ChatModel, Chat } from './chat';\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Completions = void 0;\nconst resource_1 = require(\"../../resource.js\");\nclass Completions extends resource_1.APIResource {\n    create(body, options) {\n        return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false });\n    }\n}\nexports.Completions = Completions;\n(function (Completions) {\n})(Completions = exports.Completions || (exports.Completions = {}));\n//# sourceMappingURL=completions.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport { APIPromise } from '../../core';\nimport * as Core from '../../core';\nimport * as ChatCompletionsAPI from './completions';\nimport * as CompletionsAPI from '../completions';\nimport * as Shared from '../shared';\nimport * as ChatAPI from './chat';\nimport { Stream } from '../../streaming';\n\nexport class Completions extends APIResource {\n  /**\n   * Creates a model response for the given chat conversation.\n   */\n  create(\n    body: ChatCompletionCreateParamsNonStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<ChatCompletion>;\n  create(\n    body: ChatCompletionCreateParamsStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<ChatCompletionChunk>>;\n  create(\n    body: ChatCompletionCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<ChatCompletionChunk> | ChatCompletion>;\n  create(\n    body: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): APIPromise<ChatCompletion> | APIPromise<Stream<ChatCompletionChunk>> {\n    return this._client.post('/chat/completions', { body, ...options, stream: body.stream ?? false }) as\n      | APIPromise<ChatCompletion>\n      | APIPromise<Stream<ChatCompletionChunk>>;\n  }\n}\n\n/**\n * Represents a chat completion response returned by model, based on the provided\n * input.\n */\nexport interface ChatCompletion {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletion.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model used for the chat completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always `chat.completion`.\n   */\n  object: 'chat.completion';\n\n  /**\n   * The service tier used for processing the request. This field is only included if\n   * the `service_tier` parameter is specified in the request.\n   */\n  service_tier?: 'scale' | 'default' | null;\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n\n  /**\n   * Usage statistics for the completion request.\n   */\n  usage?: CompletionsAPI.CompletionUsage;\n}\n\nexport namespace ChatCompletion {\n  export interface Choice {\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, `tool_calls` if the\n     * model called a tool, or `function_call` (deprecated) if the model called a\n     * function.\n     */\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: Choice.Logprobs | null;\n\n    /**\n     * A chat completion message generated by the model.\n     */\n    message: ChatCompletionsAPI.ChatCompletionMessage;\n  }\n\n  export namespace Choice {\n    /**\n     * Log probability information for the choice.\n     */\n    export interface Logprobs {\n      /**\n       * A list of message content tokens with log probability information.\n       */\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n\n      /**\n       * A list of message refusal tokens with log probability information.\n       */\n      refusal: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n    }\n  }\n}\n\nexport interface ChatCompletionAssistantMessageParam {\n  /**\n   * The role of the messages author, in this case `assistant`.\n   */\n  role: 'assistant';\n\n  /**\n   * The contents of the assistant message. Required unless `tool_calls` or\n   * `function_call` is specified.\n   */\n  content?: string | Array<ChatCompletionContentPartText | ChatCompletionContentPartRefusal> | null;\n\n  /**\n   * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n   * a function that should be called, as generated by the model.\n   */\n  function_call?: ChatCompletionAssistantMessageParam.FunctionCall | null;\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n\n  /**\n   * The refusal message by the assistant.\n   */\n  refusal?: string | null;\n\n  /**\n   * The tool calls generated by the model, such as function calls.\n   */\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\n}\n\nexport namespace ChatCompletionAssistantMessageParam {\n  /**\n   * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n   * a function that should be called, as generated by the model.\n   */\n  export interface FunctionCall {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionChunk {\n  /**\n   * A unique identifier for the chat completion. Each chunk has the same ID.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can contain more than one elements if `n` is\n   * greater than 1. Can also be empty for the last chunk if you set\n   * `stream_options: {\"include_usage\": true}`.\n   */\n  choices: Array<ChatCompletionChunk.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created. Each\n   * chunk has the same timestamp.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always `chat.completion.chunk`.\n   */\n  object: 'chat.completion.chunk';\n\n  /**\n   * The service tier used for processing the request. This field is only included if\n   * the `service_tier` parameter is specified in the request.\n   */\n  service_tier?: 'scale' | 'default' | null;\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n\n  /**\n   * An optional field that will only be present when you set\n   * `stream_options: {\"include_usage\": true}` in your request. When present, it\n   * contains a null value except for the last chunk which contains the token usage\n   * statistics for the entire request.\n   */\n  usage?: CompletionsAPI.CompletionUsage;\n}\n\nexport namespace ChatCompletionChunk {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    delta: Choice.Delta;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, `tool_calls` if the\n     * model called a tool, or `function_call` (deprecated) if the model called a\n     * function.\n     */\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call' | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs?: Choice.Logprobs | null;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Delta {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n       * a function that should be called, as generated by the model.\n       */\n      function_call?: Delta.FunctionCall;\n\n      /**\n       * The refusal message generated by the model.\n       */\n      refusal?: string | null;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'tool';\n\n      tool_calls?: Array<Delta.ToolCall>;\n    }\n\n    export namespace Delta {\n      /**\n       * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n       * a function that should be called, as generated by the model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n\n      export interface ToolCall {\n        index: number;\n\n        /**\n         * The ID of the tool call.\n         */\n        id?: string;\n\n        function?: ToolCall.Function;\n\n        /**\n         * The type of the tool. Currently, only `function` is supported.\n         */\n        type?: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments?: string;\n\n          /**\n           * The name of the function to call.\n           */\n          name?: string;\n        }\n      }\n    }\n\n    /**\n     * Log probability information for the choice.\n     */\n    export interface Logprobs {\n      /**\n       * A list of message content tokens with log probability information.\n       */\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n\n      /**\n       * A list of message refusal tokens with log probability information.\n       */\n      refusal: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n    }\n  }\n}\n\nexport type ChatCompletionContentPart = ChatCompletionContentPartText | ChatCompletionContentPartImage;\n\nexport interface ChatCompletionContentPartImage {\n  image_url: ChatCompletionContentPartImage.ImageURL;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'image_url';\n}\n\nexport namespace ChatCompletionContentPartImage {\n  export interface ImageURL {\n    /**\n     * Either a URL of the image or the base64 encoded image data.\n     */\n    url: string;\n\n    /**\n     * Specifies the detail level of the image. Learn more in the\n     * [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).\n     */\n    detail?: 'auto' | 'low' | 'high';\n  }\n}\n\nexport interface ChatCompletionContentPartRefusal {\n  /**\n   * The refusal message generated by the model.\n   */\n  refusal: string;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'refusal';\n}\n\nexport interface ChatCompletionContentPartText {\n  /**\n   * The text content.\n   */\n  text: string;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'text';\n}\n\n/**\n * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model\n * to call that function.\n */\nexport interface ChatCompletionFunctionCallOption {\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\n/**\n * @deprecated\n */\nexport interface ChatCompletionFunctionMessageParam {\n  /**\n   * The contents of the function message.\n   */\n  content: string | null;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n\n  /**\n   * The role of the messages author, in this case `function`.\n   */\n  role: 'function';\n}\n\n/**\n * A chat completion message generated by the model.\n */\nexport interface ChatCompletionMessage {\n  /**\n   * The contents of the message.\n   */\n  content: string | null;\n\n  /**\n   * The refusal message generated by the model.\n   */\n  refusal: string | null;\n\n  /**\n   * The role of the author of this message.\n   */\n  role: 'assistant';\n\n  /**\n   * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n   * a function that should be called, as generated by the model.\n   */\n  function_call?: ChatCompletionMessage.FunctionCall | null;\n\n  /**\n   * The tool calls generated by the model, such as function calls.\n   */\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\n}\n\nexport namespace ChatCompletionMessage {\n  /**\n   * @deprecated: Deprecated and replaced by `tool_calls`. The name and arguments of\n   * a function that should be called, as generated by the model.\n   */\n  export interface FunctionCall {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\nexport type ChatCompletionMessageParam =\n  | ChatCompletionSystemMessageParam\n  | ChatCompletionUserMessageParam\n  | ChatCompletionAssistantMessageParam\n  | ChatCompletionToolMessageParam\n  | ChatCompletionFunctionMessageParam;\n\nexport interface ChatCompletionMessageToolCall {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: ChatCompletionMessageToolCall.Function;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\nexport namespace ChatCompletionMessageToolCall {\n  /**\n   * The function that the model called.\n   */\n  export interface Function {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\n/**\n * Specifies a tool the model should use. Use to force the model to call a specific\n * function.\n */\nexport interface ChatCompletionNamedToolChoice {\n  function: ChatCompletionNamedToolChoice.Function;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\nexport namespace ChatCompletionNamedToolChoice {\n  export interface Function {\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\n/**\n * The role of the author of a message\n */\nexport type ChatCompletionRole = 'system' | 'user' | 'assistant' | 'tool' | 'function';\n\n/**\n * Options for streaming response. Only set this when you set `stream: true`.\n */\nexport interface ChatCompletionStreamOptions {\n  /**\n   * If set, an additional chunk will be streamed before the `data: [DONE]` message.\n   * The `usage` field on this chunk shows the token usage statistics for the entire\n   * request, and the `choices` field will always be an empty array. All other chunks\n   * will also include a `usage` field, but with a null value.\n   */\n  include_usage?: boolean;\n}\n\nexport interface ChatCompletionSystemMessageParam {\n  /**\n   * The contents of the system message.\n   */\n  content: string | Array<ChatCompletionContentPartText>;\n\n  /**\n   * The role of the messages author, in this case `system`.\n   */\n  role: 'system';\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n}\n\nexport interface ChatCompletionTokenLogprob {\n  /**\n   * The token.\n   */\n  token: string;\n\n  /**\n   * A list of integers representing the UTF-8 bytes representation of the token.\n   * Useful in instances where characters are represented by multiple tokens and\n   * their byte representations must be combined to generate the correct text\n   * representation. Can be `null` if there is no bytes representation for the token.\n   */\n  bytes: Array<number> | null;\n\n  /**\n   * The log probability of this token, if it is within the top 20 most likely\n   * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\n   * unlikely.\n   */\n  logprob: number;\n\n  /**\n   * List of the most likely tokens and their log probability, at this token\n   * position. In rare cases, there may be fewer than the number of requested\n   * `top_logprobs` returned.\n   */\n  top_logprobs: Array<ChatCompletionTokenLogprob.TopLogprob>;\n}\n\nexport namespace ChatCompletionTokenLogprob {\n  export interface TopLogprob {\n    /**\n     * The token.\n     */\n    token: string;\n\n    /**\n     * A list of integers representing the UTF-8 bytes representation of the token.\n     * Useful in instances where characters are represented by multiple tokens and\n     * their byte representations must be combined to generate the correct text\n     * representation. Can be `null` if there is no bytes representation for the token.\n     */\n    bytes: Array<number> | null;\n\n    /**\n     * The log probability of this token, if it is within the top 20 most likely\n     * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\n     * unlikely.\n     */\n    logprob: number;\n  }\n}\n\nexport interface ChatCompletionTool {\n  function: Shared.FunctionDefinition;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\n/**\n * Controls which (if any) tool is called by the model. `none` means the model will\n * not call any tool and instead generates a message. `auto` means the model can\n * pick between generating a message or calling one or more tools. `required` means\n * the model must call one or more tools. Specifying a particular tool via\n * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n * call that tool.\n *\n * `none` is the default when no tools are present. `auto` is the default if tools\n * are present.\n */\nexport type ChatCompletionToolChoiceOption = 'none' | 'auto' | 'required' | ChatCompletionNamedToolChoice;\n\nexport interface ChatCompletionToolMessageParam {\n  /**\n   * The contents of the tool message.\n   */\n  content: string | Array<ChatCompletionContentPartText>;\n\n  /**\n   * The role of the messages author, in this case `tool`.\n   */\n  role: 'tool';\n\n  /**\n   * Tool call that this message is responding to.\n   */\n  tool_call_id: string;\n}\n\nexport interface ChatCompletionUserMessageParam {\n  /**\n   * The contents of the user message.\n   */\n  content: string | Array<ChatCompletionContentPart>;\n\n  /**\n   * The role of the messages author, in this case `user`.\n   */\n  role: 'user';\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n}\n\n/**\n * @deprecated ChatCompletionMessageParam should be used instead\n */\nexport type CreateChatCompletionRequestMessage = ChatCompletionMessageParam;\n\nexport type ChatCompletionCreateParams =\n  | ChatCompletionCreateParamsNonStreaming\n  | ChatCompletionCreateParamsStreaming;\n\nexport interface ChatCompletionCreateParamsBase {\n  /**\n   * A list of messages comprising the conversation so far.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).\n   */\n  messages: Array<ChatCompletionMessageParam>;\n\n  /**\n   * ID of the model to use. See the\n   * [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility)\n   * table for details on which models work with the Chat API.\n   */\n  model: (string & {}) | ChatAPI.ChatModel;\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their\n   * existing frequency in the text so far, decreasing the model's likelihood to\n   * repeat the same line verbatim.\n   *\n   * [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)\n   */\n  frequency_penalty?: number | null;\n\n  /**\n   * Deprecated in favor of `tool_choice`.\n   *\n   * Controls which (if any) function is called by the model. `none` means the model\n   * will not call a function and instead generates a message. `auto` means the model\n   * can pick between generating a message or calling a function. Specifying a\n   * particular function via `{\"name\": \"my_function\"}` forces the model to call that\n   * function.\n   *\n   * `none` is the default when no functions are present. `auto` is the default if\n   * functions are present.\n   */\n  function_call?: 'none' | 'auto' | ChatCompletionFunctionCallOption;\n\n  /**\n   * Deprecated in favor of `tools`.\n   *\n   * A list of functions the model may generate JSON inputs for.\n   */\n  functions?: Array<ChatCompletionCreateParams.Function>;\n\n  /**\n   * Modify the likelihood of specified tokens appearing in the completion.\n   *\n   * Accepts a JSON object that maps tokens (specified by their token ID in the\n   * tokenizer) to an associated bias value from -100 to 100. Mathematically, the\n   * bias is added to the logits generated by the model prior to sampling. The exact\n   * effect will vary per model, but values between -1 and 1 should decrease or\n   * increase likelihood of selection; values like -100 or 100 should result in a ban\n   * or exclusive selection of the relevant token.\n   */\n  logit_bias?: Record<string, number> | null;\n\n  /**\n   * Whether to return log probabilities of the output tokens or not. If true,\n   * returns the log probabilities of each output token returned in the `content` of\n   * `message`.\n   */\n  logprobs?: boolean | null;\n\n  /**\n   * An upper bound for the number of tokens that can be generated for a completion,\n   * including visible output tokens and\n   * [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of [tokens](/tokenizer) that can be generated in the chat\n   * completion. This value can be used to control\n   * [costs](https://openai.com/api/pricing/) for text generated via API.\n   *\n   * This value is now deprecated in favor of `max_completion_tokens`, and is not\n   * compatible with\n   * [o1 series models](https://platform.openai.com/docs/guides/reasoning).\n   */\n  max_tokens?: number | null;\n\n  /**\n   * How many chat completion choices to generate for each input message. Note that\n   * you will be charged based on the number of generated tokens across all of the\n   * choices. Keep `n` as `1` to minimize costs.\n   */\n  n?: number | null;\n\n  /**\n   * Whether to enable\n   * [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)\n   * during tool use.\n   */\n  parallel_tool_calls?: boolean;\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on\n   * whether they appear in the text so far, increasing the model's likelihood to\n   * talk about new topics.\n   *\n   * [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)\n   */\n  presence_penalty?: number | null;\n\n  /**\n   * An object specifying the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4o mini](https://platform.openai.com/docs/models/gpt-4o-mini),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and\n   * all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?:\n    | Shared.ResponseFormatText\n    | Shared.ResponseFormatJSONObject\n    | Shared.ResponseFormatJSONSchema;\n\n  /**\n   * This feature is in Beta. If specified, our system will make a best effort to\n   * sample deterministically, such that repeated requests with the same `seed` and\n   * parameters should return the same result. Determinism is not guaranteed, and you\n   * should refer to the `system_fingerprint` response parameter to monitor changes\n   * in the backend.\n   */\n  seed?: number | null;\n\n  /**\n   * Specifies the latency tier to use for processing the request. This parameter is\n   * relevant for customers subscribed to the scale tier service:\n   *\n   * - If set to 'auto', and the Project is Scale tier enabled, the system will\n   *   utilize scale tier credits until they are exhausted.\n   * - If set to 'auto', and the Project is not Scale tier enabled, the request will\n   *   be processed using the default service tier with a lower uptime SLA and no\n   *   latency guarentee.\n   * - If set to 'default', the request will be processed using the default service\n   *   tier with a lower uptime SLA and no latency guarentee.\n   * - When not set, the default behavior is 'auto'.\n   *\n   * When this parameter is set, the response body will include the `service_tier`\n   * utilized.\n   */\n  service_tier?: 'auto' | 'default' | null;\n\n  /**\n   * Up to 4 sequences where the API will stop generating further tokens.\n   */\n  stop?: string | null | Array<string>;\n\n  /**\n   * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be\n   * sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream?: boolean | null;\n\n  /**\n   * Options for streaming response. Only set this when you set `stream: true`.\n   */\n  stream_options?: ChatCompletionStreamOptions | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   *\n   * We generally recommend altering this or `top_p` but not both.\n   */\n  temperature?: number | null;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tool and instead generates a message. `auto` means the model can\n   * pick between generating a message or calling one or more tools. `required` means\n   * the model must call one or more tools. Specifying a particular tool via\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   *\n   * `none` is the default when no tools are present. `auto` is the default if tools\n   * are present.\n   */\n  tool_choice?: ChatCompletionToolChoiceOption;\n\n  /**\n   * A list of tools the model may call. Currently, only functions are supported as a\n   * tool. Use this to provide a list of functions the model may generate JSON inputs\n   * for. A max of 128 functions are supported.\n   */\n  tools?: Array<ChatCompletionTool>;\n\n  /**\n   * An integer between 0 and 20 specifying the number of most likely tokens to\n   * return at each token position, each with an associated log probability.\n   * `logprobs` must be set to `true` if this parameter is used.\n   */\n  top_logprobs?: number | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or `temperature` but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport namespace ChatCompletionCreateParams {\n  /**\n   * @deprecated\n   */\n  export interface Function {\n    /**\n     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n     * underscores and dashes, with a maximum length of 64.\n     */\n    name: string;\n\n    /**\n     * A description of what the function does, used by the model to choose when and\n     * how to call the function.\n     */\n    description?: string;\n\n    /**\n     * The parameters the functions accepts, described as a JSON Schema object. See the\n     * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,\n     * and the\n     * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n     * documentation about the format.\n     *\n     * Omitting `parameters` defines a function with an empty parameter list.\n     */\n    parameters?: Shared.FunctionParameters;\n  }\n\n  export type ChatCompletionCreateParamsNonStreaming =\n    ChatCompletionsAPI.ChatCompletionCreateParamsNonStreaming;\n  export type ChatCompletionCreateParamsStreaming = ChatCompletionsAPI.ChatCompletionCreateParamsStreaming;\n}\n\n/**\n * @deprecated Use ChatCompletionCreateParams instead\n */\nexport type CompletionCreateParams = ChatCompletionCreateParams;\n\nexport interface ChatCompletionCreateParamsNonStreaming extends ChatCompletionCreateParamsBase {\n  /**\n   * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be\n   * sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream?: false | null;\n}\n\n/**\n * @deprecated Use ChatCompletionCreateParamsNonStreaming instead\n */\nexport type CompletionCreateParamsNonStreaming = ChatCompletionCreateParamsNonStreaming;\n\nexport interface ChatCompletionCreateParamsStreaming extends ChatCompletionCreateParamsBase {\n  /**\n   * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be\n   * sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream: true;\n}\n\n/**\n * @deprecated Use ChatCompletionCreateParamsStreaming instead\n */\nexport type CompletionCreateParamsStreaming = ChatCompletionCreateParamsStreaming;\n\nexport namespace Completions {\n  export import ChatCompletion = ChatCompletionsAPI.ChatCompletion;\n  export import ChatCompletionAssistantMessageParam = ChatCompletionsAPI.ChatCompletionAssistantMessageParam;\n  export import ChatCompletionChunk = ChatCompletionsAPI.ChatCompletionChunk;\n  export import ChatCompletionContentPart = ChatCompletionsAPI.ChatCompletionContentPart;\n  export import ChatCompletionContentPartImage = ChatCompletionsAPI.ChatCompletionContentPartImage;\n  export import ChatCompletionContentPartRefusal = ChatCompletionsAPI.ChatCompletionContentPartRefusal;\n  export import ChatCompletionContentPartText = ChatCompletionsAPI.ChatCompletionContentPartText;\n  export import ChatCompletionFunctionCallOption = ChatCompletionsAPI.ChatCompletionFunctionCallOption;\n  export import ChatCompletionFunctionMessageParam = ChatCompletionsAPI.ChatCompletionFunctionMessageParam;\n  export import ChatCompletionMessage = ChatCompletionsAPI.ChatCompletionMessage;\n  export import ChatCompletionMessageParam = ChatCompletionsAPI.ChatCompletionMessageParam;\n  export import ChatCompletionMessageToolCall = ChatCompletionsAPI.ChatCompletionMessageToolCall;\n  export import ChatCompletionNamedToolChoice = ChatCompletionsAPI.ChatCompletionNamedToolChoice;\n  export import ChatCompletionRole = ChatCompletionsAPI.ChatCompletionRole;\n  export import ChatCompletionStreamOptions = ChatCompletionsAPI.ChatCompletionStreamOptions;\n  export import ChatCompletionSystemMessageParam = ChatCompletionsAPI.ChatCompletionSystemMessageParam;\n  export import ChatCompletionTokenLogprob = ChatCompletionsAPI.ChatCompletionTokenLogprob;\n  export import ChatCompletionTool = ChatCompletionsAPI.ChatCompletionTool;\n  export import ChatCompletionToolChoiceOption = ChatCompletionsAPI.ChatCompletionToolChoiceOption;\n  export import ChatCompletionToolMessageParam = ChatCompletionsAPI.ChatCompletionToolMessageParam;\n  export import ChatCompletionUserMessageParam = ChatCompletionsAPI.ChatCompletionUserMessageParam;\n  /**\n   * @deprecated ChatCompletionMessageParam should be used instead\n   */\n  export import CreateChatCompletionRequestMessage = ChatCompletionsAPI.CreateChatCompletionRequestMessage;\n  export import ChatCompletionCreateParams = ChatCompletionsAPI.ChatCompletionCreateParams;\n  export import CompletionCreateParams = ChatCompletionsAPI.CompletionCreateParams;\n  export import ChatCompletionCreateParamsNonStreaming = ChatCompletionsAPI.ChatCompletionCreateParamsNonStreaming;\n  export import CompletionCreateParamsNonStreaming = ChatCompletionsAPI.CompletionCreateParamsNonStreaming;\n  export import ChatCompletionCreateParamsStreaming = ChatCompletionsAPI.ChatCompletionCreateParamsStreaming;\n  export import CompletionCreateParamsStreaming = ChatCompletionsAPI.CompletionCreateParamsStreaming;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APIResource = void 0;\nclass APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\nexports.APIResource = APIResource;\n//# sourceMappingURL=resource.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport type { OpenAI } from './index';\n\nexport class APIResource {\n  protected _client: OpenAI;\n\n  constructor(client: OpenAI) {\n    this._client = client;\n  }\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chat = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst CompletionsAPI = __importStar(require(\"./completions.js\"));\nclass Chat extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\nexports.Chat = Chat;\n(function (Chat) {\n    Chat.Completions = CompletionsAPI.Completions;\n})(Chat = exports.Chat || (exports.Chat = {}));\n//# sourceMappingURL=chat.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as ChatAPI from './chat';\nimport * as CompletionsAPI from './completions';\n\nexport class Chat extends APIResource {\n  completions: CompletionsAPI.Completions = new CompletionsAPI.Completions(this._client);\n}\n\nexport type ChatModel =\n  | 'o1-preview'\n  | 'o1-preview-2024-09-12'\n  | 'o1-mini'\n  | 'o1-mini-2024-09-12'\n  | 'gpt-4o'\n  | 'gpt-4o-2024-08-06'\n  | 'gpt-4o-2024-05-13'\n  | 'chatgpt-4o-latest'\n  | 'gpt-4o-mini'\n  | 'gpt-4o-mini-2024-07-18'\n  | 'gpt-4-turbo'\n  | 'gpt-4-turbo-2024-04-09'\n  | 'gpt-4-0125-preview'\n  | 'gpt-4-turbo-preview'\n  | 'gpt-4-1106-preview'\n  | 'gpt-4-vision-preview'\n  | 'gpt-4'\n  | 'gpt-4-0314'\n  | 'gpt-4-0613'\n  | 'gpt-4-32k'\n  | 'gpt-4-32k-0314'\n  | 'gpt-4-32k-0613'\n  | 'gpt-3.5-turbo'\n  | 'gpt-3.5-turbo-16k'\n  | 'gpt-3.5-turbo-0301'\n  | 'gpt-3.5-turbo-0613'\n  | 'gpt-3.5-turbo-1106'\n  | 'gpt-3.5-turbo-0125'\n  | 'gpt-3.5-turbo-16k-0613';\n\nexport namespace Chat {\n  export import ChatModel = ChatAPI.ChatModel;\n  export import Completions = CompletionsAPI.Completions;\n  export import ChatCompletion = CompletionsAPI.ChatCompletion;\n  export import ChatCompletionAssistantMessageParam = CompletionsAPI.ChatCompletionAssistantMessageParam;\n  export import ChatCompletionChunk = CompletionsAPI.ChatCompletionChunk;\n  export import ChatCompletionContentPart = CompletionsAPI.ChatCompletionContentPart;\n  export import ChatCompletionContentPartImage = CompletionsAPI.ChatCompletionContentPartImage;\n  export import ChatCompletionContentPartRefusal = CompletionsAPI.ChatCompletionContentPartRefusal;\n  export import ChatCompletionContentPartText = CompletionsAPI.ChatCompletionContentPartText;\n  export import ChatCompletionFunctionCallOption = CompletionsAPI.ChatCompletionFunctionCallOption;\n  export import ChatCompletionFunctionMessageParam = CompletionsAPI.ChatCompletionFunctionMessageParam;\n  export import ChatCompletionMessage = CompletionsAPI.ChatCompletionMessage;\n  export import ChatCompletionMessageParam = CompletionsAPI.ChatCompletionMessageParam;\n  export import ChatCompletionMessageToolCall = CompletionsAPI.ChatCompletionMessageToolCall;\n  export import ChatCompletionNamedToolChoice = CompletionsAPI.ChatCompletionNamedToolChoice;\n  export import ChatCompletionRole = CompletionsAPI.ChatCompletionRole;\n  export import ChatCompletionStreamOptions = CompletionsAPI.ChatCompletionStreamOptions;\n  export import ChatCompletionSystemMessageParam = CompletionsAPI.ChatCompletionSystemMessageParam;\n  export import ChatCompletionTokenLogprob = CompletionsAPI.ChatCompletionTokenLogprob;\n  export import ChatCompletionTool = CompletionsAPI.ChatCompletionTool;\n  export import ChatCompletionToolChoiceOption = CompletionsAPI.ChatCompletionToolChoiceOption;\n  export import ChatCompletionToolMessageParam = CompletionsAPI.ChatCompletionToolMessageParam;\n  export import ChatCompletionUserMessageParam = CompletionsAPI.ChatCompletionUserMessageParam;\n  /**\n   * @deprecated ChatCompletionMessageParam should be used instead\n   */\n  export import CreateChatCompletionRequestMessage = CompletionsAPI.CreateChatCompletionRequestMessage;\n  export import ChatCompletionCreateParams = CompletionsAPI.ChatCompletionCreateParams;\n  export import CompletionCreateParams = CompletionsAPI.CompletionCreateParams;\n  export import ChatCompletionCreateParamsNonStreaming = CompletionsAPI.ChatCompletionCreateParamsNonStreaming;\n  export import CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\n  export import ChatCompletionCreateParamsStreaming = CompletionsAPI.ChatCompletionCreateParamsStreaming;\n  export import CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=shared.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nexport interface ErrorObject {\n  code: string | null;\n\n  message: string;\n\n  param: string | null;\n\n  type: string;\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,\n   * and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * Omitting `parameters` defines a function with an empty parameter list.\n   */\n  parameters?: FunctionParameters;\n\n  /**\n   * Whether to enable strict schema adherence when generating the function call. If\n   * set to true, the model will follow the exact schema defined in the `parameters`\n   * field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn\n   * more about Structured Outputs in the\n   * [function calling guide](docs/guides/function-calling).\n   */\n  strict?: boolean | null;\n}\n\n/**\n * The parameters the functions accepts, described as a JSON Schema object. See the\n * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,\n * and the\n * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n * documentation about the format.\n *\n * Omitting `parameters` defines a function with an empty parameter list.\n */\nexport type FunctionParameters = Record<string, unknown>;\n\nexport interface ResponseFormatJSONObject {\n  /**\n   * The type of response format being defined: `json_object`\n   */\n  type: 'json_object';\n}\n\nexport interface ResponseFormatJSONSchema {\n  json_schema: ResponseFormatJSONSchema.JSONSchema;\n\n  /**\n   * The type of response format being defined: `json_schema`\n   */\n  type: 'json_schema';\n}\n\nexport namespace ResponseFormatJSONSchema {\n  export interface JSONSchema {\n    /**\n     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores\n     * and dashes, with a maximum length of 64.\n     */\n    name: string;\n\n    /**\n     * A description of what the response format is for, used by the model to determine\n     * how to respond in the format.\n     */\n    description?: string;\n\n    /**\n     * The schema for the response format, described as a JSON Schema object.\n     */\n    schema?: Record<string, unknown>;\n\n    /**\n     * Whether to enable strict schema adherence when generating the output. If set to\n     * true, the model will always follow the exact schema defined in the `schema`\n     * field. Only a subset of JSON Schema is supported when `strict` is `true`. To\n     * learn more, read the\n     * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n     */\n    strict?: boolean | null;\n  }\n}\n\nexport interface ResponseFormatText {\n  /**\n   * The type of response format being defined: `text`\n   */\n  type: 'text';\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Audio = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst SpeechAPI = __importStar(require(\"./speech.js\"));\nconst TranscriptionsAPI = __importStar(require(\"./transcriptions.js\"));\nconst TranslationsAPI = __importStar(require(\"./translations.js\"));\nclass Audio extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n        this.translations = new TranslationsAPI.Translations(this._client);\n        this.speech = new SpeechAPI.Speech(this._client);\n    }\n}\nexports.Audio = Audio;\n(function (Audio) {\n    Audio.Transcriptions = TranscriptionsAPI.Transcriptions;\n    Audio.Translations = TranslationsAPI.Translations;\n    Audio.Speech = SpeechAPI.Speech;\n})(Audio = exports.Audio || (exports.Audio = {}));\n//# sourceMappingURL=audio.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as AudioAPI from './audio';\nimport * as SpeechAPI from './speech';\nimport * as TranscriptionsAPI from './transcriptions';\nimport * as TranslationsAPI from './translations';\n\nexport class Audio extends APIResource {\n  transcriptions: TranscriptionsAPI.Transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n  translations: TranslationsAPI.Translations = new TranslationsAPI.Translations(this._client);\n  speech: SpeechAPI.Speech = new SpeechAPI.Speech(this._client);\n}\n\nexport type AudioModel = 'whisper-1';\n\n/**\n * The format of the output, in one of these options: `json`, `text`, `srt`,\n * `verbose_json`, or `vtt`.\n */\nexport type AudioResponseFormat = 'json' | 'text' | 'srt' | 'verbose_json' | 'vtt';\n\nexport namespace Audio {\n  export import AudioModel = AudioAPI.AudioModel;\n  export import AudioResponseFormat = AudioAPI.AudioResponseFormat;\n  export import Transcriptions = TranscriptionsAPI.Transcriptions;\n  export import Transcription = TranscriptionsAPI.Transcription;\n  export import TranscriptionSegment = TranscriptionsAPI.TranscriptionSegment;\n  export import TranscriptionVerbose = TranscriptionsAPI.TranscriptionVerbose;\n  export import TranscriptionWord = TranscriptionsAPI.TranscriptionWord;\n  export import TranscriptionCreateResponse = TranscriptionsAPI.TranscriptionCreateResponse;\n  export type TranscriptionCreateParams<\n    ResponseFormat extends AudioAPI.AudioResponseFormat | undefined =\n      | AudioAPI.AudioResponseFormat\n      | undefined,\n  > = TranscriptionsAPI.TranscriptionCreateParams<ResponseFormat>;\n  export import Translations = TranslationsAPI.Translations;\n  export import Translation = TranslationsAPI.Translation;\n  export import TranslationVerbose = TranslationsAPI.TranslationVerbose;\n  export import TranslationCreateResponse = TranslationsAPI.TranslationCreateResponse;\n  export type TranslationCreateParams<\n    ResponseFormat extends AudioAPI.AudioResponseFormat | undefined =\n      | AudioAPI.AudioResponseFormat\n      | undefined,\n  > = TranslationsAPI.TranslationCreateParams<ResponseFormat>;\n  export import Speech = SpeechAPI.Speech;\n  export import SpeechModel = SpeechAPI.SpeechModel;\n  export import SpeechCreateParams = SpeechAPI.SpeechCreateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Speech = void 0;\nconst resource_1 = require(\"../../resource.js\");\nclass Speech extends resource_1.APIResource {\n    /**\n     * Generates audio from the input text.\n     */\n    create(body, options) {\n        return this._client.post('/audio/speech', { body, ...options, __binaryResponse: true });\n    }\n}\nexports.Speech = Speech;\n(function (Speech) {\n})(Speech = exports.Speech || (exports.Speech = {}));\n//# sourceMappingURL=speech.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as SpeechAPI from './speech';\nimport { type Response } from '../../_shims/index';\n\nexport class Speech extends APIResource {\n  /**\n   * Generates audio from the input text.\n   */\n  create(body: SpeechCreateParams, options?: Core.RequestOptions): Core.APIPromise<Response> {\n    return this._client.post('/audio/speech', { body, ...options, __binaryResponse: true });\n  }\n}\n\nexport type SpeechModel = 'tts-1' | 'tts-1-hd';\n\nexport interface SpeechCreateParams {\n  /**\n   * The text to generate audio for. The maximum length is 4096 characters.\n   */\n  input: string;\n\n  /**\n   * One of the available [TTS models](https://platform.openai.com/docs/models/tts):\n   * `tts-1` or `tts-1-hd`\n   */\n  model: (string & {}) | SpeechModel;\n\n  /**\n   * The voice to use when generating the audio. Supported voices are `alloy`,\n   * `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are\n   * available in the\n   * [Text to speech guide](https://platform.openai.com/docs/guides/text-to-speech/voice-options).\n   */\n  voice: 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';\n\n  /**\n   * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`,\n   * `wav`, and `pcm`.\n   */\n  response_format?: 'mp3' | 'opus' | 'aac' | 'flac' | 'wav' | 'pcm';\n\n  /**\n   * The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is\n   * the default.\n   */\n  speed?: number;\n}\n\nexport namespace Speech {\n  export import SpeechModel = SpeechAPI.SpeechModel;\n  export import SpeechCreateParams = SpeechAPI.SpeechCreateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transcriptions = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst Core = __importStar(require(\"../../core.js\"));\nclass Transcriptions extends resource_1.APIResource {\n    create(body, options) {\n        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\nexports.Transcriptions = Transcriptions;\n(function (Transcriptions) {\n})(Transcriptions = exports.Transcriptions || (exports.Transcriptions = {}));\n//# sourceMappingURL=transcriptions.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as TranscriptionsAPI from './transcriptions';\nimport * as AudioAPI from './audio';\n\nexport class Transcriptions extends APIResource {\n  /**\n   * Transcribes audio into the input language.\n   */\n  create(\n    body: TranscriptionCreateParams<'json' | undefined>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Transcription>;\n  create(\n    body: TranscriptionCreateParams<'verbose_json'>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<TranscriptionVerbose>;\n  create(\n    body: TranscriptionCreateParams<'srt' | 'vtt' | 'text'>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<string>;\n  create(body: TranscriptionCreateParams, options?: Core.RequestOptions): Core.APIPromise<Transcription>;\n  create(\n    body: TranscriptionCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<TranscriptionCreateResponse | string> {\n    return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n}\n\n/**\n * Represents a transcription response returned by model, based on the provided\n * input.\n */\nexport interface Transcription {\n  /**\n   * The transcribed text.\n   */\n  text: string;\n}\n\nexport interface TranscriptionSegment {\n  /**\n   * Unique identifier of the segment.\n   */\n  id: number;\n\n  /**\n   * Average logprob of the segment. If the value is lower than -1, consider the\n   * logprobs failed.\n   */\n  avg_logprob: number;\n\n  /**\n   * Compression ratio of the segment. If the value is greater than 2.4, consider the\n   * compression failed.\n   */\n  compression_ratio: number;\n\n  /**\n   * End time of the segment in seconds.\n   */\n  end: number;\n\n  /**\n   * Probability of no speech in the segment. If the value is higher than 1.0 and the\n   * `avg_logprob` is below -1, consider this segment silent.\n   */\n  no_speech_prob: number;\n\n  /**\n   * Seek offset of the segment.\n   */\n  seek: number;\n\n  /**\n   * Start time of the segment in seconds.\n   */\n  start: number;\n\n  /**\n   * Temperature parameter used for generating the segment.\n   */\n  temperature: number;\n\n  /**\n   * Text content of the segment.\n   */\n  text: string;\n\n  /**\n   * Array of token IDs for the text content.\n   */\n  tokens: Array<number>;\n}\n\n/**\n * Represents a verbose json transcription response returned by model, based on the\n * provided input.\n */\nexport interface TranscriptionVerbose {\n  /**\n   * The duration of the input audio.\n   */\n  duration: string;\n\n  /**\n   * The language of the input audio.\n   */\n  language: string;\n\n  /**\n   * The transcribed text.\n   */\n  text: string;\n\n  /**\n   * Segments of the transcribed text and their corresponding details.\n   */\n  segments?: Array<TranscriptionSegment>;\n\n  /**\n   * Extracted words and their corresponding timestamps.\n   */\n  words?: Array<TranscriptionWord>;\n}\n\nexport interface TranscriptionWord {\n  /**\n   * End time of the word in seconds.\n   */\n  end: number;\n\n  /**\n   * Start time of the word in seconds.\n   */\n  start: number;\n\n  /**\n   * The text content of the word.\n   */\n  word: string;\n}\n\n/**\n * Represents a transcription response returned by model, based on the provided\n * input.\n */\nexport type TranscriptionCreateResponse = Transcription | TranscriptionVerbose;\n\nexport interface TranscriptionCreateParams<\n  ResponseFormat extends AudioAPI.AudioResponseFormat | undefined = AudioAPI.AudioResponseFormat | undefined,\n> {\n  /**\n   * The audio file object (not file name) to transcribe, in one of these formats:\n   * flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n   */\n  file: Core.Uploadable;\n\n  /**\n   * ID of the model to use. Only `whisper-1` (which is powered by our open source\n   * Whisper V2 model) is currently available.\n   */\n  model: (string & {}) | AudioAPI.AudioModel;\n\n  /**\n   * The language of the input audio. Supplying the input language in\n   * [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will\n   * improve accuracy and latency.\n   */\n  language?: string;\n\n  /**\n   * An optional text to guide the model's style or continue a previous audio\n   * segment. The\n   * [prompt](https://platform.openai.com/docs/guides/speech-to-text/prompting)\n   * should match the audio language.\n   */\n  prompt?: string;\n\n  /**\n   * The format of the output, in one of these options: `json`, `text`, `srt`,\n   * `verbose_json`, or `vtt`.\n   */\n  response_format?: ResponseFormat;\n\n  /**\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\n   * output more random, while lower values like 0.2 will make it more focused and\n   * deterministic. If set to 0, the model will use\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\n   * automatically increase the temperature until certain thresholds are hit.\n   */\n  temperature?: number;\n\n  /**\n   * The timestamp granularities to populate for this transcription.\n   * `response_format` must be set `verbose_json` to use timestamp granularities.\n   * Either or both of these options are supported: `word`, or `segment`. Note: There\n   * is no additional latency for segment timestamps, but generating word timestamps\n   * incurs additional latency.\n   */\n  timestamp_granularities?: Array<'word' | 'segment'>;\n}\n\nexport namespace Transcriptions {\n  export import Transcription = TranscriptionsAPI.Transcription;\n  export import TranscriptionSegment = TranscriptionsAPI.TranscriptionSegment;\n  export import TranscriptionVerbose = TranscriptionsAPI.TranscriptionVerbose;\n  export import TranscriptionWord = TranscriptionsAPI.TranscriptionWord;\n  export import TranscriptionCreateResponse = TranscriptionsAPI.TranscriptionCreateResponse;\n  export type TranscriptionCreateParams<\n    ResponseFormat extends AudioAPI.AudioResponseFormat | undefined =\n      | AudioAPI.AudioResponseFormat\n      | undefined,\n  > = TranscriptionsAPI.TranscriptionCreateParams<ResponseFormat>;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Translations = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst Core = __importStar(require(\"../../core.js\"));\nclass Translations extends resource_1.APIResource {\n    create(body, options) {\n        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\nexports.Translations = Translations;\n(function (Translations) {\n})(Translations = exports.Translations || (exports.Translations = {}));\n//# sourceMappingURL=translations.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as TranslationsAPI from './translations';\nimport * as AudioAPI from './audio';\nimport * as TranscriptionsAPI from './transcriptions';\n\nexport class Translations extends APIResource {\n  /**\n   * Translates audio into English.\n   */\n  create(\n    body: TranslationCreateParams<'json' | undefined>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Translation>;\n  create(\n    body: TranslationCreateParams<'verbose_json'>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<TranslationVerbose>;\n  create(\n    body: TranslationCreateParams<'text' | 'srt' | 'vtt'>,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<string>;\n  create(body: TranslationCreateParams, options?: Core.RequestOptions): Core.APIPromise<Translation>;\n  create(\n    body: TranslationCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<TranslationCreateResponse | string> {\n    return this._client.post('/audio/translations', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n}\n\nexport interface Translation {\n  text: string;\n}\n\nexport interface TranslationVerbose {\n  /**\n   * The duration of the input audio.\n   */\n  duration: string;\n\n  /**\n   * The language of the output translation (always `english`).\n   */\n  language: string;\n\n  /**\n   * The translated text.\n   */\n  text: string;\n\n  /**\n   * Segments of the translated text and their corresponding details.\n   */\n  segments?: Array<TranscriptionsAPI.TranscriptionSegment>;\n}\n\nexport type TranslationCreateResponse = Translation | TranslationVerbose;\n\nexport interface TranslationCreateParams<\n  ResponseFormat extends AudioAPI.AudioResponseFormat | undefined = AudioAPI.AudioResponseFormat | undefined,\n> {\n  /**\n   * The audio file object (not file name) translate, in one of these formats: flac,\n   * mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n   */\n  file: Core.Uploadable;\n\n  /**\n   * ID of the model to use. Only `whisper-1` (which is powered by our open source\n   * Whisper V2 model) is currently available.\n   */\n  model: (string & {}) | AudioAPI.AudioModel;\n\n  /**\n   * An optional text to guide the model's style or continue a previous audio\n   * segment. The\n   * [prompt](https://platform.openai.com/docs/guides/speech-to-text/prompting)\n   * should be in English.\n   */\n  prompt?: string;\n\n  /**\n   * The format of the output, in one of these options: `json`, `text`, `srt`,\n   * `verbose_json`, or `vtt`.\n   */\n  response_format?: ResponseFormat;\n\n  /**\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\n   * output more random, while lower values like 0.2 will make it more focused and\n   * deterministic. If set to 0, the model will use\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\n   * automatically increase the temperature until certain thresholds are hit.\n   */\n  temperature?: number;\n}\n\nexport namespace Translations {\n  export import Translation = TranslationsAPI.Translation;\n  export import TranslationVerbose = TranslationsAPI.TranslationVerbose;\n  export import TranslationCreateResponse = TranslationsAPI.TranslationCreateResponse;\n  export type TranslationCreateParams<\n    ResponseFormat extends AudioAPI.AudioResponseFormat | undefined =\n      | AudioAPI.AudioResponseFormat\n      | undefined,\n  > = TranslationsAPI.TranslationCreateParams<ResponseFormat>;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BatchesPage = exports.Batches = void 0;\nconst resource_1 = require(\"../resource.js\");\nconst core_1 = require(\"../core.js\");\nconst BatchesAPI = __importStar(require(\"./batches.js\"));\nconst pagination_1 = require(\"../pagination.js\");\nclass Batches extends resource_1.APIResource {\n    /**\n     * Creates and executes a batch from an uploaded file of requests\n     */\n    create(body, options) {\n        return this._client.post('/batches', { body, ...options });\n    }\n    /**\n     * Retrieves a batch.\n     */\n    retrieve(batchId, options) {\n        return this._client.get(`/batches/${batchId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n    }\n    /**\n     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n     * 10 minutes, before changing to `cancelled`, where it will have partial results\n     * (if any) available in the output file.\n     */\n    cancel(batchId, options) {\n        return this._client.post(`/batches/${batchId}/cancel`, options);\n    }\n}\nexports.Batches = Batches;\nclass BatchesPage extends pagination_1.CursorPage {\n}\nexports.BatchesPage = BatchesPage;\n(function (Batches) {\n    Batches.BatchesPage = BatchesAPI.BatchesPage;\n})(Batches = exports.Batches || (exports.Batches = {}));\n//# sourceMappingURL=batches.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport { isRequestOptions } from '../core';\nimport * as Core from '../core';\nimport * as BatchesAPI from './batches';\nimport { CursorPage, type CursorPageParams } from '../pagination';\n\nexport class Batches extends APIResource {\n  /**\n   * Creates and executes a batch from an uploaded file of requests\n   */\n  create(body: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<Batch> {\n    return this._client.post('/batches', { body, ...options });\n  }\n\n  /**\n   * Retrieves a batch.\n   */\n  retrieve(batchId: string, options?: Core.RequestOptions): Core.APIPromise<Batch> {\n    return this._client.get(`/batches/${batchId}`, options);\n  }\n\n  /**\n   * List your organization's batches.\n   */\n  list(query?: BatchListParams, options?: Core.RequestOptions): Core.PagePromise<BatchesPage, Batch>;\n  list(options?: Core.RequestOptions): Core.PagePromise<BatchesPage, Batch>;\n  list(\n    query: BatchListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<BatchesPage, Batch> {\n    if (isRequestOptions(query)) {\n      return this.list({}, query);\n    }\n    return this._client.getAPIList('/batches', BatchesPage, { query, ...options });\n  }\n\n  /**\n   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to\n   * 10 minutes, before changing to `cancelled`, where it will have partial results\n   * (if any) available in the output file.\n   */\n  cancel(batchId: string, options?: Core.RequestOptions): Core.APIPromise<Batch> {\n    return this._client.post(`/batches/${batchId}/cancel`, options);\n  }\n}\n\nexport class BatchesPage extends CursorPage<Batch> {}\n\nexport interface Batch {\n  id: string;\n\n  /**\n   * The time frame within which the batch should be processed.\n   */\n  completion_window: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was created.\n   */\n  created_at: number;\n\n  /**\n   * The OpenAI API endpoint used by the batch.\n   */\n  endpoint: string;\n\n  /**\n   * The ID of the input file for the batch.\n   */\n  input_file_id: string;\n\n  /**\n   * The object type, which is always `batch`.\n   */\n  object: 'batch';\n\n  /**\n   * The current status of the batch.\n   */\n  status:\n    | 'validating'\n    | 'failed'\n    | 'in_progress'\n    | 'finalizing'\n    | 'completed'\n    | 'expired'\n    | 'cancelling'\n    | 'cancelled';\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\n   */\n  cancelled_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\n   */\n  cancelling_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was completed.\n   */\n  completed_at?: number;\n\n  /**\n   * The ID of the file containing the outputs of requests with errors.\n   */\n  error_file_id?: string;\n\n  errors?: Batch.Errors;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch expired.\n   */\n  expired_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch will expire.\n   */\n  expires_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch failed.\n   */\n  failed_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\n   */\n  finalizing_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started processing.\n   */\n  in_progress_at?: number;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the file containing the outputs of successfully executed requests.\n   */\n  output_file_id?: string;\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  request_counts?: BatchRequestCounts;\n}\n\nexport namespace Batch {\n  export interface Errors {\n    data?: Array<BatchesAPI.BatchError>;\n\n    /**\n     * The object type, which is always `list`.\n     */\n    object?: string;\n  }\n}\n\nexport interface BatchError {\n  /**\n   * An error code identifying the error type.\n   */\n  code?: string;\n\n  /**\n   * The line number of the input file where the error occurred, if applicable.\n   */\n  line?: number | null;\n\n  /**\n   * A human-readable message providing more details about the error.\n   */\n  message?: string;\n\n  /**\n   * The name of the parameter that caused the error, if applicable.\n   */\n  param?: string | null;\n}\n\n/**\n * The request counts for different statuses within the batch.\n */\nexport interface BatchRequestCounts {\n  /**\n   * Number of requests that have been completed successfully.\n   */\n  completed: number;\n\n  /**\n   * Number of requests that have failed.\n   */\n  failed: number;\n\n  /**\n   * Total number of requests in the batch.\n   */\n  total: number;\n}\n\nexport interface BatchCreateParams {\n  /**\n   * The time frame within which the batch should be processed. Currently only `24h`\n   * is supported.\n   */\n  completion_window: '24h';\n\n  /**\n   * The endpoint to be used for all requests in the batch. Currently\n   * `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported.\n   * Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000\n   * embedding inputs across all requests in the batch.\n   */\n  endpoint: '/v1/chat/completions' | '/v1/embeddings' | '/v1/completions';\n\n  /**\n   * The ID of an uploaded file that contains requests for the new batch.\n   *\n   * See [upload file](https://platform.openai.com/docs/api-reference/files/create)\n   * for how to upload a file.\n   *\n   * Your input file must be formatted as a\n   * [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input),\n   * and must be uploaded with the purpose `batch`. The file can contain up to 50,000\n   * requests, and can be up to 100 MB in size.\n   */\n  input_file_id: string;\n\n  /**\n   * Optional custom metadata for the batch.\n   */\n  metadata?: Record<string, string> | null;\n}\n\nexport interface BatchListParams extends CursorPageParams {}\n\nexport namespace Batches {\n  export import Batch = BatchesAPI.Batch;\n  export import BatchError = BatchesAPI.BatchError;\n  export import BatchRequestCounts = BatchesAPI.BatchRequestCounts;\n  export import BatchesPage = BatchesAPI.BatchesPage;\n  export import BatchCreateParams = BatchesAPI.BatchCreateParams;\n  export import BatchListParams = BatchesAPI.BatchListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Beta = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst AssistantsAPI = __importStar(require(\"./assistants.js\"));\nconst ChatAPI = __importStar(require(\"./chat/chat.js\"));\nconst ThreadsAPI = __importStar(require(\"./threads/threads.js\"));\nconst VectorStoresAPI = __importStar(require(\"./vector-stores/vector-stores.js\"));\nclass Beta extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.vectorStores = new VectorStoresAPI.VectorStores(this._client);\n        this.chat = new ChatAPI.Chat(this._client);\n        this.assistants = new AssistantsAPI.Assistants(this._client);\n        this.threads = new ThreadsAPI.Threads(this._client);\n    }\n}\nexports.Beta = Beta;\n(function (Beta) {\n    Beta.VectorStores = VectorStoresAPI.VectorStores;\n    Beta.VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n    Beta.Chat = ChatAPI.Chat;\n    Beta.Assistants = AssistantsAPI.Assistants;\n    Beta.AssistantsPage = AssistantsAPI.AssistantsPage;\n    Beta.Threads = ThreadsAPI.Threads;\n})(Beta = exports.Beta || (exports.Beta = {}));\n//# sourceMappingURL=beta.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as AssistantsAPI from './assistants';\nimport * as ChatAPI from './chat/chat';\nimport * as ThreadsAPI from './threads/threads';\nimport * as VectorStoresAPI from './vector-stores/vector-stores';\n\nexport class Beta extends APIResource {\n  vectorStores: VectorStoresAPI.VectorStores = new VectorStoresAPI.VectorStores(this._client);\n  chat: ChatAPI.Chat = new ChatAPI.Chat(this._client);\n  assistants: AssistantsAPI.Assistants = new AssistantsAPI.Assistants(this._client);\n  threads: ThreadsAPI.Threads = new ThreadsAPI.Threads(this._client);\n}\n\nexport namespace Beta {\n  export import VectorStores = VectorStoresAPI.VectorStores;\n  export import AutoFileChunkingStrategyParam = VectorStoresAPI.AutoFileChunkingStrategyParam;\n  export import FileChunkingStrategy = VectorStoresAPI.FileChunkingStrategy;\n  export import FileChunkingStrategyParam = VectorStoresAPI.FileChunkingStrategyParam;\n  export import OtherFileChunkingStrategyObject = VectorStoresAPI.OtherFileChunkingStrategyObject;\n  export import StaticFileChunkingStrategy = VectorStoresAPI.StaticFileChunkingStrategy;\n  export import StaticFileChunkingStrategyObject = VectorStoresAPI.StaticFileChunkingStrategyObject;\n  export import StaticFileChunkingStrategyParam = VectorStoresAPI.StaticFileChunkingStrategyParam;\n  export import VectorStore = VectorStoresAPI.VectorStore;\n  export import VectorStoreDeleted = VectorStoresAPI.VectorStoreDeleted;\n  export import VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n  export import VectorStoreCreateParams = VectorStoresAPI.VectorStoreCreateParams;\n  export import VectorStoreUpdateParams = VectorStoresAPI.VectorStoreUpdateParams;\n  export import VectorStoreListParams = VectorStoresAPI.VectorStoreListParams;\n  export import Chat = ChatAPI.Chat;\n  export import Assistants = AssistantsAPI.Assistants;\n  export import Assistant = AssistantsAPI.Assistant;\n  export import AssistantDeleted = AssistantsAPI.AssistantDeleted;\n  export import AssistantStreamEvent = AssistantsAPI.AssistantStreamEvent;\n  export import AssistantTool = AssistantsAPI.AssistantTool;\n  export import CodeInterpreterTool = AssistantsAPI.CodeInterpreterTool;\n  export import FileSearchTool = AssistantsAPI.FileSearchTool;\n  export import FunctionTool = AssistantsAPI.FunctionTool;\n  export import MessageStreamEvent = AssistantsAPI.MessageStreamEvent;\n  export import RunStepStreamEvent = AssistantsAPI.RunStepStreamEvent;\n  export import RunStreamEvent = AssistantsAPI.RunStreamEvent;\n  export import ThreadStreamEvent = AssistantsAPI.ThreadStreamEvent;\n  export import AssistantsPage = AssistantsAPI.AssistantsPage;\n  export import AssistantCreateParams = AssistantsAPI.AssistantCreateParams;\n  export import AssistantUpdateParams = AssistantsAPI.AssistantUpdateParams;\n  export import AssistantListParams = AssistantsAPI.AssistantListParams;\n  export import Threads = ThreadsAPI.Threads;\n  export import AssistantResponseFormatOption = ThreadsAPI.AssistantResponseFormatOption;\n  export import AssistantToolChoice = ThreadsAPI.AssistantToolChoice;\n  export import AssistantToolChoiceFunction = ThreadsAPI.AssistantToolChoiceFunction;\n  export import AssistantToolChoiceOption = ThreadsAPI.AssistantToolChoiceOption;\n  export import Thread = ThreadsAPI.Thread;\n  export import ThreadDeleted = ThreadsAPI.ThreadDeleted;\n  export import ThreadCreateParams = ThreadsAPI.ThreadCreateParams;\n  export import ThreadUpdateParams = ThreadsAPI.ThreadUpdateParams;\n  export import ThreadCreateAndRunParams = ThreadsAPI.ThreadCreateAndRunParams;\n  export import ThreadCreateAndRunParamsNonStreaming = ThreadsAPI.ThreadCreateAndRunParamsNonStreaming;\n  export import ThreadCreateAndRunParamsStreaming = ThreadsAPI.ThreadCreateAndRunParamsStreaming;\n  export import ThreadCreateAndRunPollParams = ThreadsAPI.ThreadCreateAndRunPollParams;\n  export import ThreadCreateAndRunStreamParams = ThreadsAPI.ThreadCreateAndRunStreamParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssistantsPage = exports.Assistants = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst core_1 = require(\"../../core.js\");\nconst AssistantsAPI = __importStar(require(\"./assistants.js\"));\nconst pagination_1 = require(\"../../pagination.js\");\nclass Assistants extends resource_1.APIResource {\n    /**\n     * Create an assistant with a model and instructions.\n     */\n    create(body, options) {\n        return this._client.post('/assistants', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves an assistant.\n     */\n    retrieve(assistantId, options) {\n        return this._client.get(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies an assistant.\n     */\n    update(assistantId, body, options) {\n        return this._client.post(`/assistants/${assistantId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/assistants', AssistantsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete an assistant.\n     */\n    del(assistantId, options) {\n        return this._client.delete(`/assistants/${assistantId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexports.Assistants = Assistants;\nclass AssistantsPage extends pagination_1.CursorPage {\n}\nexports.AssistantsPage = AssistantsPage;\n(function (Assistants) {\n    Assistants.AssistantsPage = AssistantsAPI.AssistantsPage;\n})(Assistants = exports.Assistants || (exports.Assistants = {}));\n//# sourceMappingURL=assistants.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport { isRequestOptions } from '../../core';\nimport * as Core from '../../core';\nimport * as AssistantsAPI from './assistants';\nimport * as Shared from '../shared';\nimport * as ChatAPI from '../chat/chat';\nimport * as MessagesAPI from './threads/messages';\nimport * as ThreadsAPI from './threads/threads';\nimport * as VectorStoresAPI from './vector-stores/vector-stores';\nimport * as RunsAPI from './threads/runs/runs';\nimport * as StepsAPI from './threads/runs/steps';\nimport { CursorPage, type CursorPageParams } from '../../pagination';\n\nexport class Assistants extends APIResource {\n  /**\n   * Create an assistant with a model and instructions.\n   */\n  create(body: AssistantCreateParams, options?: Core.RequestOptions): Core.APIPromise<Assistant> {\n    return this._client.post('/assistants', {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieves an assistant.\n   */\n  retrieve(assistantId: string, options?: Core.RequestOptions): Core.APIPromise<Assistant> {\n    return this._client.get(`/assistants/${assistantId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Modifies an assistant.\n   */\n  update(\n    assistantId: string,\n    body: AssistantUpdateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Assistant> {\n    return this._client.post(`/assistants/${assistantId}`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of assistants.\n   */\n  list(\n    query?: AssistantListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<AssistantsPage, Assistant>;\n  list(options?: Core.RequestOptions): Core.PagePromise<AssistantsPage, Assistant>;\n  list(\n    query: AssistantListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<AssistantsPage, Assistant> {\n    if (isRequestOptions(query)) {\n      return this.list({}, query);\n    }\n    return this._client.getAPIList('/assistants', AssistantsPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Delete an assistant.\n   */\n  del(assistantId: string, options?: Core.RequestOptions): Core.APIPromise<AssistantDeleted> {\n    return this._client.delete(`/assistants/${assistantId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n}\n\nexport class AssistantsPage extends CursorPage<Assistant> {}\n\n/**\n * Represents an `assistant` that can call the model and use tools.\n */\nexport interface Assistant {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the assistant was created.\n   */\n  created_at: number;\n\n  /**\n   * The description of the assistant. The maximum length is 512 characters.\n   */\n  description: string | null;\n\n  /**\n   * The system instructions that the assistant uses. The maximum length is 256,000\n   * characters.\n   */\n  instructions: string | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * ID of the model to use. You can use the\n   * [List models](https://platform.openai.com/docs/api-reference/models/list) API to\n   * see all of your available models, or see our\n   * [Model overview](https://platform.openai.com/docs/models/overview) for\n   * descriptions of them.\n   */\n  model: string;\n\n  /**\n   * The name of the assistant. The maximum length is 256 characters.\n   */\n  name: string | null;\n\n  /**\n   * The object type, which is always `assistant`.\n   */\n  object: 'assistant';\n\n  /**\n   * A list of tool enabled on the assistant. There can be a maximum of 128 tools per\n   * assistant. Tools can be of types `code_interpreter`, `file_search`, or\n   * `function`.\n   */\n  tools: Array<AssistantTool>;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: Assistant.ToolResources | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n}\n\nexport namespace Assistant {\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter`` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The ID of the\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n}\n\nexport interface AssistantDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'assistant.deleted';\n}\n\n/**\n * Represents an event emitted when streaming a Run.\n *\n * Each event in a server-sent events stream has an `event` and `data` property:\n *\n * ```\n * event: thread.created\n * data: {\"id\": \"thread_123\", \"object\": \"thread\", ...}\n * ```\n *\n * We emit events whenever a new object is created, transitions to a new state, or\n * is being streamed in parts (deltas). For example, we emit `thread.run.created`\n * when a new run is created, `thread.run.completed` when a run completes, and so\n * on. When an Assistant chooses to create a message during a run, we emit a\n * `thread.message.created event`, a `thread.message.in_progress` event, many\n * `thread.message.delta` events, and finally a `thread.message.completed` event.\n *\n * We may add additional events over time, so we recommend handling unknown events\n * gracefully in your code. See the\n * [Assistants API quickstart](https://platform.openai.com/docs/assistants/overview)\n * to learn how to integrate the Assistants API with streaming.\n */\nexport type AssistantStreamEvent =\n  | AssistantStreamEvent.ThreadCreated\n  | AssistantStreamEvent.ThreadRunCreated\n  | AssistantStreamEvent.ThreadRunQueued\n  | AssistantStreamEvent.ThreadRunInProgress\n  | AssistantStreamEvent.ThreadRunRequiresAction\n  | AssistantStreamEvent.ThreadRunCompleted\n  | AssistantStreamEvent.ThreadRunIncomplete\n  | AssistantStreamEvent.ThreadRunFailed\n  | AssistantStreamEvent.ThreadRunCancelling\n  | AssistantStreamEvent.ThreadRunCancelled\n  | AssistantStreamEvent.ThreadRunExpired\n  | AssistantStreamEvent.ThreadRunStepCreated\n  | AssistantStreamEvent.ThreadRunStepInProgress\n  | AssistantStreamEvent.ThreadRunStepDelta\n  | AssistantStreamEvent.ThreadRunStepCompleted\n  | AssistantStreamEvent.ThreadRunStepFailed\n  | AssistantStreamEvent.ThreadRunStepCancelled\n  | AssistantStreamEvent.ThreadRunStepExpired\n  | AssistantStreamEvent.ThreadMessageCreated\n  | AssistantStreamEvent.ThreadMessageInProgress\n  | AssistantStreamEvent.ThreadMessageDelta\n  | AssistantStreamEvent.ThreadMessageCompleted\n  | AssistantStreamEvent.ThreadMessageIncomplete\n  | AssistantStreamEvent.ErrorEvent;\n\nexport namespace AssistantStreamEvent {\n  /**\n   * Occurs when a new\n   * [thread](https://platform.openai.com/docs/api-reference/threads/object) is\n   * created.\n   */\n  export interface ThreadCreated {\n    /**\n     * Represents a thread that contains\n     * [messages](https://platform.openai.com/docs/api-reference/messages).\n     */\n    data: ThreadsAPI.Thread;\n\n    event: 'thread.created';\n  }\n\n  /**\n   * Occurs when a new\n   * [run](https://platform.openai.com/docs/api-reference/runs/object) is created.\n   */\n  export interface ThreadRunCreated {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.created';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `queued` status.\n   */\n  export interface ThreadRunQueued {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.queued';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to an `in_progress` status.\n   */\n  export interface ThreadRunInProgress {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.in_progress';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `requires_action` status.\n   */\n  export interface ThreadRunRequiresAction {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.requires_action';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * is completed.\n   */\n  export interface ThreadRunCompleted {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.completed';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * ends with status `incomplete`.\n   */\n  export interface ThreadRunIncomplete {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.incomplete';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * fails.\n   */\n  export interface ThreadRunFailed {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.failed';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `cancelling` status.\n   */\n  export interface ThreadRunCancelling {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.cancelling';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * is cancelled.\n   */\n  export interface ThreadRunCancelled {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.cancelled';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * expires.\n   */\n  export interface ThreadRunExpired {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.expired';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is created.\n   */\n  export interface ThreadRunStepCreated {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.created';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * moves to an `in_progress` state.\n   */\n  export interface ThreadRunStepInProgress {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.in_progress';\n  }\n\n  /**\n   * Occurs when parts of a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * are being streamed.\n   */\n  export interface ThreadRunStepDelta {\n    /**\n     * Represents a run step delta i.e. any changed fields on a run step during\n     * streaming.\n     */\n    data: StepsAPI.RunStepDeltaEvent;\n\n    event: 'thread.run.step.delta';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is completed.\n   */\n  export interface ThreadRunStepCompleted {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.completed';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * fails.\n   */\n  export interface ThreadRunStepFailed {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.failed';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is cancelled.\n   */\n  export interface ThreadRunStepCancelled {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.cancelled';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * expires.\n   */\n  export interface ThreadRunStepExpired {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.expired';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) is\n   * created.\n   */\n  export interface ThreadMessageCreated {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.created';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) moves\n   * to an `in_progress` state.\n   */\n  export interface ThreadMessageInProgress {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.in_progress';\n  }\n\n  /**\n   * Occurs when parts of a\n   * [Message](https://platform.openai.com/docs/api-reference/messages/object) are\n   * being streamed.\n   */\n  export interface ThreadMessageDelta {\n    /**\n     * Represents a message delta i.e. any changed fields on a message during\n     * streaming.\n     */\n    data: MessagesAPI.MessageDeltaEvent;\n\n    event: 'thread.message.delta';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) is\n   * completed.\n   */\n  export interface ThreadMessageCompleted {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.completed';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) ends\n   * before it is completed.\n   */\n  export interface ThreadMessageIncomplete {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.incomplete';\n  }\n\n  /**\n   * Occurs when an\n   * [error](https://platform.openai.com/docs/guides/error-codes/api-errors) occurs.\n   * This can happen due to an internal server error or a timeout.\n   */\n  export interface ErrorEvent {\n    data: Shared.ErrorObject;\n\n    event: 'error';\n  }\n}\n\nexport type AssistantTool = CodeInterpreterTool | FileSearchTool | FunctionTool;\n\nexport interface CodeInterpreterTool {\n  /**\n   * The type of tool being defined: `code_interpreter`\n   */\n  type: 'code_interpreter';\n}\n\nexport interface FileSearchTool {\n  /**\n   * The type of tool being defined: `file_search`\n   */\n  type: 'file_search';\n\n  /**\n   * Overrides for the file search tool.\n   */\n  file_search?: FileSearchTool.FileSearch;\n}\n\nexport namespace FileSearchTool {\n  /**\n   * Overrides for the file search tool.\n   */\n  export interface FileSearch {\n    /**\n     * The maximum number of results the file search tool should output. The default is\n     * 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between\n     * 1 and 50 inclusive.\n     *\n     * Note that the file search tool may output fewer than `max_num_results` results.\n     * See the\n     * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n     * for more information.\n     */\n    max_num_results?: number;\n\n    /**\n     * The ranking options for the file search. If not specified, the file search tool\n     * will use the `auto` ranker and a score_threshold of 0.\n     *\n     * See the\n     * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n     * for more information.\n     */\n    ranking_options?: FileSearch.RankingOptions;\n  }\n\n  export namespace FileSearch {\n    /**\n     * The ranking options for the file search. If not specified, the file search tool\n     * will use the `auto` ranker and a score_threshold of 0.\n     *\n     * See the\n     * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n     * for more information.\n     */\n    export interface RankingOptions {\n      /**\n       * The score threshold for the file search. All values must be a floating point\n       * number between 0 and 1.\n       */\n      score_threshold: number;\n\n      /**\n       * The ranker to use for the file search. If not specified will use the `auto`\n       * ranker.\n       */\n      ranker?: 'auto' | 'default_2024_08_21';\n    }\n  }\n}\n\nexport interface FunctionTool {\n  function: Shared.FunctionDefinition;\n\n  /**\n   * The type of tool being defined: `function`\n   */\n  type: 'function';\n}\n\n/**\n * Occurs when a\n * [message](https://platform.openai.com/docs/api-reference/messages/object) is\n * created.\n */\nexport type MessageStreamEvent =\n  | MessageStreamEvent.ThreadMessageCreated\n  | MessageStreamEvent.ThreadMessageInProgress\n  | MessageStreamEvent.ThreadMessageDelta\n  | MessageStreamEvent.ThreadMessageCompleted\n  | MessageStreamEvent.ThreadMessageIncomplete;\n\nexport namespace MessageStreamEvent {\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) is\n   * created.\n   */\n  export interface ThreadMessageCreated {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.created';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) moves\n   * to an `in_progress` state.\n   */\n  export interface ThreadMessageInProgress {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.in_progress';\n  }\n\n  /**\n   * Occurs when parts of a\n   * [Message](https://platform.openai.com/docs/api-reference/messages/object) are\n   * being streamed.\n   */\n  export interface ThreadMessageDelta {\n    /**\n     * Represents a message delta i.e. any changed fields on a message during\n     * streaming.\n     */\n    data: MessagesAPI.MessageDeltaEvent;\n\n    event: 'thread.message.delta';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) is\n   * completed.\n   */\n  export interface ThreadMessageCompleted {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.completed';\n  }\n\n  /**\n   * Occurs when a\n   * [message](https://platform.openai.com/docs/api-reference/messages/object) ends\n   * before it is completed.\n   */\n  export interface ThreadMessageIncomplete {\n    /**\n     * Represents a message within a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: MessagesAPI.Message;\n\n    event: 'thread.message.incomplete';\n  }\n}\n\n/**\n * Occurs when a\n * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n * is created.\n */\nexport type RunStepStreamEvent =\n  | RunStepStreamEvent.ThreadRunStepCreated\n  | RunStepStreamEvent.ThreadRunStepInProgress\n  | RunStepStreamEvent.ThreadRunStepDelta\n  | RunStepStreamEvent.ThreadRunStepCompleted\n  | RunStepStreamEvent.ThreadRunStepFailed\n  | RunStepStreamEvent.ThreadRunStepCancelled\n  | RunStepStreamEvent.ThreadRunStepExpired;\n\nexport namespace RunStepStreamEvent {\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is created.\n   */\n  export interface ThreadRunStepCreated {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.created';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * moves to an `in_progress` state.\n   */\n  export interface ThreadRunStepInProgress {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.in_progress';\n  }\n\n  /**\n   * Occurs when parts of a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * are being streamed.\n   */\n  export interface ThreadRunStepDelta {\n    /**\n     * Represents a run step delta i.e. any changed fields on a run step during\n     * streaming.\n     */\n    data: StepsAPI.RunStepDeltaEvent;\n\n    event: 'thread.run.step.delta';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is completed.\n   */\n  export interface ThreadRunStepCompleted {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.completed';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * fails.\n   */\n  export interface ThreadRunStepFailed {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.failed';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * is cancelled.\n   */\n  export interface ThreadRunStepCancelled {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.cancelled';\n  }\n\n  /**\n   * Occurs when a\n   * [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object)\n   * expires.\n   */\n  export interface ThreadRunStepExpired {\n    /**\n     * Represents a step in execution of a run.\n     */\n    data: StepsAPI.RunStep;\n\n    event: 'thread.run.step.expired';\n  }\n}\n\n/**\n * Occurs when a new\n * [run](https://platform.openai.com/docs/api-reference/runs/object) is created.\n */\nexport type RunStreamEvent =\n  | RunStreamEvent.ThreadRunCreated\n  | RunStreamEvent.ThreadRunQueued\n  | RunStreamEvent.ThreadRunInProgress\n  | RunStreamEvent.ThreadRunRequiresAction\n  | RunStreamEvent.ThreadRunCompleted\n  | RunStreamEvent.ThreadRunIncomplete\n  | RunStreamEvent.ThreadRunFailed\n  | RunStreamEvent.ThreadRunCancelling\n  | RunStreamEvent.ThreadRunCancelled\n  | RunStreamEvent.ThreadRunExpired;\n\nexport namespace RunStreamEvent {\n  /**\n   * Occurs when a new\n   * [run](https://platform.openai.com/docs/api-reference/runs/object) is created.\n   */\n  export interface ThreadRunCreated {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.created';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `queued` status.\n   */\n  export interface ThreadRunQueued {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.queued';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to an `in_progress` status.\n   */\n  export interface ThreadRunInProgress {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.in_progress';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `requires_action` status.\n   */\n  export interface ThreadRunRequiresAction {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.requires_action';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * is completed.\n   */\n  export interface ThreadRunCompleted {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.completed';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * ends with status `incomplete`.\n   */\n  export interface ThreadRunIncomplete {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.incomplete';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * fails.\n   */\n  export interface ThreadRunFailed {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.failed';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * moves to a `cancelling` status.\n   */\n  export interface ThreadRunCancelling {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.cancelling';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * is cancelled.\n   */\n  export interface ThreadRunCancelled {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.cancelled';\n  }\n\n  /**\n   * Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object)\n   * expires.\n   */\n  export interface ThreadRunExpired {\n    /**\n     * Represents an execution run on a\n     * [thread](https://platform.openai.com/docs/api-reference/threads).\n     */\n    data: RunsAPI.Run;\n\n    event: 'thread.run.expired';\n  }\n}\n\n/**\n * Occurs when a new\n * [thread](https://platform.openai.com/docs/api-reference/threads/object) is\n * created.\n */\nexport interface ThreadStreamEvent {\n  /**\n   * Represents a thread that contains\n   * [messages](https://platform.openai.com/docs/api-reference/messages).\n   */\n  data: ThreadsAPI.Thread;\n\n  event: 'thread.created';\n}\n\nexport interface AssistantCreateParams {\n  /**\n   * ID of the model to use. You can use the\n   * [List models](https://platform.openai.com/docs/api-reference/models/list) API to\n   * see all of your available models, or see our\n   * [Model overview](https://platform.openai.com/docs/models/overview) for\n   * descriptions of them.\n   */\n  model: (string & {}) | ChatAPI.ChatModel;\n\n  /**\n   * The description of the assistant. The maximum length is 512 characters.\n   */\n  description?: string | null;\n\n  /**\n   * The system instructions that the assistant uses. The maximum length is 256,000\n   * characters.\n   */\n  instructions?: string | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The name of the assistant. The maximum length is 256 characters.\n   */\n  name?: string | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: AssistantCreateParams.ToolResources | null;\n\n  /**\n   * A list of tool enabled on the assistant. There can be a maximum of 128 tools per\n   * assistant. Tools can be of types `code_interpreter`, `file_search`, or\n   * `function`.\n   */\n  tools?: Array<AssistantTool>;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n}\n\nexport namespace AssistantCreateParams {\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n\n      /**\n       * A helper to create a\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * with file_ids and attach it to this assistant. There can be a maximum of 1\n       * vector store attached to the assistant.\n       */\n      vector_stores?: Array<FileSearch.VectorStore>;\n    }\n\n    export namespace FileSearch {\n      export interface VectorStore {\n        /**\n         * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n         * strategy. Only applicable if `file_ids` is non-empty.\n         */\n        chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\n\n        /**\n         * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to\n         * add to the vector store. There can be a maximum of 10000 files in a vector\n         * store.\n         */\n        file_ids?: Array<string>;\n\n        /**\n         * Set of 16 key-value pairs that can be attached to a vector store. This can be\n         * useful for storing additional information about the vector store in a structured\n         * format. Keys can be a maximum of 64 characters long and values can be a maxium\n         * of 512 characters long.\n         */\n        metadata?: unknown;\n      }\n    }\n  }\n}\n\nexport interface AssistantUpdateParams {\n  /**\n   * The description of the assistant. The maximum length is 512 characters.\n   */\n  description?: string | null;\n\n  /**\n   * The system instructions that the assistant uses. The maximum length is 256,000\n   * characters.\n   */\n  instructions?: string | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * ID of the model to use. You can use the\n   * [List models](https://platform.openai.com/docs/api-reference/models/list) API to\n   * see all of your available models, or see our\n   * [Model overview](https://platform.openai.com/docs/models/overview) for\n   * descriptions of them.\n   */\n  model?: string;\n\n  /**\n   * The name of the assistant. The maximum length is 256 characters.\n   */\n  name?: string | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: AssistantUpdateParams.ToolResources | null;\n\n  /**\n   * A list of tool enabled on the assistant. There can be a maximum of 128 tools per\n   * assistant. Tools can be of types `code_interpreter`, `file_search`, or\n   * `function`.\n   */\n  tools?: Array<AssistantTool>;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n}\n\nexport namespace AssistantUpdateParams {\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * Overrides the list of\n       * [file](https://platform.openai.com/docs/api-reference/files) IDs made available\n       * to the `code_interpreter` tool. There can be a maximum of 20 files associated\n       * with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * Overrides the\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n}\n\nexport interface AssistantListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport namespace Assistants {\n  export import Assistant = AssistantsAPI.Assistant;\n  export import AssistantDeleted = AssistantsAPI.AssistantDeleted;\n  export import AssistantStreamEvent = AssistantsAPI.AssistantStreamEvent;\n  export import AssistantTool = AssistantsAPI.AssistantTool;\n  export import CodeInterpreterTool = AssistantsAPI.CodeInterpreterTool;\n  export import FileSearchTool = AssistantsAPI.FileSearchTool;\n  export import FunctionTool = AssistantsAPI.FunctionTool;\n  export import MessageStreamEvent = AssistantsAPI.MessageStreamEvent;\n  export import RunStepStreamEvent = AssistantsAPI.RunStepStreamEvent;\n  export import RunStreamEvent = AssistantsAPI.RunStreamEvent;\n  export import ThreadStreamEvent = AssistantsAPI.ThreadStreamEvent;\n  export import AssistantsPage = AssistantsAPI.AssistantsPage;\n  export import AssistantCreateParams = AssistantsAPI.AssistantCreateParams;\n  export import AssistantUpdateParams = AssistantsAPI.AssistantUpdateParams;\n  export import AssistantListParams = AssistantsAPI.AssistantListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chat = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst CompletionsAPI = __importStar(require(\"./completions.js\"));\nclass Chat extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.completions = new CompletionsAPI.Completions(this._client);\n    }\n}\nexports.Chat = Chat;\n(function (Chat) {\n    Chat.Completions = CompletionsAPI.Completions;\n})(Chat = exports.Chat || (exports.Chat = {}));\n//# sourceMappingURL=chat.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport * as CompletionsAPI from './completions';\n\nexport class Chat extends APIResource {\n  completions: CompletionsAPI.Completions = new CompletionsAPI.Completions(this._client);\n}\n\nexport namespace Chat {\n  export import Completions = CompletionsAPI.Completions;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Completions = exports.ChatCompletionStream = exports.ParsingToolFunction = exports.ParsingFunction = exports.ChatCompletionStreamingRunner = exports.ChatCompletionRunner = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst ChatCompletionRunner_1 = require(\"../../../lib/ChatCompletionRunner.js\");\nvar ChatCompletionRunner_2 = require(\"../../../lib/ChatCompletionRunner.js\");\nObject.defineProperty(exports, \"ChatCompletionRunner\", { enumerable: true, get: function () { return ChatCompletionRunner_2.ChatCompletionRunner; } });\nconst ChatCompletionStreamingRunner_1 = require(\"../../../lib/ChatCompletionStreamingRunner.js\");\nvar ChatCompletionStreamingRunner_2 = require(\"../../../lib/ChatCompletionStreamingRunner.js\");\nObject.defineProperty(exports, \"ChatCompletionStreamingRunner\", { enumerable: true, get: function () { return ChatCompletionStreamingRunner_2.ChatCompletionStreamingRunner; } });\nvar RunnableFunction_1 = require(\"../../../lib/RunnableFunction.js\");\nObject.defineProperty(exports, \"ParsingFunction\", { enumerable: true, get: function () { return RunnableFunction_1.ParsingFunction; } });\nObject.defineProperty(exports, \"ParsingToolFunction\", { enumerable: true, get: function () { return RunnableFunction_1.ParsingToolFunction; } });\nconst ChatCompletionStream_1 = require(\"../../../lib/ChatCompletionStream.js\");\nconst parser_1 = require(\"../../../lib/parser.js\");\nvar ChatCompletionStream_2 = require(\"../../../lib/ChatCompletionStream.js\");\nObject.defineProperty(exports, \"ChatCompletionStream\", { enumerable: true, get: function () { return ChatCompletionStream_2.ChatCompletionStream; } });\nclass Completions extends resource_1.APIResource {\n    parse(body, options) {\n        (0, parser_1.validateInputTools)(body.tools);\n        return this._client.chat.completions\n            .create(body, {\n            ...options,\n            headers: {\n                ...options?.headers,\n                'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n            },\n        })\n            ._thenUnwrap((completion) => (0, parser_1.parseChatCompletion)(completion, body));\n    }\n    runFunctions(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runFunctions(this._client, body, options);\n        }\n        return ChatCompletionRunner_1.ChatCompletionRunner.runFunctions(this._client, body, options);\n    }\n    runTools(body, options) {\n        if (body.stream) {\n            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runTools(this._client, body, options);\n        }\n        return ChatCompletionRunner_1.ChatCompletionRunner.runTools(this._client, body, options);\n    }\n    /**\n     * Creates a chat completion stream\n     */\n    stream(body, options) {\n        return ChatCompletionStream_1.ChatCompletionStream.createChatCompletion(this._client, body, options);\n    }\n}\nexports.Completions = Completions;\n//# sourceMappingURL=completions.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport * as Core from '../../../core';\nimport { APIResource } from '../../../resource';\nimport { ChatCompletionRunner, ChatCompletionFunctionRunnerParams } from '../../../lib/ChatCompletionRunner';\nexport { ChatCompletionRunner, ChatCompletionFunctionRunnerParams } from '../../../lib/ChatCompletionRunner';\nimport {\n  ChatCompletionStreamingRunner,\n  ChatCompletionStreamingFunctionRunnerParams,\n} from '../../../lib/ChatCompletionStreamingRunner';\nexport {\n  ChatCompletionStreamingRunner,\n  ChatCompletionStreamingFunctionRunnerParams,\n} from '../../../lib/ChatCompletionStreamingRunner';\nimport { BaseFunctionsArgs } from '../../../lib/RunnableFunction';\nexport {\n  RunnableFunction,\n  RunnableFunctions,\n  RunnableFunctionWithParse,\n  RunnableFunctionWithoutParse,\n  ParsingFunction,\n  ParsingToolFunction,\n} from '../../../lib/RunnableFunction';\nimport { RunnerOptions } from '../../../lib/AbstractChatCompletionRunner';\nimport { ChatCompletionToolRunnerParams } from '../../../lib/ChatCompletionRunner';\nexport { ChatCompletionToolRunnerParams } from '../../../lib/ChatCompletionRunner';\nimport { ChatCompletionStreamingToolRunnerParams } from '../../../lib/ChatCompletionStreamingRunner';\nexport { ChatCompletionStreamingToolRunnerParams } from '../../../lib/ChatCompletionStreamingRunner';\nimport { ChatCompletionStream, type ChatCompletionStreamParams } from '../../../lib/ChatCompletionStream';\nimport {\n  ChatCompletion,\n  ChatCompletionCreateParamsNonStreaming,\n  ChatCompletionMessage,\n  ChatCompletionMessageToolCall,\n} from '../../chat/completions';\nimport { ExtractParsedContentFromParams, parseChatCompletion, validateInputTools } from '../../../lib/parser';\nexport { ChatCompletionStream, type ChatCompletionStreamParams } from '../../../lib/ChatCompletionStream';\n\nexport interface ParsedFunction extends ChatCompletionMessageToolCall.Function {\n  parsed_arguments?: unknown;\n}\n\nexport interface ParsedFunctionToolCall extends ChatCompletionMessageToolCall {\n  function: ParsedFunction;\n}\n\nexport interface ParsedChatCompletionMessage<ParsedT> extends ChatCompletionMessage {\n  parsed: ParsedT | null;\n  tool_calls: Array<ParsedFunctionToolCall>;\n}\n\nexport interface ParsedChoice<ParsedT> extends ChatCompletion.Choice {\n  message: ParsedChatCompletionMessage<ParsedT>;\n}\n\nexport interface ParsedChatCompletion<ParsedT> extends ChatCompletion {\n  choices: Array<ParsedChoice<ParsedT>>;\n}\n\nexport type ChatCompletionParseParams = ChatCompletionCreateParamsNonStreaming;\n\nexport class Completions extends APIResource {\n  parse<Params extends ChatCompletionParseParams, ParsedT = ExtractParsedContentFromParams<Params>>(\n    body: Params,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<ParsedChatCompletion<ParsedT>> {\n    validateInputTools(body.tools);\n\n    return this._client.chat.completions\n      .create(body, {\n        ...options,\n        headers: {\n          ...options?.headers,\n          'X-Stainless-Helper-Method': 'beta.chat.completions.parse',\n        },\n      })\n      ._thenUnwrap((completion) => parseChatCompletion(completion, body));\n  }\n\n  /**\n   * @deprecated - use `runTools` instead.\n   */\n  runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    body: ChatCompletionFunctionRunnerParams<FunctionsArgs>,\n    options?: Core.RequestOptions,\n  ): ChatCompletionRunner<null>;\n  runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    body: ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStreamingRunner<null>;\n  runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    body:\n      | ChatCompletionFunctionRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: Core.RequestOptions,\n  ): ChatCompletionRunner<null> | ChatCompletionStreamingRunner<null> {\n    if (body.stream) {\n      return ChatCompletionStreamingRunner.runFunctions(\n        this._client,\n        body as ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n        options,\n      );\n    }\n    return ChatCompletionRunner.runFunctions(\n      this._client,\n      body as ChatCompletionFunctionRunnerParams<FunctionsArgs>,\n      options,\n    );\n  }\n\n  /**\n   * A convenience helper for using tool calls with the /chat/completions endpoint\n   * which automatically calls the JavaScript functions you provide and sends their\n   * results back to the /chat/completions endpoint, looping as long as the model\n   * requests function calls.\n   *\n   * For more details and examples, see\n   * [the docs](https://github.com/openai/openai-node#automated-function-calls)\n   */\n  runTools<\n    Params extends ChatCompletionToolRunnerParams<any>,\n    ParsedT = ExtractParsedContentFromParams<Params>,\n  >(body: Params, options?: RunnerOptions): ChatCompletionRunner<ParsedT>;\n\n  runTools<\n    Params extends ChatCompletionStreamingToolRunnerParams<any>,\n    ParsedT = ExtractParsedContentFromParams<Params>,\n  >(body: Params, options?: RunnerOptions): ChatCompletionStreamingRunner<ParsedT>;\n\n  runTools<\n    Params extends ChatCompletionToolRunnerParams<any> | ChatCompletionStreamingToolRunnerParams<any>,\n    ParsedT = ExtractParsedContentFromParams<Params>,\n  >(\n    body: Params,\n    options?: RunnerOptions,\n  ): ChatCompletionRunner<ParsedT> | ChatCompletionStreamingRunner<ParsedT> {\n    if (body.stream) {\n      return ChatCompletionStreamingRunner.runTools(\n        this._client,\n        body as ChatCompletionStreamingToolRunnerParams<any>,\n        options,\n      );\n    }\n\n    return ChatCompletionRunner.runTools(this._client, body as ChatCompletionToolRunnerParams<any>, options);\n  }\n\n  /**\n   * Creates a chat completion stream\n   */\n  stream<Params extends ChatCompletionStreamParams, ParsedT = ExtractParsedContentFromParams<Params>>(\n    body: Params,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream<ParsedT> {\n    return ChatCompletionStream.createChatCompletion(this._client, body, options);\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatCompletionRunner = void 0;\nconst AbstractChatCompletionRunner_1 = require(\"./AbstractChatCompletionRunner.js\");\nconst chatCompletionUtils_1 = require(\"./chatCompletionUtils.js\");\nclass ChatCompletionRunner extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionRunner();\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n    _addMessage(message, emit = true) {\n        super._addMessage(message, emit);\n        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.content) {\n            this._emit('content', message.content);\n        }\n    }\n}\nexports.ChatCompletionRunner = ChatCompletionRunner;\n//# sourceMappingURL=ChatCompletionRunner.js.map","import {\n  type ChatCompletionMessageParam,\n  type ChatCompletionCreateParamsNonStreaming,\n} from \"../resources/chat/completions\";\nimport { type RunnableFunctions, type BaseFunctionsArgs, RunnableTools } from './RunnableFunction';\nimport {\n  AbstractChatCompletionRunner,\n  AbstractChatCompletionRunnerEvents,\n  RunnerOptions,\n} from './AbstractChatCompletionRunner';\nimport { isAssistantMessage } from './chatCompletionUtils';\nimport OpenAI from \"../index\";\nimport { AutoParseableTool } from \"./parser\";\n\nexport interface ChatCompletionRunnerEvents extends AbstractChatCompletionRunnerEvents {\n  content: (content: string) => void;\n}\n\nexport type ChatCompletionFunctionRunnerParams<FunctionsArgs extends BaseFunctionsArgs> = Omit<\n  ChatCompletionCreateParamsNonStreaming,\n  'functions'\n> & {\n  functions: RunnableFunctions<FunctionsArgs>;\n};\n\nexport type ChatCompletionToolRunnerParams<FunctionsArgs extends BaseFunctionsArgs> = Omit<\n  ChatCompletionCreateParamsNonStreaming,\n  'tools'\n> & {\n  tools: RunnableTools<FunctionsArgs> | AutoParseableTool<any, true>[];\n};\n\nexport class ChatCompletionRunner<ParsedT = null> extends AbstractChatCompletionRunner<\n  ChatCompletionRunnerEvents,\n  ParsedT\n> {\n  /** @deprecated - please use `runTools` instead. */\n  static runFunctions(\n    client: OpenAI,\n    params: ChatCompletionFunctionRunnerParams<any[]>,\n    options?: RunnerOptions,\n  ): ChatCompletionRunner<null> {\n    const runner = new ChatCompletionRunner();\n    const opts = {\n      ...options,\n      headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n    };\n    runner._run(() => runner._runFunctions(client, params, opts));\n    return runner;\n  }\n\n  static runTools<ParsedT>(\n    client: OpenAI,\n    params: ChatCompletionToolRunnerParams<any[]>,\n    options?: RunnerOptions,\n  ): ChatCompletionRunner<ParsedT> {\n    const runner = new ChatCompletionRunner<ParsedT>();\n    const opts = {\n      ...options,\n      headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n    };\n    runner._run(() => runner._runTools(client, params, opts));\n    return runner;\n  }\n\n  override _addMessage(\n    this: ChatCompletionRunner<ParsedT>,\n    message: ChatCompletionMessageParam,\n    emit: boolean = true,\n  ) {\n    super._addMessage(message, emit);\n    if (isAssistantMessage(message) && message.content) {\n      this._emit('content', message.content as string);\n    }\n  }\n}\n","\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractChatCompletionRunner = void 0;\nconst error_1 = require(\"openai/error\");\nconst RunnableFunction_1 = require(\"./RunnableFunction.js\");\nconst chatCompletionUtils_1 = require(\"./chatCompletionUtils.js\");\nconst EventStream_1 = require(\"./EventStream.js\");\nconst parser_1 = require(\"openai/lib/parser\");\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nclass AbstractChatCompletionRunner extends EventStream_1.EventStream {\n    constructor() {\n        super(...arguments);\n        _AbstractChatCompletionRunner_instances.add(this);\n        this._chatCompletions = [];\n        this.messages = [];\n    }\n    _addChatCompletion(chatCompletion) {\n        this._chatCompletions.push(chatCompletion);\n        this._emit('chatCompletion', chatCompletion);\n        const message = chatCompletion.choices[0]?.message;\n        if (message)\n            this._addMessage(message);\n        return chatCompletion;\n    }\n    _addMessage(message, emit = true) {\n        if (!('content' in message))\n            message.content = null;\n        this.messages.push(message);\n        if (emit) {\n            this._emit('message', message);\n            if (((0, chatCompletionUtils_1.isFunctionMessage)(message) || (0, chatCompletionUtils_1.isToolMessage)(message)) && message.content) {\n                // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n                this._emit('functionCallResult', message.content);\n            }\n            else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.function_call) {\n                this._emit('functionCall', message.function_call);\n            }\n            else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.tool_calls) {\n                for (const tool_call of message.tool_calls) {\n                    if (tool_call.type === 'function') {\n                        this._emit('functionCall', tool_call.function);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @returns a promise that resolves with the final ChatCompletion, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n     */\n    async finalChatCompletion() {\n        await this.done();\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (!completion)\n            throw new error_1.OpenAIError('stream ended without producing a ChatCompletion');\n        return completion;\n    }\n    /**\n     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalContent() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalMessage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n     */\n    async finalFunctionCall() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    }\n    async finalFunctionCallResult() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    }\n    async totalUsage() {\n        await this.done();\n        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n    }\n    allChatCompletions() {\n        return [...this._chatCompletions];\n    }\n    _emitFinal() {\n        const completion = this._chatCompletions[this._chatCompletions.length - 1];\n        if (completion)\n            this._emit('finalChatCompletion', completion);\n        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n        if (finalMessage)\n            this._emit('finalMessage', finalMessage);\n        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n        if (finalContent)\n            this._emit('finalContent', finalContent);\n        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n        if (finalFunctionCall)\n            this._emit('finalFunctionCall', finalFunctionCall);\n        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n        if (finalFunctionCallResult != null)\n            this._emit('finalFunctionCallResult', finalFunctionCallResult);\n        if (this._chatCompletions.some((c) => c.usage)) {\n            this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n        }\n    }\n    async _createChatCompletion(client, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n        const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });\n        this._connected();\n        return this._addChatCompletion((0, parser_1.parseChatCompletion)(chatCompletion, params));\n    }\n    async _runChatCompletion(client, params, options) {\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        return await this._createChatCompletion(client, params, options);\n    }\n    async _runFunctions(client, params, options) {\n        const role = 'function';\n        const { function_call = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        const functionsByName = {};\n        for (const f of params.functions) {\n            functionsByName[f.name || f.function.name] = f;\n        }\n        const functions = params.functions.map((f) => ({\n            name: f.name || f.function.name,\n            parameters: f.parameters,\n            description: f.description,\n        }));\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                function_call,\n                functions,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new error_1.OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.function_call)\n                return;\n            const { name, arguments: args } = message.function_call;\n            const fn = functionsByName[name];\n            if (!fn) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n                    .map((f) => JSON.stringify(f.name))\n                    .join(', ')}. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                this._addMessage({ role, name, content });\n                continue;\n            }\n            let parsed;\n            try {\n                parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n            }\n            catch (error) {\n                this._addMessage({\n                    role,\n                    name,\n                    content: error instanceof Error ? error.message : String(error),\n                });\n                continue;\n            }\n            // @ts-expect-error it can't rule out `never` type.\n            const rawContent = await fn.function(parsed, this);\n            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n            this._addMessage({ role, name, content });\n            if (singleFunctionToCall)\n                return;\n        }\n    }\n    async _runTools(client, params, options) {\n        const role = 'tool';\n        const { tool_choice = 'auto', stream, ...restParams } = params;\n        const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n        // TODO(someday): clean this logic up\n        const inputTools = params.tools.map((tool) => {\n            if ((0, parser_1.isAutoParsableTool)(tool)) {\n                if (!tool.$callback) {\n                    throw new error_1.OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n                }\n                return {\n                    type: 'function',\n                    function: {\n                        function: tool.$callback,\n                        name: tool.function.name,\n                        description: tool.function.description || '',\n                        parameters: tool.function.parameters,\n                        parse: tool.$parseRaw,\n                        strict: true,\n                    },\n                };\n            }\n            return tool;\n        });\n        const functionsByName = {};\n        for (const f of inputTools) {\n            if (f.type === 'function') {\n                functionsByName[f.function.name || f.function.function.name] = f.function;\n            }\n        }\n        const tools = 'tools' in params ?\n            inputTools.map((t) => t.type === 'function' ?\n                {\n                    type: 'function',\n                    function: {\n                        name: t.function.name || t.function.function.name,\n                        parameters: t.function.parameters,\n                        description: t.function.description,\n                        strict: t.function.strict,\n                    },\n                }\n                : t)\n            : undefined;\n        for (const message of params.messages) {\n            this._addMessage(message, false);\n        }\n        for (let i = 0; i < maxChatCompletions; ++i) {\n            const chatCompletion = await this._createChatCompletion(client, {\n                ...restParams,\n                tool_choice,\n                tools,\n                messages: [...this.messages],\n            }, options);\n            const message = chatCompletion.choices[0]?.message;\n            if (!message) {\n                throw new error_1.OpenAIError(`missing message in ChatCompletion response`);\n            }\n            if (!message.tool_calls?.length) {\n                return;\n            }\n            for (const tool_call of message.tool_calls) {\n                if (tool_call.type !== 'function')\n                    continue;\n                const tool_call_id = tool_call.id;\n                const { name, arguments: args } = tool_call.function;\n                const fn = functionsByName[name];\n                if (!fn) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName)\n                        .map((name) => JSON.stringify(name))\n                        .join(', ')}. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                else if (singleFunctionToCall && singleFunctionToCall !== name) {\n                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                let parsed;\n                try {\n                    parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n                }\n                catch (error) {\n                    const content = error instanceof Error ? error.message : String(error);\n                    this._addMessage({ role, tool_call_id, content });\n                    continue;\n                }\n                // @ts-expect-error it can't rule out `never` type.\n                const rawContent = await fn.function(parsed, this);\n                const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n                this._addMessage({ role, tool_call_id, content });\n                if (singleFunctionToCall) {\n                    return;\n                }\n            }\n        }\n        return;\n    }\n}\nexports.AbstractChatCompletionRunner = AbstractChatCompletionRunner;\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n    let i = this.messages.length;\n    while (i-- > 0) {\n        const message = this.messages[i];\n        if ((0, chatCompletionUtils_1.isAssistantMessage)(message)) {\n            const { function_call, ...rest } = message;\n            const ret = {\n                ...rest,\n                content: message.content ?? null,\n                refusal: message.refusal ?? null,\n            };\n            if (function_call) {\n                ret.function_call = function_call;\n            }\n            return ret;\n        }\n    }\n    throw new error_1.OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message?.function_call) {\n            return message.function_call;\n        }\n        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message?.tool_calls?.length) {\n            return message.tool_calls.at(-1)?.function;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n        const message = this.messages[i];\n        if ((0, chatCompletionUtils_1.isFunctionMessage)(message) && message.content != null) {\n            return message.content;\n        }\n        if ((0, chatCompletionUtils_1.isToolMessage)(message) &&\n            message.content != null &&\n            typeof message.content === 'string' &&\n            this.messages.some((x) => x.role === 'assistant' &&\n                x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id))) {\n            return message.content;\n        }\n    }\n    return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n    const total = {\n        completion_tokens: 0,\n        prompt_tokens: 0,\n        total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n        if (usage) {\n            total.completion_tokens += usage.completion_tokens;\n            total.prompt_tokens += usage.prompt_tokens;\n            total.total_tokens += usage.total_tokens;\n        }\n    }\n    return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n    if (params.n != null && params.n > 1) {\n        throw new error_1.OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n    }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n    return (typeof rawContent === 'string' ? rawContent\n        : rawContent === undefined ? 'undefined'\n            : JSON.stringify(rawContent));\n};\n//# sourceMappingURL=AbstractChatCompletionRunner.js.map","import * as Core from \"../core\";\nimport { type CompletionUsage } from \"../resources/completions\";\nimport {\n  type ChatCompletion,\n  type ChatCompletionMessage,\n  type ChatCompletionMessageParam,\n  type ChatCompletionCreateParams,\n  type ChatCompletionTool,\n} from \"../resources/chat/completions\";\nimport { OpenAIError } from \"../error\";\nimport {\n  type RunnableFunction,\n  isRunnableFunctionWithParse,\n  type BaseFunctionsArgs,\n  RunnableToolFunction,\n} from './RunnableFunction';\nimport { ChatCompletionFunctionRunnerParams, ChatCompletionToolRunnerParams } from './ChatCompletionRunner';\nimport {\n  ChatCompletionStreamingFunctionRunnerParams,\n  ChatCompletionStreamingToolRunnerParams,\n} from './ChatCompletionStreamingRunner';\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from './chatCompletionUtils';\nimport { BaseEvents, EventStream } from './EventStream';\nimport { ParsedChatCompletion } from '../resources/beta/chat/completions';\nimport OpenAI from '../index';\nimport { isAutoParsableTool, parseChatCompletion } from \"./parser\";\n\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport interface RunnerOptions extends Core.RequestOptions {\n  /** How many requests to make before canceling. Default 10. */\n  maxChatCompletions?: number;\n}\n\nexport class AbstractChatCompletionRunner<\n  EventTypes extends AbstractChatCompletionRunnerEvents,\n  ParsedT,\n> extends EventStream<EventTypes> {\n  protected _chatCompletions: ParsedChatCompletion<ParsedT>[] = [];\n  messages: ChatCompletionMessageParam[] = [];\n\n  protected _addChatCompletion(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n    chatCompletion: ParsedChatCompletion<ParsedT>,\n  ): ParsedChatCompletion<ParsedT> {\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message as ChatCompletionMessageParam);\n    return chatCompletion;\n  }\n\n  protected _addMessage(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n    message: ChatCompletionMessageParam,\n    emit = true,\n  ) {\n    if (!('content' in message)) message.content = null;\n\n    this.messages.push(message);\n\n    if (emit) {\n      this._emit('message', message);\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content as string);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion(): Promise<ParsedChatCompletion<ParsedT>> {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n\n  #getFinalContent(): string | null {\n    return this.#getFinalMessage().content ?? null;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent(): Promise<string | null> {\n    await this.done();\n    return this.#getFinalContent();\n  }\n\n  #getFinalMessage(): ChatCompletionMessage {\n    let i = this.messages.length;\n    while (i-- > 0) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message)) {\n        const { function_call, ...rest } = message;\n        const ret: ChatCompletionMessage = {\n          ...rest,\n          content: (message as ChatCompletionMessage).content ?? null,\n          refusal: (message as ChatCompletionMessage).refusal ?? null,\n        };\n        if (function_call) {\n          ret.function_call = function_call;\n        }\n        return ret;\n      }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage(): Promise<ChatCompletionMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalFunctionCall(): ChatCompletionMessage.FunctionCall | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message) && message?.function_call) {\n        return message.function_call;\n      }\n      if (isAssistantMessage(message) && message?.tool_calls?.length) {\n        return message.tool_calls.at(-1)?.function;\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall(): Promise<ChatCompletionMessage.FunctionCall | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCall();\n  }\n\n  #getFinalFunctionCallResult(): string | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isFunctionMessage(message) && message.content != null) {\n        return message.content;\n      }\n      if (\n        isToolMessage(message) &&\n        message.content != null &&\n        typeof message.content === 'string' &&\n        this.messages.some(\n          (x) =>\n            x.role === 'assistant' &&\n            x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id),\n        )\n      ) {\n        return message.content;\n      }\n    }\n\n    return;\n  }\n\n  async finalFunctionCallResult(): Promise<string | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCallResult();\n  }\n\n  #calculateTotalUsage(): CompletionUsage {\n    const total: CompletionUsage = {\n      completion_tokens: 0,\n      prompt_tokens: 0,\n      total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n      if (usage) {\n        total.completion_tokens += usage.completion_tokens;\n        total.prompt_tokens += usage.prompt_tokens;\n        total.total_tokens += usage.total_tokens;\n      }\n    }\n    return total;\n  }\n\n  async totalUsage(): Promise<CompletionUsage> {\n    await this.done();\n    return this.#calculateTotalUsage();\n  }\n\n  allChatCompletions(): ChatCompletion[] {\n    return [...this._chatCompletions];\n  }\n\n  protected override _emitFinal(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n  ) {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = this.#getFinalMessage();\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = this.#getFinalContent();\n    if (finalContent) this._emit('finalContent', finalContent);\n\n    const finalFunctionCall = this.#getFinalFunctionCall();\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n\n    const finalFunctionCallResult = this.#getFinalFunctionCallResult();\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n\n    if (this._chatCompletions.some((c) => c.usage)) {\n      this._emit('totalUsage', this.#calculateTotalUsage());\n    }\n  }\n\n  #validateParams(params: ChatCompletionCreateParams): void {\n    if (params.n != null && params.n > 1) {\n      throw new OpenAIError(\n        'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.',\n      );\n    }\n  }\n\n  protected async _createChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ParsedChatCompletion<ParsedT>> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#validateParams(params);\n\n    const chatCompletion = await client.chat.completions.create(\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n  }\n\n  protected async _runChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(client, params, options);\n  }\n\n  protected async _runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    client: OpenAI,\n    params:\n      | ChatCompletionFunctionRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'function' as const;\n    const { function_call = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n\n    const functions: ChatCompletionCreateParams.Function[] = params.functions.map(\n      (f): ChatCompletionCreateParams.Function => ({\n        name: f.name || f.function.name,\n        parameters: f.parameters as Record<string, unknown>,\n        description: f.description,\n      }),\n    );\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        client,\n        {\n          ...restParams,\n          function_call,\n          functions,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.function_call) return;\n      const { name, arguments: args } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n          .map((f) => JSON.stringify(f.name))\n          .join(', ')}. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(\n          singleFunctionToCall,\n        )} requested. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      }\n\n      let parsed;\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error),\n        });\n        continue;\n      }\n\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = this.#stringifyFunctionCallResult(rawContent);\n\n      this._addMessage({ role, name, content });\n\n      if (singleFunctionToCall) return;\n    }\n  }\n\n  protected async _runTools<FunctionsArgs extends BaseFunctionsArgs>(\n    client: OpenAI,\n    params:\n      | ChatCompletionToolRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingToolRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'tool' as const;\n    const { tool_choice = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    // TODO(someday): clean this logic up\n    const inputTools = params.tools.map((tool): RunnableToolFunction<any> => {\n      if (isAutoParsableTool(tool)) {\n        if (!tool.$callback) {\n          throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n        }\n\n        return {\n          type: 'function',\n          function: {\n            function: tool.$callback,\n            name: tool.function.name,\n            description: tool.function.description || '',\n            parameters: tool.function.parameters as any,\n            parse: tool.$parseRaw,\n            strict: true,\n          },\n        };\n      }\n\n      return tool as any as RunnableToolFunction<any>;\n    });\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of inputTools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n\n    const tools: ChatCompletionTool[] =\n      'tools' in params ?\n        inputTools.map((t) =>\n          t.type === 'function' ?\n            {\n              type: 'function',\n              function: {\n                name: t.function.name || t.function.function.name,\n                parameters: t.function.parameters as Record<string, unknown>,\n                description: t.function.description,\n                strict: t.function.strict,\n              },\n            }\n          : (t as unknown as ChatCompletionTool),\n        )\n      : (undefined as any);\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        client,\n        {\n          ...restParams,\n          tool_choice,\n          tools,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.tool_calls?.length) {\n        return;\n      }\n\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const { name, arguments: args } = tool_call.function;\n        const fn = functionsByName[name];\n\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(\n            functionsByName,\n          )\n            .map((name) => JSON.stringify(name))\n            .join(', ')}. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(\n            singleFunctionToCall,\n          )} requested. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = this.#stringifyFunctionCallResult(rawContent);\n        this._addMessage({ role, tool_call_id, content });\n\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n\n    return;\n  }\n\n  #stringifyFunctionCallResult(rawContent: unknown): string {\n    return (\n      typeof rawContent === 'string' ? rawContent\n      : rawContent === undefined ? 'undefined'\n      : JSON.stringify(rawContent)\n    );\n  }\n}\n\nexport interface AbstractChatCompletionRunnerEvents extends BaseEvents {\n  functionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  message: (message: ChatCompletionMessageParam) => void;\n  chatCompletion: (completion: ChatCompletion) => void;\n  finalContent: (contentSnapshot: string) => void;\n  finalMessage: (message: ChatCompletionMessageParam) => void;\n  finalChatCompletion: (completion: ChatCompletion) => void;\n  finalFunctionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  functionCallResult: (content: string) => void;\n  finalFunctionCallResult: (content: string) => void;\n  totalUsage: (usage: CompletionUsage) => void;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParsingToolFunction = exports.ParsingFunction = exports.isRunnableFunctionWithParse = void 0;\nfunction isRunnableFunctionWithParse(fn) {\n    return typeof fn.parse === 'function';\n}\nexports.isRunnableFunctionWithParse = isRunnableFunctionWithParse;\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */\nclass ParsingFunction {\n    constructor(input) {\n        this.function = input.function;\n        this.parse = input.parse;\n        this.parameters = input.parameters;\n        this.description = input.description;\n        this.name = input.name;\n    }\n}\nexports.ParsingFunction = ParsingFunction;\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */\nclass ParsingToolFunction {\n    constructor(input) {\n        this.type = 'function';\n        this.function = input;\n    }\n}\nexports.ParsingToolFunction = ParsingToolFunction;\n//# sourceMappingURL=RunnableFunction.js.map","import { type ChatCompletionRunner } from './ChatCompletionRunner';\nimport { type ChatCompletionStreamingRunner } from './ChatCompletionStreamingRunner';\nimport { JSONSchema } from './jsonschema';\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nexport type RunnableFunctionWithParse<Args extends object> = {\n  /**\n   * @param args the return value from `parse`.\n   * @param runner the runner evaluating this callback.\n   * @returns a string to send back to OpenAI.\n   */\n  function: (\n    args: Args,\n    runner: ChatCompletionRunner<unknown> | ChatCompletionStreamingRunner<unknown>,\n  ) => PromiseOrValue<unknown>;\n  /**\n   * @param input the raw args from the OpenAI function call.\n   * @returns the parsed arguments to pass to `function`\n   */\n  parse: (input: string) => PromiseOrValue<Args>;\n  /**\n   * The parameters the function accepts, describes as a JSON Schema object.\n   */\n  parameters: JSONSchema;\n  /**\n   * A description of what the function does, used by the model to choose when and how to call the function.\n   */\n  description: string;\n  /**\n   * The name of the function to be called. Will default to function.name if omitted.\n   */\n  name?: string | undefined;\n  strict?: boolean | undefined;\n};\n\nexport type RunnableFunctionWithoutParse = {\n  /**\n   * @param args the raw args from the OpenAI function call.\n   * @returns a string to send back to OpenAI\n   */\n  function: (\n    args: string,\n    runner: ChatCompletionRunner<unknown> | ChatCompletionStreamingRunner<unknown>,\n  ) => PromiseOrValue<unknown>;\n  /**\n   * The parameters the function accepts, describes as a JSON Schema object.\n   */\n  parameters: JSONSchema;\n  /**\n   * A description of what the function does, used by the model to choose when and how to call the function.\n   */\n  description: string;\n  /**\n   * The name of the function to be called. Will default to function.name if omitted.\n   */\n  name?: string | undefined;\n  strict?: boolean | undefined;\n};\n\nexport type RunnableFunction<Args extends object | string> =\n  Args extends string ? RunnableFunctionWithoutParse\n  : Args extends object ? RunnableFunctionWithParse<Args>\n  : never;\n\nexport type RunnableToolFunction<Args extends object | string> =\n  Args extends string ? RunnableToolFunctionWithoutParse\n  : Args extends object ? RunnableToolFunctionWithParse<Args>\n  : never;\n\nexport type RunnableToolFunctionWithoutParse = {\n  type: 'function';\n  function: RunnableFunctionWithoutParse;\n};\nexport type RunnableToolFunctionWithParse<Args extends object> = {\n  type: 'function';\n  function: RunnableFunctionWithParse<Args>;\n};\n\nexport function isRunnableFunctionWithParse<Args extends object>(\n  fn: any,\n): fn is RunnableFunctionWithParse<Args> {\n  return typeof (fn as any).parse === 'function';\n}\n\nexport type BaseFunctionsArgs = readonly (object | string)[];\n\nexport type RunnableFunctions<FunctionsArgs extends BaseFunctionsArgs> =\n  [any[]] extends [FunctionsArgs] ? readonly RunnableFunction<any>[]\n  : {\n      [Index in keyof FunctionsArgs]: Index extends number ? RunnableFunction<FunctionsArgs[Index]>\n      : FunctionsArgs[Index];\n    };\n\nexport type RunnableTools<FunctionsArgs extends BaseFunctionsArgs> =\n  [any[]] extends [FunctionsArgs] ? readonly RunnableToolFunction<any>[]\n  : {\n      [Index in keyof FunctionsArgs]: Index extends number ? RunnableToolFunction<FunctionsArgs[Index]>\n      : FunctionsArgs[Index];\n    };\n\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n *\n * @deprecated - please use ParsingToolFunction instead.\n */\nexport class ParsingFunction<Args extends object> {\n  function: RunnableFunctionWithParse<Args>['function'];\n  parse: RunnableFunctionWithParse<Args>['parse'];\n  parameters: RunnableFunctionWithParse<Args>['parameters'];\n  description: RunnableFunctionWithParse<Args>['description'];\n  name?: RunnableFunctionWithParse<Args>['name'];\n\n  constructor(input: RunnableFunctionWithParse<Args>) {\n    this.function = input.function;\n    this.parse = input.parse;\n    this.parameters = input.parameters;\n    this.description = input.description;\n    this.name = input.name;\n  }\n}\n\n/**\n * This is helper class for passing a `function` and `parse` where the `function`\n * argument type matches the `parse` return type.\n */\nexport class ParsingToolFunction<Args extends object> {\n  type: 'function';\n  function: RunnableFunctionWithParse<Args>;\n\n  constructor(input: RunnableFunctionWithParse<Args>) {\n    this.type = 'function';\n    this.function = input;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPresent = exports.isToolMessage = exports.isFunctionMessage = exports.isAssistantMessage = void 0;\nconst isAssistantMessage = (message) => {\n    return message?.role === 'assistant';\n};\nexports.isAssistantMessage = isAssistantMessage;\nconst isFunctionMessage = (message) => {\n    return message?.role === 'function';\n};\nexports.isFunctionMessage = isFunctionMessage;\nconst isToolMessage = (message) => {\n    return message?.role === 'tool';\n};\nexports.isToolMessage = isToolMessage;\nfunction isPresent(obj) {\n    return obj != null;\n}\nexports.isPresent = isPresent;\n//# sourceMappingURL=chatCompletionUtils.js.map","import {\n  type ChatCompletionAssistantMessageParam,\n  type ChatCompletionFunctionMessageParam,\n  type ChatCompletionMessageParam,\n  type ChatCompletionToolMessageParam,\n} from \"../resources\";\n\nexport const isAssistantMessage = (\n  message: ChatCompletionMessageParam | null | undefined,\n): message is ChatCompletionAssistantMessageParam => {\n  return message?.role === 'assistant';\n};\n\nexport const isFunctionMessage = (\n  message: ChatCompletionMessageParam | null | undefined,\n): message is ChatCompletionFunctionMessageParam => {\n  return message?.role === 'function';\n};\n\nexport const isToolMessage = (\n  message: ChatCompletionMessageParam | null | undefined,\n): message is ChatCompletionToolMessageParam => {\n  return message?.role === 'tool';\n};\n\nexport function isPresent<T>(obj: T | null | undefined): obj is T {\n  return obj != null;\n}\n","\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventStream = void 0;\nconst error_1 = require(\"openai/error\");\nclass EventStream {\n    constructor() {\n        _EventStream_instances.add(this);\n        this.controller = new AbortController();\n        _EventStream_connectedPromise.set(this, void 0);\n        _EventStream_resolveConnectedPromise.set(this, () => { });\n        _EventStream_rejectConnectedPromise.set(this, () => { });\n        _EventStream_endPromise.set(this, void 0);\n        _EventStream_resolveEndPromise.set(this, () => { });\n        _EventStream_rejectEndPromise.set(this, () => { });\n        _EventStream_listeners.set(this, {});\n        _EventStream_ended.set(this, false);\n        _EventStream_errored.set(this, false);\n        _EventStream_aborted.set(this, false);\n        _EventStream_catchingPromiseCreated.set(this, false);\n        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => { });\n        __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => { });\n    }\n    _run(executor) {\n        // Unfortunately if we call `executor()` immediately we get runtime errors about\n        // references to `this` before the `super()` constructor call returns.\n        setTimeout(() => {\n            executor().then(() => {\n                this._emitFinal();\n                this._emit('end');\n            }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n        }, 0);\n    }\n    _connected() {\n        if (this.ended)\n            return;\n        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n        this._emit('connect');\n    }\n    get ended() {\n        return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n    }\n    get errored() {\n        return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n    }\n    get aborted() {\n        return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this ChatCompletionStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n        await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any events after end\n        if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n            return;\n        }\n        if (event === 'end') {\n            __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n            __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n        if (listeners) {\n            __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.finalChatCompletion()\n                // - etc.\n                Promise.reject(error);\n            }\n            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() { }\n}\nexports.EventStream = EventStream;\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n    __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n    if (error instanceof Error && error.name === 'AbortError') {\n        error = new error_1.APIUserAbortError();\n    }\n    if (error instanceof error_1.APIUserAbortError) {\n        __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n    }\n    if (error instanceof error_1.OpenAIError) {\n        return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n        const openAIError = new error_1.OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n    }\n    return this._emit('error', new error_1.OpenAIError(String(error)));\n};\n//# sourceMappingURL=EventStream.js.map","import { APIUserAbortError, OpenAIError } from \"../error\";\n\nexport class EventStream<EventTypes extends BaseEvents> {\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: OpenAIError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: OpenAIError) => void = () => {};\n\n  #listeners: {\n    [Event in keyof EventTypes]?: EventListeners<EventTypes, Event>;\n  } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  protected _run(this: EventStream<EventTypes>, executor: () => Promise<any>) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, this.#handleError.bind(this));\n    }, 0);\n  }\n\n  protected _connected(this: EventStream<EventTypes>) {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\n    const listeners: EventListeners<EventTypes, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once<Event extends keyof EventTypes>(event: Event, listener: EventListener<EventTypes, Event>): this {\n    const listeners: EventListeners<EventTypes, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof EventTypes>(\n    event: Event,\n  ): Promise<\n    EventParameters<EventTypes, Event> extends [infer Param] ? Param\n    : EventParameters<EventTypes, Event> extends [] ? void\n    : EventParameters<EventTypes, Event>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  #handleError(this: EventStream<EventTypes>, error: unknown) {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const openAIError: OpenAIError = new OpenAIError(error.message);\n      // @ts-ignore\n      openAIError.cause = error;\n      return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n  }\n\n  _emit<Event extends keyof BaseEvents>(event: Event, ...args: EventParameters<BaseEvents, Event>): void;\n  _emit<Event extends keyof EventTypes>(event: Event, ...args: EventParameters<EventTypes, Event>): void;\n  _emit<Event extends keyof EventTypes>(\n    this: EventStream<EventTypes>,\n    event: Event,\n    ...args: EventParameters<EventTypes, Event>\n  ) {\n    // make sure we don't emit any events after end\n    if (this.#ended) {\n      return;\n    }\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: EventListeners<EventTypes, Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...(args as any)));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as OpenAIError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal(): void {}\n}\n\ntype EventListener<Events, EventType extends keyof Events> = Events[EventType];\n\ntype EventListeners<Events, EventType extends keyof Events> = Array<{\n  listener: EventListener<Events, EventType>;\n  once?: boolean;\n}>;\n\nexport type EventParameters<Events, EventType extends keyof Events> = {\n  [Event in EventType]: EventListener<Events, EventType> extends (...args: infer P) => any ? P : never;\n}[EventType];\n\nexport interface BaseEvents {\n  connect: () => void;\n  error: (error: OpenAIError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateInputTools = exports.hasAutoParseableInput = exports.shouldParseToolCall = exports.parseChatCompletion = exports.maybeParseChatCompletion = exports.isAutoParsableTool = exports.makeParseableTool = exports.isAutoParsableResponseFormat = exports.makeParseableResponseFormat = void 0;\nconst error_1 = require(\"openai/error\");\nfunction makeParseableResponseFormat(response_format, parser) {\n    const obj = { ...response_format };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-response-format',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexports.makeParseableResponseFormat = makeParseableResponseFormat;\nfunction isAutoParsableResponseFormat(response_format) {\n    return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexports.isAutoParsableResponseFormat = isAutoParsableResponseFormat;\nfunction makeParseableTool(tool, { parser, callback, }) {\n    const obj = { ...tool };\n    Object.defineProperties(obj, {\n        $brand: {\n            value: 'auto-parseable-tool',\n            enumerable: false,\n        },\n        $parseRaw: {\n            value: parser,\n            enumerable: false,\n        },\n        $callback: {\n            value: callback,\n            enumerable: false,\n        },\n    });\n    return obj;\n}\nexports.makeParseableTool = makeParseableTool;\nfunction isAutoParsableTool(tool) {\n    return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexports.isAutoParsableTool = isAutoParsableTool;\nfunction maybeParseChatCompletion(completion, params) {\n    if (!params || !hasAutoParseableInput(params)) {\n        return {\n            ...completion,\n            choices: completion.choices.map((choice) => ({\n                ...choice,\n                message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] },\n            })),\n        };\n    }\n    return parseChatCompletion(completion, params);\n}\nexports.maybeParseChatCompletion = maybeParseChatCompletion;\nfunction parseChatCompletion(completion, params) {\n    const choices = completion.choices.map((choice) => {\n        if (choice.finish_reason === 'length') {\n            throw new error_1.LengthFinishReasonError();\n        }\n        if (choice.finish_reason === 'content_filter') {\n            throw new error_1.ContentFilterFinishReasonError();\n        }\n        return {\n            ...choice,\n            message: {\n                ...choice.message,\n                tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? [],\n                parsed: choice.message.content && !choice.message.refusal ?\n                    parseResponseFormat(params, choice.message.content)\n                    : null,\n            },\n        };\n    });\n    return { ...completion, choices };\n}\nexports.parseChatCompletion = parseChatCompletion;\nfunction parseResponseFormat(params, content) {\n    if (params.response_format?.type !== 'json_schema') {\n        return null;\n    }\n    if (params.response_format?.type === 'json_schema') {\n        if ('$parseRaw' in params.response_format) {\n            const response_format = params.response_format;\n            return response_format.$parseRaw(content);\n        }\n        return JSON.parse(content);\n    }\n    return null;\n}\nfunction parseToolCall(params, toolCall) {\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return {\n        ...toolCall,\n        function: {\n            ...toolCall.function,\n            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n                : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n                    : null,\n        },\n    };\n}\nfunction shouldParseToolCall(params, toolCall) {\n    if (!params) {\n        return false;\n    }\n    const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n    return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexports.shouldParseToolCall = shouldParseToolCall;\nfunction hasAutoParseableInput(params) {\n    if (isAutoParsableResponseFormat(params.response_format)) {\n        return true;\n    }\n    return (params.tools?.some((t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)) ?? false);\n}\nexports.hasAutoParseableInput = hasAutoParseableInput;\nfunction validateInputTools(tools) {\n    for (const tool of tools ?? []) {\n        if (tool.type !== 'function') {\n            throw new error_1.OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n        }\n        if (tool.function.strict !== true) {\n            throw new error_1.OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n        }\n    }\n}\nexports.validateInputTools = validateInputTools;\n//# sourceMappingURL=parser.js.map","import {\n  ChatCompletion,\n  ChatCompletionCreateParams,\n  ChatCompletionMessageToolCall,\n  ChatCompletionTool,\n} from '../resources/chat/completions';\nimport {\n  ChatCompletionStreamingToolRunnerParams,\n  ChatCompletionStreamParams,\n  ChatCompletionToolRunnerParams,\n  ParsedChatCompletion,\n  ParsedChoice,\n  ParsedFunctionToolCall,\n} from '../resources/beta/chat/completions';\nimport { ResponseFormatJSONSchema } from '../resources/shared';\nimport { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error\";\n\ntype AnyChatCompletionCreateParams =\n  | ChatCompletionCreateParams\n  | ChatCompletionToolRunnerParams<any>\n  | ChatCompletionStreamingToolRunnerParams<any>\n  | ChatCompletionStreamParams;\n\nexport type ExtractParsedContentFromParams<Params extends AnyChatCompletionCreateParams> =\n  Params['response_format'] extends AutoParseableResponseFormat<infer P> ? P : null;\n\nexport type AutoParseableResponseFormat<ParsedT> = ResponseFormatJSONSchema & {\n  __output: ParsedT; // type-level only\n\n  $brand: 'auto-parseable-response-format';\n  $parseRaw(content: string): ParsedT;\n};\n\nexport function makeParseableResponseFormat<ParsedT>(\n  response_format: ResponseFormatJSONSchema,\n  parser: (content: string) => ParsedT,\n): AutoParseableResponseFormat<ParsedT> {\n  const obj = { ...response_format };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableResponseFormat<ParsedT>;\n}\n\nexport function isAutoParsableResponseFormat<ParsedT>(\n  response_format: any,\n): response_format is AutoParseableResponseFormat<ParsedT> {\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\n\ntype ToolOptions = {\n  name: string;\n  arguments: any;\n  function?: ((args: any) => any) | undefined;\n};\n\nexport type AutoParseableTool<\n  OptionsT extends ToolOptions,\n  HasFunction = OptionsT['function'] extends Function ? true : false,\n> = ChatCompletionTool & {\n  __arguments: OptionsT['arguments']; // type-level only\n  __name: OptionsT['name']; // type-level only\n  __hasFunction: HasFunction; // type-level only\n\n  $brand: 'auto-parseable-tool';\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\n  $parseRaw(args: string): OptionsT['arguments'];\n};\n\nexport function makeParseableTool<OptionsT extends ToolOptions>(\n  tool: ChatCompletionTool,\n  {\n    parser,\n    callback,\n  }: {\n    parser: (content: string) => OptionsT['arguments'];\n    callback: ((args: any) => any) | undefined;\n  },\n): AutoParseableTool<OptionsT['arguments']> {\n  const obj = { ...tool };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n    $callback: {\n      value: callback,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableTool<OptionsT['arguments']>;\n}\n\nexport function isAutoParsableTool(tool: any): tool is AutoParseableTool<any> {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\n\nexport function maybeParseChatCompletion<\n  Params extends ChatCompletionCreateParams | null,\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...completion,\n      choices: completion.choices.map((choice) => ({\n        ...choice,\n        message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] },\n      })),\n    };\n  }\n\n  return parseChatCompletion(completion, params);\n}\n\nexport function parseChatCompletion<\n  Params extends ChatCompletionCreateParams,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\n  const choices: Array<ParsedChoice<ParsedT>> = completion.choices.map((choice): ParsedChoice<ParsedT> => {\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n\n    return {\n      ...choice,\n      message: {\n        ...choice.message,\n        tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? [],\n        parsed:\n          choice.message.content && !choice.message.refusal ?\n            parseResponseFormat(params, choice.message.content)\n          : null,\n      },\n    };\n  });\n\n  return { ...completion, choices };\n}\n\nfunction parseResponseFormat<\n  Params extends ChatCompletionCreateParams,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(params: Params, content: string): ParsedT | null {\n  if (params.response_format?.type !== 'json_schema') {\n    return null;\n  }\n\n  if (params.response_format?.type === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format as AutoParseableResponseFormat<ParsedT>;\n\n      return response_format.$parseRaw(content);\n    }\n\n    return JSON.parse(content);\n  }\n\n  return null;\n}\n\nfunction parseToolCall<Params extends ChatCompletionCreateParams>(\n  params: Params,\n  toolCall: ChatCompletionMessageToolCall,\n): ParsedFunctionToolCall {\n  const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n  return {\n    ...toolCall,\n    function: {\n      ...toolCall.function,\n      parsed_arguments:\n        isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n        : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n        : null,\n    },\n  };\n}\n\nexport function shouldParseToolCall(\n  params: ChatCompletionCreateParams | null | undefined,\n  toolCall: ChatCompletionMessageToolCall,\n): boolean {\n  if (!params) {\n    return false;\n  }\n\n  const inputTool = params.tools?.find((inputTool) => inputTool.function?.name === toolCall.function.name);\n  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\n\nexport function hasAutoParseableInput(params: AnyChatCompletionCreateParams): boolean {\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n\n  return (\n    params.tools?.some(\n      (t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true),\n    ) ?? false\n  );\n}\n\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\n      );\n    }\n\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\n      );\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatCompletionStreamingRunner = void 0;\nconst ChatCompletionStream_1 = require(\"./ChatCompletionStream.js\");\nclass ChatCompletionStreamingRunner extends ChatCompletionStream_1.ChatCompletionStream {\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    /** @deprecated - please use `runTools` instead. */\n    static runFunctions(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(null);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n        };\n        runner._run(() => runner._runFunctions(client, params, opts));\n        return runner;\n    }\n    static runTools(client, params, options) {\n        const runner = new ChatCompletionStreamingRunner(\n        // @ts-expect-error TODO these types are incompatible\n        params);\n        const opts = {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n        };\n        runner._run(() => runner._runTools(client, params, opts));\n        return runner;\n    }\n}\nexports.ChatCompletionStreamingRunner = ChatCompletionStreamingRunner;\n//# sourceMappingURL=ChatCompletionStreamingRunner.js.map","import {\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParamsStreaming,\n} from \"../resources/chat/completions\";\nimport { RunnerOptions, type AbstractChatCompletionRunnerEvents } from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { RunnableTools, type BaseFunctionsArgs, type RunnableFunctions } from './RunnableFunction';\nimport { ChatCompletionSnapshot, ChatCompletionStream } from './ChatCompletionStream';\nimport OpenAI from \"../index\";\nimport { AutoParseableTool } from \"./parser\";\n\nexport interface ChatCompletionStreamEvents extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n}\n\nexport type ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs extends BaseFunctionsArgs> = Omit<\n  ChatCompletionCreateParamsStreaming,\n  'functions'\n> & {\n  functions: RunnableFunctions<FunctionsArgs>;\n};\n\nexport type ChatCompletionStreamingToolRunnerParams<FunctionsArgs extends BaseFunctionsArgs> = Omit<\n  ChatCompletionCreateParamsStreaming,\n  'tools'\n> & {\n  tools: RunnableTools<FunctionsArgs> | AutoParseableTool<any, true>[];\n};\n\nexport class ChatCompletionStreamingRunner<ParsedT = null>\n  extends ChatCompletionStream<ParsedT>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  static override fromReadableStream(stream: ReadableStream): ChatCompletionStreamingRunner<null> {\n    const runner = new ChatCompletionStreamingRunner(null);\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  /** @deprecated - please use `runTools` instead. */\n  static runFunctions<T extends (string | object)[]>(\n    client: OpenAI,\n    params: ChatCompletionStreamingFunctionRunnerParams<T>,\n    options?: RunnerOptions,\n  ): ChatCompletionStreamingRunner<null> {\n    const runner = new ChatCompletionStreamingRunner(null);\n    const opts = {\n      ...options,\n      headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runFunctions' },\n    };\n    runner._run(() => runner._runFunctions(client, params, opts));\n    return runner;\n  }\n\n  static runTools<T extends (string | object)[], ParsedT = null>(\n    client: OpenAI,\n    params: ChatCompletionStreamingToolRunnerParams<T>,\n    options?: RunnerOptions,\n  ): ChatCompletionStreamingRunner<ParsedT> {\n    const runner = new ChatCompletionStreamingRunner<ParsedT>(\n      // @ts-expect-error TODO these types are incompatible\n      params,\n    );\n    const opts = {\n      ...options,\n      headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },\n    };\n    runner._run(() => runner._runTools(client, params, opts));\n    return runner;\n  }\n}\n","\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChatCompletionStream = void 0;\nconst error_1 = require(\"openai/error\");\nconst AbstractChatCompletionRunner_1 = require(\"./AbstractChatCompletionRunner.js\");\nconst streaming_1 = require(\"openai/streaming\");\nconst parser_1 = require(\"openai/lib/parser\");\nconst parser_2 = require(\"../_vendor/partial-json-parser/parser.js\");\nclass ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n    constructor(params) {\n        super();\n        _ChatCompletionStream_instances.add(this);\n        _ChatCompletionStream_params.set(this, void 0);\n        _ChatCompletionStream_choiceEventStates.set(this, void 0);\n        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    }\n    get currentChatCompletionSnapshot() {\n        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new ChatCompletionStream(null);\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createChatCompletion(client, params, options) {\n        const runner = new ChatCompletionStream(params);\n        runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    async _createChatCompletion(client, params, options) {\n        super._createChatCompletion;\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const chunk of stream) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n        this._connected();\n        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n        let chatId;\n        for await (const chunk of stream) {\n            if (chatId && chatId !== chunk.id) {\n                // A new request has been made.\n                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n            }\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n            chatId = chunk.id;\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n    }\n    [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n        if (this.ended)\n            return;\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n        if (state) {\n            return state;\n        }\n        state = {\n            content_done: false,\n            refusal_done: false,\n            logprobs_content_done: false,\n            logprobs_refusal_done: false,\n            done_tool_calls: new Set(),\n            current_tool_call_index: null,\n        };\n        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n        return state;\n    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n        if (this.ended)\n            return;\n        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n        this._emit('chunk', chunk, completion);\n        for (const choice of chunk.choices) {\n            const choiceSnapshot = completion.choices[choice.index];\n            if (choice.delta.content != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.content) {\n                this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n                this._emit('content.delta', {\n                    delta: choice.delta.content,\n                    snapshot: choiceSnapshot.message.content,\n                    parsed: choiceSnapshot.message.parsed,\n                });\n            }\n            if (choice.delta.refusal != null &&\n                choiceSnapshot.message?.role === 'assistant' &&\n                choiceSnapshot.message?.refusal) {\n                this._emit('refusal.delta', {\n                    delta: choice.delta.refusal,\n                    snapshot: choiceSnapshot.message.refusal,\n                });\n            }\n            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.content.delta', {\n                    content: choice.logprobs?.content,\n                    snapshot: choiceSnapshot.logprobs?.content ?? [],\n                });\n            }\n            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n                this._emit('logprobs.refusal.delta', {\n                    refusal: choice.logprobs?.refusal,\n                    snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n                });\n            }\n            const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n            if (choiceSnapshot.finish_reason) {\n                __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                if (state.current_tool_call_index != null) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                }\n            }\n            for (const toolCall of choice.delta.tool_calls ?? []) {\n                if (state.current_tool_call_index !== toolCall.index) {\n                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n                    // new tool call started, the previous one is done\n                    if (state.current_tool_call_index != null) {\n                        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n                    }\n                }\n                state.current_tool_call_index = toolCall.index;\n            }\n            for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n                if (!toolCallSnapshot?.type) {\n                    continue;\n                }\n                if (toolCallSnapshot?.type === 'function') {\n                    this._emit('tool_calls.function.arguments.delta', {\n                        name: toolCallSnapshot.function?.name,\n                        index: toolCallDelta.index,\n                        arguments: toolCallSnapshot.function.arguments,\n                        parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n                        arguments_delta: toolCallDelta.function?.arguments ?? '',\n                    });\n                }\n                else {\n                    assertNever(toolCallSnapshot?.type);\n                }\n            }\n        }\n    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (state.done_tool_calls.has(toolCallIndex)) {\n            // we've already fired the done event\n            return;\n        }\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n        if (!toolCallSnapshot) {\n            throw new Error('no tool call snapshot');\n        }\n        if (!toolCallSnapshot.type) {\n            throw new Error('tool call snapshot missing `type`');\n        }\n        if (toolCallSnapshot.type === 'function') {\n            const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.tools?.find((tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n            this._emit('tool_calls.function.arguments.done', {\n                name: toolCallSnapshot.function.name,\n                index: toolCallIndex,\n                arguments: toolCallSnapshot.function.arguments,\n                parsed_arguments: (0, parser_1.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n                    : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n                        : null,\n            });\n        }\n        else {\n            assertNever(toolCallSnapshot.type);\n        }\n    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n        if (choiceSnapshot.message.content && !state.content_done) {\n            state.content_done = true;\n            const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n            this._emit('content.done', {\n                content: choiceSnapshot.message.content,\n                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null,\n            });\n        }\n        if (choiceSnapshot.message.refusal && !state.refusal_done) {\n            state.refusal_done = true;\n            this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n        }\n        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n            state.logprobs_content_done = true;\n            this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n        }\n        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n            state.logprobs_refusal_done = true;\n            this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n        }\n    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n        if (this.ended) {\n            throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        if (!snapshot) {\n            throw new error_1.OpenAIError(`request ended without sending any chunks`);\n        }\n        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")?.response_format;\n        if ((0, parser_1.isAutoParsableResponseFormat)(responseFormat)) {\n            return responseFormat;\n        }\n        return null;\n    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n        var _a, _b, _c, _d;\n        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n        const { choices, ...rest } = chunk;\n        if (!snapshot) {\n            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n                ...rest,\n                choices: [],\n            }, \"f\");\n        }\n        else {\n            Object.assign(snapshot, rest);\n        }\n        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n            let choice = snapshot.choices[index];\n            if (!choice) {\n                choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n            }\n            if (logprobs) {\n                if (!choice.logprobs) {\n                    choice.logprobs = Object.assign({}, logprobs);\n                }\n                else {\n                    const { content, refusal, ...rest } = logprobs;\n                    assertIsEmpty(rest);\n                    Object.assign(choice.logprobs, rest);\n                    if (content) {\n                        (_a = choice.logprobs).content ?? (_a.content = []);\n                        choice.logprobs.content.push(...content);\n                    }\n                    if (refusal) {\n                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);\n                        choice.logprobs.refusal.push(...refusal);\n                    }\n                }\n            }\n            if (finish_reason) {\n                choice.finish_reason = finish_reason;\n                if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && (0, parser_1.hasAutoParseableInput)(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n                    if (finish_reason === 'length') {\n                        throw new error_1.LengthFinishReasonError();\n                    }\n                    if (finish_reason === 'content_filter') {\n                        throw new error_1.ContentFilterFinishReasonError();\n                    }\n                }\n            }\n            Object.assign(choice, other);\n            if (!delta)\n                continue; // Shouldn't happen; just in case.\n            const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n            assertIsEmpty(rest);\n            Object.assign(choice.message, rest);\n            if (refusal) {\n                choice.message.refusal = (choice.message.refusal || '') + refusal;\n            }\n            if (role)\n                choice.message.role = role;\n            if (function_call) {\n                if (!choice.message.function_call) {\n                    choice.message.function_call = function_call;\n                }\n                else {\n                    if (function_call.name)\n                        choice.message.function_call.name = function_call.name;\n                    if (function_call.arguments) {\n                        (_c = choice.message.function_call).arguments ?? (_c.arguments = '');\n                        choice.message.function_call.arguments += function_call.arguments;\n                    }\n                }\n            }\n            if (content) {\n                choice.message.content = (choice.message.content || '') + content;\n                if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n                    choice.message.parsed = (0, parser_2.partialParse)(choice.message.content);\n                }\n            }\n            if (tool_calls) {\n                if (!choice.message.tool_calls)\n                    choice.message.tool_calls = [];\n                for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n                    const tool_call = ((_d = choice.message.tool_calls)[index] ?? (_d[index] = {}));\n                    Object.assign(tool_call, rest);\n                    if (id)\n                        tool_call.id = id;\n                    if (type)\n                        tool_call.type = type;\n                    if (fn)\n                        tool_call.function ?? (tool_call.function = { name: fn.name ?? '', arguments: '' });\n                    if (fn?.name)\n                        tool_call.function.name = fn.name;\n                    if (fn?.arguments) {\n                        tool_call.function.arguments += fn.arguments;\n                        if ((0, parser_1.shouldParseToolCall)(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n                            tool_call.function.parsed_arguments = (0, parser_2.partialParse)(tool_call.function.arguments);\n                        }\n                    }\n                }\n            }\n        }\n        return snapshot;\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('chunk', (chunk) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(chunk);\n            }\n            else {\n                pushQueue.push(chunk);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\nexports.ChatCompletionStream = ChatCompletionStream;\nfunction finalizeChatCompletion(snapshot, params) {\n    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n    const completion = {\n        ...rest,\n        id,\n        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {\n            if (!finish_reason) {\n                throw new error_1.OpenAIError(`missing finish_reason for choice ${index}`);\n            }\n            const { content = null, function_call, tool_calls, ...messageRest } = message;\n            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n            if (!role) {\n                throw new error_1.OpenAIError(`missing role for choice ${index}`);\n            }\n            if (function_call) {\n                const { arguments: args, name } = function_call;\n                if (args == null) {\n                    throw new error_1.OpenAIError(`missing function_call.arguments for choice ${index}`);\n                }\n                if (!name) {\n                    throw new error_1.OpenAIError(`missing function_call.name for choice ${index}`);\n                }\n                return {\n                    ...choiceRest,\n                    message: {\n                        content,\n                        function_call: { arguments: args, name },\n                        role,\n                        refusal: message.refusal ?? null,\n                    },\n                    finish_reason,\n                    index,\n                    logprobs,\n                };\n            }\n            if (tool_calls) {\n                return {\n                    ...choiceRest,\n                    index,\n                    finish_reason,\n                    logprobs,\n                    message: {\n                        ...messageRest,\n                        role,\n                        content,\n                        refusal: message.refusal ?? null,\n                        tool_calls: tool_calls.map((tool_call, i) => {\n                            const { function: fn, type, id, ...toolRest } = tool_call;\n                            const { arguments: args, name, ...fnRest } = fn || {};\n                            if (id == null) {\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                            }\n                            if (type == null) {\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                            }\n                            if (name == null) {\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`);\n                            }\n                            if (args == null) {\n                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`);\n                            }\n                            return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n                        }),\n                    },\n                };\n            }\n            return {\n                ...choiceRest,\n                message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n                finish_reason,\n                index,\n                logprobs,\n            };\n        }),\n        created,\n        model,\n        object: 'chat.completion',\n        ...(system_fingerprint ? { system_fingerprint } : {}),\n    };\n    return (0, parser_1.maybeParseChatCompletion)(completion, params);\n}\nfunction str(x) {\n    return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty(obj) {\n    return;\n}\nfunction assertNever(_x) { }\n//# sourceMappingURL=ChatCompletionStream.js.map","import * as Core from \"../core\";\nimport {\n  OpenAIError,\n  APIUserAbortError,\n  LengthFinishReasonError,\n  ContentFilterFinishReasonError,\n} from \"../error\";\nimport {\n  ChatCompletionTokenLogprob,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  type ChatCompletionCreateParamsStreaming,\n  type ChatCompletionCreateParamsBase,\n} from \"../resources/chat/completions\";\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\nimport OpenAI from \"../index\";\nimport { ParsedChatCompletion } from \"../resources/beta/chat/completions\";\nimport {\n  AutoParseableResponseFormat,\n  hasAutoParseableInput,\n  isAutoParsableResponseFormat,\n  isAutoParsableTool,\n  maybeParseChatCompletion,\n  shouldParseToolCall,\n} from \"./parser\";\nimport { partialParse } from '../_vendor/partial-json-parser/parser';\n\nexport interface ContentDeltaEvent {\n  delta: string;\n  snapshot: string;\n  parsed: unknown | null;\n}\n\nexport interface ContentDoneEvent<ParsedT = null> {\n  content: string;\n  parsed: ParsedT | null;\n}\n\nexport interface RefusalDeltaEvent {\n  delta: string;\n  snapshot: string;\n}\n\nexport interface RefusalDoneEvent {\n  refusal: string;\n}\n\nexport interface FunctionToolCallArgumentsDeltaEvent {\n  name: string;\n\n  index: number;\n\n  arguments: string;\n\n  parsed_arguments: unknown;\n\n  arguments_delta: string;\n}\n\nexport interface FunctionToolCallArgumentsDoneEvent {\n  name: string;\n\n  index: number;\n\n  arguments: string;\n\n  parsed_arguments: unknown;\n}\n\nexport interface LogProbsContentDeltaEvent {\n  content: Array<ChatCompletionTokenLogprob>;\n  snapshot: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsContentDoneEvent {\n  content: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsRefusalDeltaEvent {\n  refusal: Array<ChatCompletionTokenLogprob>;\n  snapshot: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsRefusalDoneEvent {\n  refusal: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface ChatCompletionStreamEvents<ParsedT = null> extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n\n  'content.delta': (props: ContentDeltaEvent) => void;\n  'content.done': (props: ContentDoneEvent<ParsedT>) => void;\n\n  'refusal.delta': (props: RefusalDeltaEvent) => void;\n  'refusal.done': (props: RefusalDoneEvent) => void;\n\n  'tool_calls.function.arguments.delta': (props: FunctionToolCallArgumentsDeltaEvent) => void;\n  'tool_calls.function.arguments.done': (props: FunctionToolCallArgumentsDoneEvent) => void;\n\n  'logprobs.content.delta': (props: LogProbsContentDeltaEvent) => void;\n  'logprobs.content.done': (props: LogProbsContentDoneEvent) => void;\n\n  'logprobs.refusal.delta': (props: LogProbsRefusalDeltaEvent) => void;\n  'logprobs.refusal.done': (props: LogProbsRefusalDoneEvent) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\ninterface ChoiceEventState {\n  content_done: boolean;\n  refusal_done: boolean;\n  logprobs_content_done: boolean;\n  logprobs_refusal_done: boolean;\n  current_tool_call_index: number | null;\n  done_tool_calls: Set<number>;\n}\n\nexport class ChatCompletionStream<ParsedT = null>\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents<ParsedT>, ParsedT>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #params: ChatCompletionCreateParams | null;\n  #choiceEventStates: ChoiceEventState[];\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  constructor(params: ChatCompletionCreateParams | null) {\n    super();\n    this.#params = params;\n    this.#choiceEventStates = [];\n  }\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream<null> {\n    const runner = new ChatCompletionStream(null);\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion<ParsedT>(\n    client: OpenAI,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream<ParsedT> {\n    const runner = new ChatCompletionStream<ParsedT>(params as ChatCompletionCreateParamsStreaming);\n    runner._run(() =>\n      runner._runChatCompletion(\n        client,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n\n  #getChoiceEventState(choice: ChatCompletionSnapshot.Choice): ChoiceEventState {\n    let state = this.#choiceEventStates[choice.index];\n    if (state) {\n      return state;\n    }\n\n    state = {\n      content_done: false,\n      refusal_done: false,\n      logprobs_content_done: false,\n      logprobs_refusal_done: false,\n      done_tool_calls: new Set(),\n      current_tool_call_index: null,\n    };\n    this.#choiceEventStates[choice.index] = state;\n    return state;\n  }\n\n  #addChunk(this: ChatCompletionStream<ParsedT>, chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n\n    for (const choice of chunk.choices) {\n      const choiceSnapshot = completion.choices[choice.index]!;\n\n      if (\n        choice.delta.content != null &&\n        choiceSnapshot.message?.role === 'assistant' &&\n        choiceSnapshot.message?.content\n      ) {\n        this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n        this._emit('content.delta', {\n          delta: choice.delta.content,\n          snapshot: choiceSnapshot.message.content,\n          parsed: choiceSnapshot.message.parsed,\n        });\n      }\n\n      if (\n        choice.delta.refusal != null &&\n        choiceSnapshot.message?.role === 'assistant' &&\n        choiceSnapshot.message?.refusal\n      ) {\n        this._emit('refusal.delta', {\n          delta: choice.delta.refusal,\n          snapshot: choiceSnapshot.message.refusal,\n        });\n      }\n\n      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.content.delta', {\n          content: choice.logprobs?.content,\n          snapshot: choiceSnapshot.logprobs?.content ?? [],\n        });\n      }\n\n      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.refusal.delta', {\n          refusal: choice.logprobs?.refusal,\n          snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n        });\n      }\n\n      const state = this.#getChoiceEventState(choiceSnapshot);\n\n      if (choiceSnapshot.finish_reason) {\n        this.#emitContentDoneEvents(choiceSnapshot);\n\n        if (state.current_tool_call_index != null) {\n          this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\n        }\n      }\n\n      for (const toolCall of choice.delta.tool_calls ?? []) {\n        if (state.current_tool_call_index !== toolCall.index) {\n          this.#emitContentDoneEvents(choiceSnapshot);\n\n          // new tool call started, the previous one is done\n          if (state.current_tool_call_index != null) {\n            this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\n          }\n        }\n\n        state.current_tool_call_index = toolCall.index;\n      }\n\n      for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n        if (!toolCallSnapshot?.type) {\n          continue;\n        }\n\n        if (toolCallSnapshot?.type === 'function') {\n          this._emit('tool_calls.function.arguments.delta', {\n            name: toolCallSnapshot.function?.name,\n            index: toolCallDelta.index,\n            arguments: toolCallSnapshot.function.arguments,\n            parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n            arguments_delta: toolCallDelta.function?.arguments ?? '',\n          });\n        } else {\n          assertNever(toolCallSnapshot?.type);\n        }\n      }\n    }\n  }\n\n  #emitToolCallDoneEvent(choiceSnapshot: ChatCompletionSnapshot.Choice, toolCallIndex: number) {\n    const state = this.#getChoiceEventState(choiceSnapshot);\n    if (state.done_tool_calls.has(toolCallIndex)) {\n      // we've already fired the done event\n      return;\n    }\n\n    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n    if (!toolCallSnapshot) {\n      throw new Error('no tool call snapshot');\n    }\n    if (!toolCallSnapshot.type) {\n      throw new Error('tool call snapshot missing `type`');\n    }\n\n    if (toolCallSnapshot.type === 'function') {\n      const inputTool = this.#params?.tools?.find(\n        (tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name,\n      );\n\n      this._emit('tool_calls.function.arguments.done', {\n        name: toolCallSnapshot.function.name,\n        index: toolCallIndex,\n        arguments: toolCallSnapshot.function.arguments,\n        parsed_arguments:\n          isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n          : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n          : null,\n      });\n    } else {\n      assertNever(toolCallSnapshot.type);\n    }\n  }\n\n  #emitContentDoneEvents(choiceSnapshot: ChatCompletionSnapshot.Choice) {\n    const state = this.#getChoiceEventState(choiceSnapshot);\n\n    if (choiceSnapshot.message.content && !state.content_done) {\n      state.content_done = true;\n\n      const responseFormat = this.#getAutoParseableResponseFormat();\n\n      this._emit('content.done', {\n        content: choiceSnapshot.message.content,\n        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : (null as any),\n      });\n    }\n\n    if (choiceSnapshot.message.refusal && !state.refusal_done) {\n      state.refusal_done = true;\n\n      this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n    }\n\n    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n      state.logprobs_content_done = true;\n\n      this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n    }\n\n    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n      state.logprobs_refusal_done = true;\n\n      this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n    }\n  }\n\n  #endRequest(): ParsedChatCompletion<ParsedT> {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    this.#choiceEventStates = [];\n    return finalizeChatCompletion(snapshot, this.#params);\n  }\n\n  protected override async _createChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ParsedChatCompletion<ParsedT>> {\n    super._createChatCompletion;\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n\n    const stream = await client.chat.completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #getAutoParseableResponseFormat(): AutoParseableResponseFormat<ParsedT> | null {\n    const responseFormat = this.#params?.response_format;\n    if (isAutoParsableResponseFormat<ParsedT>(responseFormat)) {\n      return responseFormat;\n    }\n\n    return null;\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    const { choices, ...rest } = chunk;\n    if (!snapshot) {\n      snapshot = this.#currentChatCompletionSnapshot = {\n        ...rest,\n        choices: [],\n      };\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n      }\n\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const { content, refusal, ...rest } = logprobs;\n          assertIsEmpty(rest);\n          Object.assign(choice.logprobs, rest);\n\n          if (content) {\n            choice.logprobs.content ??= [];\n            choice.logprobs.content.push(...content);\n          }\n\n          if (refusal) {\n            choice.logprobs.refusal ??= [];\n            choice.logprobs.refusal.push(...refusal);\n          }\n        }\n      }\n\n      if (finish_reason) {\n        choice.finish_reason = finish_reason;\n\n        if (this.#params && hasAutoParseableInput(this.#params)) {\n          if (finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n          }\n\n          if (finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n          }\n        }\n      }\n\n      Object.assign(choice, other);\n\n      if (!delta) continue; // Shouldn't happen; just in case.\n\n      const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n      assertIsEmpty(rest);\n      Object.assign(choice.message, rest);\n\n      if (refusal) {\n        choice.message.refusal = (choice.message.refusal || '') + refusal;\n      }\n\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            choice.message.function_call.arguments ??= '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (content) {\n        choice.message.content = (choice.message.content || '') + content;\n\n        if (!choice.message.refusal && this.#getAutoParseableResponseFormat()) {\n          choice.message.parsed = partialParse(choice.message.content);\n        }\n      }\n\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n\n        for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n          const tool_call = (choice.message.tool_calls[index] ??=\n            {} as ChatCompletionSnapshot.Choice.Message.ToolCall);\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ??= { name: fn.name ?? '', arguments: '' };\n          if (fn?.name) tool_call.function!.name = fn.name;\n          if (fn?.arguments) {\n            tool_call.function!.arguments += fn.arguments;\n\n            if (shouldParseToolCall(this.#params, tool_call)) {\n              tool_call.function!.parsed_arguments = partialParse(tool_call.function!.arguments);\n            }\n          }\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](this: ChatCompletionStream<ParsedT>): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: {\n      resolve: (chunk: ChatCompletionChunk | undefined) => void;\n      reject: (err: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion<ParsedT>(\n  snapshot: ChatCompletionSnapshot,\n  params: ChatCompletionCreateParams | null,\n): ParsedChatCompletion<ParsedT> {\n  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n  const completion: ChatCompletion = {\n    ...rest,\n    id,\n    choices: choices.map(\n      ({ message, finish_reason, index, logprobs, ...choiceRest }): ChatCompletion.Choice => {\n        if (!finish_reason) {\n          throw new OpenAIError(`missing finish_reason for choice ${index}`);\n        }\n\n        const { content = null, function_call, tool_calls, ...messageRest } = message;\n        const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n        if (!role) {\n          throw new OpenAIError(`missing role for choice ${index}`);\n        }\n\n        if (function_call) {\n          const { arguments: args, name } = function_call;\n          if (args == null) {\n            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n          }\n\n          if (!name) {\n            throw new OpenAIError(`missing function_call.name for choice ${index}`);\n          }\n\n          return {\n            ...choiceRest,\n            message: {\n              content,\n              function_call: { arguments: args, name },\n              role,\n              refusal: message.refusal ?? null,\n            },\n            finish_reason,\n            index,\n            logprobs,\n          };\n        }\n\n        if (tool_calls) {\n          return {\n            ...choiceRest,\n            index,\n            finish_reason,\n            logprobs,\n            message: {\n              ...messageRest,\n              role,\n              content,\n              refusal: message.refusal ?? null,\n              tool_calls: tool_calls.map((tool_call, i) => {\n                const { function: fn, type, id, ...toolRest } = tool_call;\n                const { arguments: args, name, ...fnRest } = fn || {};\n                if (id == null) {\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                }\n                if (type == null) {\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                }\n                if (name == null) {\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\n                  );\n                }\n                if (args == null) {\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\n                  );\n                }\n\n                return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n              }),\n            },\n          };\n        }\n        return {\n          ...choiceRest,\n          message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n          finish_reason,\n          index,\n          logprobs,\n        };\n      },\n    ),\n    created,\n    model,\n    object: 'chat.completion',\n    ...(system_fingerprint ? { system_fingerprint } : {}),\n  };\n\n  return maybeParseChatCompletion(completion, params);\n}\n\nfunction str(x: unknown) {\n  return JSON.stringify(x);\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n\n  // Note we do not include an \"object\" type on the snapshot,\n  // because the object is not a valid \"chat.completion\" until finalized.\n  // object: 'chat.completion';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: ChatCompletion.Choice.Logprobs | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      refusal?: string | null;\n\n      parsed?: unknown | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      tool_calls?: Array<Message.ToolCall>;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function' | 'tool';\n    }\n\n    export namespace Message {\n      export interface ToolCall {\n        /**\n         * The ID of the tool call.\n         */\n        id: string;\n\n        function: ToolCall.Function;\n\n        /**\n         * The type of the tool.\n         */\n        type: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments: string;\n\n          parsed_arguments?: unknown;\n\n          /**\n           * The name of the function to call.\n           */\n          name: string;\n        }\n      }\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n\ntype AssertIsEmpty<T extends {}> = keyof T extends never ? T : never;\n\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty<T extends {}>(obj: AssertIsEmpty<T>): asserts obj is AssertIsEmpty<T> {\n  return;\n}\n\nfunction assertNever(_x: never) {}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MalformedJSON = exports.PartialJSON = exports.partialParse = void 0;\nconst STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\nconst Allow = {\n    STR,\n    NUM,\n    ARR,\n    OBJ,\n    NULL,\n    BOOL,\n    NAN,\n    INFINITY,\n    MINUS_INFINITY,\n    INF,\n    SPECIAL,\n    ATOM,\n    COLLECTION,\n    ALL,\n};\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {\n}\nexports.PartialJSON = PartialJSON;\nclass MalformedJSON extends Error {\n}\nexports.MalformedJSON = MalformedJSON;\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString, allowPartial = Allow.ALL) {\n    if (typeof jsonString !== 'string') {\n        throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    }\n    if (!jsonString.trim()) {\n        throw new Error(`${jsonString} is empty`);\n    }\n    return _parseJSON(jsonString.trim(), allowPartial);\n}\nconst _parseJSON = (jsonString, allow) => {\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg) => {\n        throw new PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg) => {\n        throw new MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = () => {\n        skipBlank();\n        if (index >= length)\n            markPartialJSON('Unexpected end of input');\n        if (jsonString[index] === '\"')\n            return parseStr();\n        if (jsonString[index] === '{')\n            return parseObj();\n        if (jsonString[index] === '[')\n            return parseArr();\n        if (jsonString.substring(index, index + 4) === 'null' ||\n            (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === 'true' ||\n            (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === 'false' ||\n            (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === 'Infinity' ||\n            (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === '-Infinity' ||\n            (Allow.MINUS_INFINITY & allow &&\n                1 < length - index &&\n                length - index < 9 &&\n                '-Infinity'.startsWith(jsonString.substring(index)))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === 'NaN' ||\n            (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = () => {\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n            escape = jsonString[index] === '\\\\' ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') {\n            try {\n                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n        else if (Allow.STR & allow) {\n            try {\n                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n            }\n            catch (e) {\n                // SyntaxError: Invalid escape sequence\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n            }\n        }\n        markPartialJSON('Unterminated string literal');\n    };\n    const parseObj = () => {\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while (jsonString[index] !== '}') {\n                skipBlank();\n                if (index >= length && Allow.OBJ & allow)\n                    return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n                }\n                catch (e) {\n                    if (Allow.OBJ & allow)\n                        return obj;\n                    else\n                        throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === ',')\n                    index++; // skip comma\n            }\n        }\n        catch (e) {\n            if (Allow.OBJ & allow)\n                return obj;\n            else\n                markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = () => {\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while (jsonString[index] !== ']') {\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === ',') {\n                    index++; // skip comma\n                }\n            }\n        }\n        catch (e) {\n            if (Allow.ARR & allow) {\n                return arr;\n            }\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = () => {\n        if (index === 0) {\n            if (jsonString === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            }\n            catch (e) {\n                if (Allow.NUM & allow) {\n                    try {\n                        if ('.' === jsonString[jsonString.length - 1])\n                            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n                    }\n                    catch (e) { }\n                }\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === '-')\n            index++;\n        while (jsonString[index] && !',]}'.includes(jsonString[index]))\n            index++;\n        if (index == length && !(Allow.NUM & allow))\n            markPartialJSON('Unterminated number literal');\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        }\n        catch (e) {\n            if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = () => {\n        while (index < length && ' \\n\\r\\t'.includes(jsonString[index])) {\n            index++;\n        }\n    };\n    return parseAny();\n};\n// using this function with malformed JSON is undefined behavior\nconst partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);\nexports.partialParse = partialParse;\n//# sourceMappingURL=parser.js.map","const STR = 0b000000001;\nconst NUM = 0b000000010;\nconst ARR = 0b000000100;\nconst OBJ = 0b000001000;\nconst NULL = 0b000010000;\nconst BOOL = 0b000100000;\nconst NAN = 0b001000000;\nconst INFINITY = 0b010000000;\nconst MINUS_INFINITY = 0b100000000;\n\nconst INF = INFINITY | MINUS_INFINITY;\nconst SPECIAL = NULL | BOOL | INF | NAN;\nconst ATOM = STR | NUM | SPECIAL;\nconst COLLECTION = ARR | OBJ;\nconst ALL = ATOM | COLLECTION;\n\nconst Allow = {\n  STR,\n  NUM,\n  ARR,\n  OBJ,\n  NULL,\n  BOOL,\n  NAN,\n  INFINITY,\n  MINUS_INFINITY,\n  INF,\n  SPECIAL,\n  ATOM,\n  COLLECTION,\n  ALL,\n};\n\n// The JSON string segment was unable to be parsed completely\nclass PartialJSON extends Error {}\n\nclass MalformedJSON extends Error {}\n\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString: string, allowPartial: number = Allow.ALL): any {\n  if (typeof jsonString !== 'string') {\n    throw new TypeError(`expecting str, got ${typeof jsonString}`);\n  }\n  if (!jsonString.trim()) {\n    throw new Error(`${jsonString} is empty`);\n  }\n  return _parseJSON(jsonString.trim(), allowPartial);\n}\n\nconst _parseJSON = (jsonString: string, allow: number) => {\n  const length = jsonString.length;\n  let index = 0;\n\n  const markPartialJSON = (msg: string) => {\n    throw new PartialJSON(`${msg} at position ${index}`);\n  };\n\n  const throwMalformedError = (msg: string) => {\n    throw new MalformedJSON(`${msg} at position ${index}`);\n  };\n\n  const parseAny: () => any = () => {\n    skipBlank();\n    if (index >= length) markPartialJSON('Unexpected end of input');\n    if (jsonString[index] === '\"') return parseStr();\n    if (jsonString[index] === '{') return parseObj();\n    if (jsonString[index] === '[') return parseArr();\n    if (\n      jsonString.substring(index, index + 4) === 'null' ||\n      (Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 4;\n      return null;\n    }\n    if (\n      jsonString.substring(index, index + 4) === 'true' ||\n      (Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 4;\n      return true;\n    }\n    if (\n      jsonString.substring(index, index + 5) === 'false' ||\n      (Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 5;\n      return false;\n    }\n    if (\n      jsonString.substring(index, index + 8) === 'Infinity' ||\n      (Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 8;\n      return Infinity;\n    }\n    if (\n      jsonString.substring(index, index + 9) === '-Infinity' ||\n      (Allow.MINUS_INFINITY & allow &&\n        1 < length - index &&\n        length - index < 9 &&\n        '-Infinity'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 9;\n      return -Infinity;\n    }\n    if (\n      jsonString.substring(index, index + 3) === 'NaN' ||\n      (Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index)))\n    ) {\n      index += 3;\n      return NaN;\n    }\n    return parseNum();\n  };\n\n  const parseStr: () => string = () => {\n    const start = index;\n    let escape = false;\n    index++; // skip initial quote\n    while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === '\\\\'))) {\n      escape = jsonString[index] === '\\\\' ? !escape : false;\n      index++;\n    }\n    if (jsonString.charAt(index) == '\"') {\n      try {\n        return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    } else if (Allow.STR & allow) {\n      try {\n        return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n      } catch (e) {\n        // SyntaxError: Invalid escape sequence\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\\\')) + '\"');\n      }\n    }\n    markPartialJSON('Unterminated string literal');\n  };\n\n  const parseObj = () => {\n    index++; // skip initial brace\n    skipBlank();\n    const obj: Record<string, any> = {};\n    try {\n      while (jsonString[index] !== '}') {\n        skipBlank();\n        if (index >= length && Allow.OBJ & allow) return obj;\n        const key = parseStr();\n        skipBlank();\n        index++; // skip colon\n        try {\n          const value = parseAny();\n          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });\n        } catch (e) {\n          if (Allow.OBJ & allow) return obj;\n          else throw e;\n        }\n        skipBlank();\n        if (jsonString[index] === ',') index++; // skip comma\n      }\n    } catch (e) {\n      if (Allow.OBJ & allow) return obj;\n      else markPartialJSON(\"Expected '}' at end of object\");\n    }\n    index++; // skip final brace\n    return obj;\n  };\n\n  const parseArr = () => {\n    index++; // skip initial bracket\n    const arr = [];\n    try {\n      while (jsonString[index] !== ']') {\n        arr.push(parseAny());\n        skipBlank();\n        if (jsonString[index] === ',') {\n          index++; // skip comma\n        }\n      }\n    } catch (e) {\n      if (Allow.ARR & allow) {\n        return arr;\n      }\n      markPartialJSON(\"Expected ']' at end of array\");\n    }\n    index++; // skip final bracket\n    return arr;\n  };\n\n  const parseNum = () => {\n    if (index === 0) {\n      if (jsonString === '-' && Allow.NUM & allow) markPartialJSON(\"Not sure what '-' is\");\n      try {\n        return JSON.parse(jsonString);\n      } catch (e) {\n        if (Allow.NUM & allow) {\n          try {\n            if ('.' === jsonString[jsonString.length - 1])\n              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));\n            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));\n          } catch (e) {}\n        }\n        throwMalformedError(String(e));\n      }\n    }\n\n    const start = index;\n\n    if (jsonString[index] === '-') index++;\n    while (jsonString[index] && !',]}'.includes(jsonString[index]!)) index++;\n\n    if (index == length && !(Allow.NUM & allow)) markPartialJSON('Unterminated number literal');\n\n    try {\n      return JSON.parse(jsonString.substring(start, index));\n    } catch (e) {\n      if (jsonString.substring(start, index) === '-' && Allow.NUM & allow)\n        markPartialJSON(\"Not sure what '-' is\");\n      try {\n        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));\n      } catch (e) {\n        throwMalformedError(String(e));\n      }\n    }\n  };\n\n  const skipBlank = () => {\n    while (index < length && ' \\n\\r\\t'.includes(jsonString[index]!)) {\n      index++;\n    }\n  };\n\n  return parseAny();\n};\n\n// using this function with malformed JSON is undefined behavior\nconst partialParse = (input: string) => parseJSON(input, Allow.ALL ^ Allow.NUM);\n\nexport { partialParse, PartialJSON, MalformedJSON };\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Threads = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst AssistantStream_1 = require(\"../../../lib/AssistantStream.js\");\nconst MessagesAPI = __importStar(require(\"./messages.js\"));\nconst RunsAPI = __importStar(require(\"./runs/runs.js\"));\nclass Threads extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.runs = new RunsAPI.Runs(this._client);\n        this.messages = new MessagesAPI.Messages(this._client);\n    }\n    create(body = {}, options) {\n        if ((0, core_1.isRequestOptions)(body)) {\n            return this.create({}, body);\n        }\n        return this._client.post('/threads', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a thread.\n     */\n    retrieve(threadId, options) {\n        return this._client.get(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a thread.\n     */\n    update(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a thread.\n     */\n    del(threadId, options) {\n        return this._client.delete(`/threads/${threadId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    createAndRun(body, options) {\n        return this._client.post('/threads/runs', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to create a thread, start a run and then poll for a terminal state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndRunPoll(body, options) {\n        const run = await this.createAndRun(body, options);\n        return await this.runs.poll(run.thread_id, run.id, options);\n    }\n    /**\n     * Create a thread and stream the run back\n     */\n    createAndRunStream(body, options) {\n        return AssistantStream_1.AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n    }\n}\nexports.Threads = Threads;\n(function (Threads) {\n    Threads.Runs = RunsAPI.Runs;\n    Threads.RunsPage = RunsAPI.RunsPage;\n    Threads.Messages = MessagesAPI.Messages;\n    Threads.MessagesPage = MessagesAPI.MessagesPage;\n})(Threads = exports.Threads || (exports.Threads = {}));\n//# sourceMappingURL=threads.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport { AssistantStream, ThreadCreateAndRunParamsBaseStream } from '../../../lib/AssistantStream';\nimport { APIPromise } from '../../../core';\nimport * as Core from '../../../core';\nimport * as ThreadsAPI from './threads';\nimport * as Shared from '../../shared';\nimport * as AssistantsAPI from '../assistants';\nimport * as ChatAPI from '../../chat/chat';\nimport * as MessagesAPI from './messages';\nimport * as VectorStoresAPI from '../vector-stores/vector-stores';\nimport * as RunsAPI from './runs/runs';\nimport { Stream } from '../../../streaming';\n\nexport class Threads extends APIResource {\n  runs: RunsAPI.Runs = new RunsAPI.Runs(this._client);\n  messages: MessagesAPI.Messages = new MessagesAPI.Messages(this._client);\n\n  /**\n   * Create a thread.\n   */\n  create(body?: ThreadCreateParams, options?: Core.RequestOptions): Core.APIPromise<Thread>;\n  create(options?: Core.RequestOptions): Core.APIPromise<Thread>;\n  create(\n    body: ThreadCreateParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Thread> {\n    if (isRequestOptions(body)) {\n      return this.create({}, body);\n    }\n    return this._client.post('/threads', {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieves a thread.\n   */\n  retrieve(threadId: string, options?: Core.RequestOptions): Core.APIPromise<Thread> {\n    return this._client.get(`/threads/${threadId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Modifies a thread.\n   */\n  update(threadId: string, body: ThreadUpdateParams, options?: Core.RequestOptions): Core.APIPromise<Thread> {\n    return this._client.post(`/threads/${threadId}`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Delete a thread.\n   */\n  del(threadId: string, options?: Core.RequestOptions): Core.APIPromise<ThreadDeleted> {\n    return this._client.delete(`/threads/${threadId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Create a thread and run it in one request.\n   */\n  createAndRun(\n    body: ThreadCreateAndRunParamsNonStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<RunsAPI.Run>;\n  createAndRun(\n    body: ThreadCreateAndRunParamsStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  createAndRun(\n    body: ThreadCreateAndRunParamsBase,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent> | RunsAPI.Run>;\n  createAndRun(\n    body: ThreadCreateAndRunParams,\n    options?: Core.RequestOptions,\n  ): APIPromise<RunsAPI.Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>> {\n    return this._client.post('/threads/runs', {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n      stream: body.stream ?? false,\n    }) as APIPromise<RunsAPI.Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  }\n\n  /**\n   * A helper to create a thread, start a run and then poll for a terminal state.\n   * More information on Run lifecycles can be found here:\n   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n   */\n  async createAndRunPoll(\n    body: ThreadCreateAndRunParamsNonStreaming,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<Threads.Run> {\n    const run = await this.createAndRun(body, options);\n    return await this.runs.poll(run.thread_id, run.id, options);\n  }\n\n  /**\n   * Create a thread and stream the run back\n   */\n  createAndRunStream(\n    body: ThreadCreateAndRunParamsBaseStream,\n    options?: Core.RequestOptions,\n  ): AssistantStream {\n    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);\n  }\n}\n\n/**\n * Specifies the format that the model must output. Compatible with\n * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n *\n * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n * Outputs which ensures the model will match your supplied JSON schema. Learn more\n * in the\n * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n *\n * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n * message the model generates is valid JSON.\n *\n * **Important:** when using JSON mode, you **must** also instruct the model to\n * produce JSON yourself via a system or user message. Without this, the model may\n * generate an unending stream of whitespace until the generation reaches the token\n * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n * the message content may be partially cut off if `finish_reason=\"length\"`, which\n * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n * max context length.\n */\nexport type AssistantResponseFormatOption =\n  | 'auto'\n  | Shared.ResponseFormatText\n  | Shared.ResponseFormatJSONObject\n  | Shared.ResponseFormatJSONSchema;\n\n/**\n * Specifies a tool the model should use. Use to force the model to call a specific\n * tool.\n */\nexport interface AssistantToolChoice {\n  /**\n   * The type of the tool. If type is `function`, the function name must be set\n   */\n  type: 'function' | 'code_interpreter' | 'file_search';\n\n  function?: AssistantToolChoiceFunction;\n}\n\nexport interface AssistantToolChoiceFunction {\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\n/**\n * Controls which (if any) tool is called by the model. `none` means the model will\n * not call any tools and instead generates a message. `auto` is the default value\n * and means the model can pick between generating a message or calling one or more\n * tools. `required` means the model must call one or more tools before responding\n * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n * call that tool.\n */\nexport type AssistantToolChoiceOption = 'none' | 'auto' | 'required' | AssistantToolChoice;\n\n/**\n * Represents a thread that contains\n * [messages](https://platform.openai.com/docs/api-reference/messages).\n */\nexport interface Thread {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the thread was created.\n   */\n  created_at: number;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * The object type, which is always `thread`.\n   */\n  object: 'thread';\n\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  tool_resources: Thread.ToolResources | null;\n}\n\nexport namespace Thread {\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this thread. There can be a maximum of 1 vector store attached to\n       * the thread.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n}\n\nexport interface ThreadDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'thread.deleted';\n}\n\nexport interface ThreadCreateParams {\n  /**\n   * A list of [messages](https://platform.openai.com/docs/api-reference/messages) to\n   * start the thread with.\n   */\n  messages?: Array<ThreadCreateParams.Message>;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  tool_resources?: ThreadCreateParams.ToolResources | null;\n}\n\nexport namespace ThreadCreateParams {\n  export interface Message {\n    /**\n     * The text contents of the message.\n     */\n    content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n    /**\n     * The role of the entity that is creating the message. Allowed values include:\n     *\n     * - `user`: Indicates the message is sent by an actual user and should be used in\n     *   most cases to represent user-generated messages.\n     * - `assistant`: Indicates the message is generated by the assistant. Use this\n     *   value to insert messages from the assistant into the conversation.\n     */\n    role: 'user' | 'assistant';\n\n    /**\n     * A list of files attached to the message, and the tools they should be added to.\n     */\n    attachments?: Array<Message.Attachment> | null;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n  }\n\n  export namespace Message {\n    export interface Attachment {\n      /**\n       * The ID of the file to attach to the message.\n       */\n      file_id?: string;\n\n      /**\n       * The tools to add this file to.\n       */\n      tools?: Array<AssistantsAPI.CodeInterpreterTool | Attachment.FileSearch>;\n    }\n\n    export namespace Attachment {\n      export interface FileSearch {\n        /**\n         * The type of tool being defined: `file_search`\n         */\n        type: 'file_search';\n      }\n    }\n  }\n\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this thread. There can be a maximum of 1 vector store attached to\n       * the thread.\n       */\n      vector_store_ids?: Array<string>;\n\n      /**\n       * A helper to create a\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * with file_ids and attach it to this thread. There can be a maximum of 1 vector\n       * store attached to the thread.\n       */\n      vector_stores?: Array<FileSearch.VectorStore>;\n    }\n\n    export namespace FileSearch {\n      export interface VectorStore {\n        /**\n         * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n         * strategy. Only applicable if `file_ids` is non-empty.\n         */\n        chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\n\n        /**\n         * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to\n         * add to the vector store. There can be a maximum of 10000 files in a vector\n         * store.\n         */\n        file_ids?: Array<string>;\n\n        /**\n         * Set of 16 key-value pairs that can be attached to a vector store. This can be\n         * useful for storing additional information about the vector store in a structured\n         * format. Keys can be a maximum of 64 characters long and values can be a maxium\n         * of 512 characters long.\n         */\n        metadata?: unknown;\n      }\n    }\n  }\n}\n\nexport interface ThreadUpdateParams {\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  tool_resources?: ThreadUpdateParams.ToolResources | null;\n}\n\nexport namespace ThreadUpdateParams {\n  /**\n   * A set of resources that are made available to the assistant's tools in this\n   * thread. The resources are specific to the type of tool. For example, the\n   * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n   * tool requires a list of vector store IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this thread. There can be a maximum of 1 vector store attached to\n       * the thread.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n}\n\nexport type ThreadCreateAndRunParams =\n  | ThreadCreateAndRunParamsNonStreaming\n  | ThreadCreateAndRunParamsStreaming;\n\nexport interface ThreadCreateAndRunParamsBase {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Override the default system message of the assistant. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?: (string & {}) | ChatAPI.ChatModel | null;\n\n  /**\n   * Whether to enable\n   * [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)\n   * during tool use.\n   */\n  parallel_tool_calls?: boolean;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: AssistantResponseFormatOption | null;\n\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream?: boolean | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  thread?: ThreadCreateAndRunParams.Thread;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: AssistantToolChoiceOption | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: ThreadCreateAndRunParams.ToolResources | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<\n    AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool | AssistantsAPI.FunctionTool\n  > | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: ThreadCreateAndRunParams.TruncationStrategy | null;\n}\n\nexport namespace ThreadCreateAndRunParams {\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  export interface Thread {\n    /**\n     * A list of [messages](https://platform.openai.com/docs/api-reference/messages) to\n     * start the thread with.\n     */\n    messages?: Array<Thread.Message>;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    tool_resources?: Thread.ToolResources | null;\n  }\n\n  export namespace Thread {\n    export interface Message {\n      /**\n       * The text contents of the message.\n       */\n      content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n      /**\n       * The role of the entity that is creating the message. Allowed values include:\n       *\n       * - `user`: Indicates the message is sent by an actual user and should be used in\n       *   most cases to represent user-generated messages.\n       * - `assistant`: Indicates the message is generated by the assistant. Use this\n       *   value to insert messages from the assistant into the conversation.\n       */\n      role: 'user' | 'assistant';\n\n      /**\n       * A list of files attached to the message, and the tools they should be added to.\n       */\n      attachments?: Array<Message.Attachment> | null;\n\n      /**\n       * Set of 16 key-value pairs that can be attached to an object. This can be useful\n       * for storing additional information about the object in a structured format. Keys\n       * can be a maximum of 64 characters long and values can be a maxium of 512\n       * characters long.\n       */\n      metadata?: unknown | null;\n    }\n\n    export namespace Message {\n      export interface Attachment {\n        /**\n         * The ID of the file to attach to the message.\n         */\n        file_id?: string;\n\n        /**\n         * The tools to add this file to.\n         */\n        tools?: Array<AssistantsAPI.CodeInterpreterTool | Attachment.FileSearch>;\n      }\n\n      export namespace Attachment {\n        export interface FileSearch {\n          /**\n           * The type of tool being defined: `file_search`\n           */\n          type: 'file_search';\n        }\n      }\n    }\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    export interface ToolResources {\n      code_interpreter?: ToolResources.CodeInterpreter;\n\n      file_search?: ToolResources.FileSearch;\n    }\n\n    export namespace ToolResources {\n      export interface CodeInterpreter {\n        /**\n         * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n         * available to the `code_interpreter` tool. There can be a maximum of 20 files\n         * associated with the tool.\n         */\n        file_ids?: Array<string>;\n      }\n\n      export interface FileSearch {\n        /**\n         * The\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * attached to this thread. There can be a maximum of 1 vector store attached to\n         * the thread.\n         */\n        vector_store_ids?: Array<string>;\n\n        /**\n         * A helper to create a\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * with file_ids and attach it to this thread. There can be a maximum of 1 vector\n         * store attached to the thread.\n         */\n        vector_stores?: Array<FileSearch.VectorStore>;\n      }\n\n      export namespace FileSearch {\n        export interface VectorStore {\n          /**\n           * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n           * strategy. Only applicable if `file_ids` is non-empty.\n           */\n          chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\n\n          /**\n           * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to\n           * add to the vector store. There can be a maximum of 10000 files in a vector\n           * store.\n           */\n          file_ids?: Array<string>;\n\n          /**\n           * Set of 16 key-value pairs that can be attached to a vector store. This can be\n           * useful for storing additional information about the vector store in a structured\n           * format. Keys can be a maximum of 64 characters long and values can be a maxium\n           * of 512 characters long.\n           */\n          metadata?: unknown;\n        }\n      }\n    }\n  }\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The ID of the\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n\n  export type ThreadCreateAndRunParamsNonStreaming = ThreadsAPI.ThreadCreateAndRunParamsNonStreaming;\n  export type ThreadCreateAndRunParamsStreaming = ThreadsAPI.ThreadCreateAndRunParamsStreaming;\n}\n\nexport interface ThreadCreateAndRunParamsNonStreaming extends ThreadCreateAndRunParamsBase {\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream?: false | null;\n}\n\nexport interface ThreadCreateAndRunParamsStreaming extends ThreadCreateAndRunParamsBase {\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream: true;\n}\n\nexport interface ThreadCreateAndRunPollParams {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Override the default system message of the assistant. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?:\n    | (string & {})\n    | 'gpt-4o'\n    | 'gpt-4o-2024-05-13'\n    | 'gpt-4-turbo'\n    | 'gpt-4-turbo-2024-04-09'\n    | 'gpt-4-0125-preview'\n    | 'gpt-4-turbo-preview'\n    | 'gpt-4-1106-preview'\n    | 'gpt-4-vision-preview'\n    | 'gpt-4'\n    | 'gpt-4-0314'\n    | 'gpt-4-0613'\n    | 'gpt-4-32k'\n    | 'gpt-4-32k-0314'\n    | 'gpt-4-32k-0613'\n    | 'gpt-3.5-turbo'\n    | 'gpt-3.5-turbo-16k'\n    | 'gpt-3.5-turbo-0613'\n    | 'gpt-3.5-turbo-1106'\n    | 'gpt-3.5-turbo-0125'\n    | 'gpt-3.5-turbo-16k-0613'\n    | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  thread?: ThreadCreateAndRunPollParams.Thread;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: AssistantToolChoiceOption | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: ThreadCreateAndRunPollParams.ToolResources | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<\n    AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool | AssistantsAPI.FunctionTool\n  > | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: ThreadCreateAndRunPollParams.TruncationStrategy | null;\n}\n\nexport namespace ThreadCreateAndRunPollParams {\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  export interface Thread {\n    /**\n     * A list of [messages](https://platform.openai.com/docs/api-reference/messages) to\n     * start the thread with.\n     */\n    messages?: Array<Thread.Message>;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    tool_resources?: Thread.ToolResources | null;\n  }\n\n  export namespace Thread {\n    export interface Message {\n      /**\n       * The text contents of the message.\n       */\n      content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n      /**\n       * The role of the entity that is creating the message. Allowed values include:\n       *\n       * - `user`: Indicates the message is sent by an actual user and should be used in\n       *   most cases to represent user-generated messages.\n       * - `assistant`: Indicates the message is generated by the assistant. Use this\n       *   value to insert messages from the assistant into the conversation.\n       */\n      role: 'user' | 'assistant';\n\n      /**\n       * A list of files attached to the message, and the tools they should be added to.\n       */\n      attachments?: Array<Message.Attachment> | null;\n\n      /**\n       * Set of 16 key-value pairs that can be attached to an object. This can be useful\n       * for storing additional information about the object in a structured format. Keys\n       * can be a maximum of 64 characters long and values can be a maxium of 512\n       * characters long.\n       */\n      metadata?: unknown | null;\n    }\n\n    export namespace Message {\n      export interface Attachment {\n        /**\n         * The ID of the file to attach to the message.\n         */\n        file_id?: string;\n\n        /**\n         * The tools to add this file to.\n         */\n        tools?: Array<AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool>;\n      }\n    }\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    export interface ToolResources {\n      code_interpreter?: ToolResources.CodeInterpreter;\n\n      file_search?: ToolResources.FileSearch;\n    }\n\n    export namespace ToolResources {\n      export interface CodeInterpreter {\n        /**\n         * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n         * available to the `code_interpreter` tool. There can be a maximum of 20 files\n         * associated with the tool.\n         */\n        file_ids?: Array<string>;\n      }\n\n      export interface FileSearch {\n        /**\n         * The\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * attached to this thread. There can be a maximum of 1 vector store attached to\n         * the thread.\n         */\n        vector_store_ids?: Array<string>;\n\n        /**\n         * A helper to create a\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * with file_ids and attach it to this thread. There can be a maximum of 1 vector\n         * store attached to the thread.\n         */\n        vector_stores?: Array<FileSearch.VectorStore>;\n      }\n\n      export namespace FileSearch {\n        export interface VectorStore {\n          /**\n           * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to\n           * add to the vector store. There can be a maximum of 10000 files in a vector\n           * store.\n           */\n          file_ids?: Array<string>;\n\n          /**\n           * Set of 16 key-value pairs that can be attached to a vector store. This can be\n           * useful for storing additional information about the vector store in a structured\n           * format. Keys can be a maximum of 64 characters long and values can be a maxium\n           * of 512 characters long.\n           */\n          metadata?: unknown;\n        }\n      }\n    }\n  }\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The ID of the\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n}\n\nexport interface ThreadCreateAndRunStreamParams {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Override the default system message of the assistant. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?:\n    | (string & {})\n    | 'gpt-4o'\n    | 'gpt-4o-2024-05-13'\n    | 'gpt-4-turbo'\n    | 'gpt-4-turbo-2024-04-09'\n    | 'gpt-4-0125-preview'\n    | 'gpt-4-turbo-preview'\n    | 'gpt-4-1106-preview'\n    | 'gpt-4-vision-preview'\n    | 'gpt-4'\n    | 'gpt-4-0314'\n    | 'gpt-4-0613'\n    | 'gpt-4-32k'\n    | 'gpt-4-32k-0314'\n    | 'gpt-4-32k-0613'\n    | 'gpt-3.5-turbo'\n    | 'gpt-3.5-turbo-16k'\n    | 'gpt-3.5-turbo-0613'\n    | 'gpt-3.5-turbo-1106'\n    | 'gpt-3.5-turbo-0125'\n    | 'gpt-3.5-turbo-16k-0613'\n    | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  thread?: ThreadCreateAndRunStreamParams.Thread;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: AssistantToolChoiceOption | null;\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  tool_resources?: ThreadCreateAndRunStreamParams.ToolResources | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<\n    AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool | AssistantsAPI.FunctionTool\n  > | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: ThreadCreateAndRunStreamParams.TruncationStrategy | null;\n}\n\nexport namespace ThreadCreateAndRunStreamParams {\n  /**\n   * If no thread is provided, an empty thread will be created.\n   */\n  export interface Thread {\n    /**\n     * A list of [messages](https://platform.openai.com/docs/api-reference/messages) to\n     * start the thread with.\n     */\n    messages?: Array<Thread.Message>;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    tool_resources?: Thread.ToolResources | null;\n  }\n\n  export namespace Thread {\n    export interface Message {\n      /**\n       * The text contents of the message.\n       */\n      content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n      /**\n       * The role of the entity that is creating the message. Allowed values include:\n       *\n       * - `user`: Indicates the message is sent by an actual user and should be used in\n       *   most cases to represent user-generated messages.\n       * - `assistant`: Indicates the message is generated by the assistant. Use this\n       *   value to insert messages from the assistant into the conversation.\n       */\n      role: 'user' | 'assistant';\n\n      /**\n       * A list of files attached to the message, and the tools they should be added to.\n       */\n      attachments?: Array<Message.Attachment> | null;\n\n      /**\n       * Set of 16 key-value pairs that can be attached to an object. This can be useful\n       * for storing additional information about the object in a structured format. Keys\n       * can be a maximum of 64 characters long and values can be a maxium of 512\n       * characters long.\n       */\n      metadata?: unknown | null;\n    }\n\n    export namespace Message {\n      export interface Attachment {\n        /**\n         * The ID of the file to attach to the message.\n         */\n        file_id?: string;\n\n        /**\n         * The tools to add this file to.\n         */\n        tools?: Array<AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool>;\n      }\n    }\n\n    /**\n     * A set of resources that are made available to the assistant's tools in this\n     * thread. The resources are specific to the type of tool. For example, the\n     * `code_interpreter` tool requires a list of file IDs, while the `file_search`\n     * tool requires a list of vector store IDs.\n     */\n    export interface ToolResources {\n      code_interpreter?: ToolResources.CodeInterpreter;\n\n      file_search?: ToolResources.FileSearch;\n    }\n\n    export namespace ToolResources {\n      export interface CodeInterpreter {\n        /**\n         * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n         * available to the `code_interpreter` tool. There can be a maximum of 20 files\n         * associated with the tool.\n         */\n        file_ids?: Array<string>;\n      }\n\n      export interface FileSearch {\n        /**\n         * The\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * attached to this thread. There can be a maximum of 1 vector store attached to\n         * the thread.\n         */\n        vector_store_ids?: Array<string>;\n\n        /**\n         * A helper to create a\n         * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n         * with file_ids and attach it to this thread. There can be a maximum of 1 vector\n         * store attached to the thread.\n         */\n        vector_stores?: Array<FileSearch.VectorStore>;\n      }\n\n      export namespace FileSearch {\n        export interface VectorStore {\n          /**\n           * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to\n           * add to the vector store. There can be a maximum of 10000 files in a vector\n           * store.\n           */\n          file_ids?: Array<string>;\n\n          /**\n           * Set of 16 key-value pairs that can be attached to a vector store. This can be\n           * useful for storing additional information about the vector store in a structured\n           * format. Keys can be a maximum of 64 characters long and values can be a maxium\n           * of 512 characters long.\n           */\n          metadata?: unknown;\n        }\n      }\n    }\n  }\n\n  /**\n   * A set of resources that are used by the assistant's tools. The resources are\n   * specific to the type of tool. For example, the `code_interpreter` tool requires\n   * a list of file IDs, while the `file_search` tool requires a list of vector store\n   * IDs.\n   */\n  export interface ToolResources {\n    code_interpreter?: ToolResources.CodeInterpreter;\n\n    file_search?: ToolResources.FileSearch;\n  }\n\n  export namespace ToolResources {\n    export interface CodeInterpreter {\n      /**\n       * A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made\n       * available to the `code_interpreter` tool. There can be a maximum of 20 files\n       * associated with the tool.\n       */\n      file_ids?: Array<string>;\n    }\n\n    export interface FileSearch {\n      /**\n       * The ID of the\n       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n       * attached to this assistant. There can be a maximum of 1 vector store attached to\n       * the assistant.\n       */\n      vector_store_ids?: Array<string>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n}\n\nexport namespace Threads {\n  export import AssistantResponseFormatOption = ThreadsAPI.AssistantResponseFormatOption;\n  export import AssistantToolChoice = ThreadsAPI.AssistantToolChoice;\n  export import AssistantToolChoiceFunction = ThreadsAPI.AssistantToolChoiceFunction;\n  export import AssistantToolChoiceOption = ThreadsAPI.AssistantToolChoiceOption;\n  export import Thread = ThreadsAPI.Thread;\n  export import ThreadDeleted = ThreadsAPI.ThreadDeleted;\n  export import ThreadCreateParams = ThreadsAPI.ThreadCreateParams;\n  export import ThreadUpdateParams = ThreadsAPI.ThreadUpdateParams;\n  export import ThreadCreateAndRunParams = ThreadsAPI.ThreadCreateAndRunParams;\n  export import ThreadCreateAndRunParamsNonStreaming = ThreadsAPI.ThreadCreateAndRunParamsNonStreaming;\n  export import ThreadCreateAndRunParamsStreaming = ThreadsAPI.ThreadCreateAndRunParamsStreaming;\n  export import ThreadCreateAndRunPollParams = ThreadsAPI.ThreadCreateAndRunPollParams;\n  export import ThreadCreateAndRunStreamParams = ThreadsAPI.ThreadCreateAndRunStreamParams;\n  export import Runs = RunsAPI.Runs;\n  export import RequiredActionFunctionToolCall = RunsAPI.RequiredActionFunctionToolCall;\n  export import Run = RunsAPI.Run;\n  export import RunStatus = RunsAPI.RunStatus;\n  export import RunsPage = RunsAPI.RunsPage;\n  export import RunCreateParams = RunsAPI.RunCreateParams;\n  export import RunCreateParamsNonStreaming = RunsAPI.RunCreateParamsNonStreaming;\n  export import RunCreateParamsStreaming = RunsAPI.RunCreateParamsStreaming;\n  export import RunUpdateParams = RunsAPI.RunUpdateParams;\n  export import RunListParams = RunsAPI.RunListParams;\n  export import RunCreateAndPollParams = RunsAPI.RunCreateAndPollParams;\n  export import RunCreateAndStreamParams = RunsAPI.RunCreateAndStreamParams;\n  export import RunStreamParams = RunsAPI.RunStreamParams;\n  export import RunSubmitToolOutputsParams = RunsAPI.RunSubmitToolOutputsParams;\n  export import RunSubmitToolOutputsParamsNonStreaming = RunsAPI.RunSubmitToolOutputsParamsNonStreaming;\n  export import RunSubmitToolOutputsParamsStreaming = RunsAPI.RunSubmitToolOutputsParamsStreaming;\n  export import RunSubmitToolOutputsAndPollParams = RunsAPI.RunSubmitToolOutputsAndPollParams;\n  export import RunSubmitToolOutputsStreamParams = RunsAPI.RunSubmitToolOutputsStreamParams;\n  export import Messages = MessagesAPI.Messages;\n  export import Annotation = MessagesAPI.Annotation;\n  export import AnnotationDelta = MessagesAPI.AnnotationDelta;\n  export import FileCitationAnnotation = MessagesAPI.FileCitationAnnotation;\n  export import FileCitationDeltaAnnotation = MessagesAPI.FileCitationDeltaAnnotation;\n  export import FilePathAnnotation = MessagesAPI.FilePathAnnotation;\n  export import FilePathDeltaAnnotation = MessagesAPI.FilePathDeltaAnnotation;\n  export import ImageFile = MessagesAPI.ImageFile;\n  export import ImageFileContentBlock = MessagesAPI.ImageFileContentBlock;\n  export import ImageFileDelta = MessagesAPI.ImageFileDelta;\n  export import ImageFileDeltaBlock = MessagesAPI.ImageFileDeltaBlock;\n  export import ImageURL = MessagesAPI.ImageURL;\n  export import ImageURLContentBlock = MessagesAPI.ImageURLContentBlock;\n  export import ImageURLDelta = MessagesAPI.ImageURLDelta;\n  export import ImageURLDeltaBlock = MessagesAPI.ImageURLDeltaBlock;\n  export import Message = MessagesAPI.Message;\n  export import MessageContent = MessagesAPI.MessageContent;\n  export import MessageContentDelta = MessagesAPI.MessageContentDelta;\n  export import MessageContentPartParam = MessagesAPI.MessageContentPartParam;\n  export import MessageDeleted = MessagesAPI.MessageDeleted;\n  export import MessageDelta = MessagesAPI.MessageDelta;\n  export import MessageDeltaEvent = MessagesAPI.MessageDeltaEvent;\n  export import RefusalContentBlock = MessagesAPI.RefusalContentBlock;\n  export import RefusalDeltaBlock = MessagesAPI.RefusalDeltaBlock;\n  export import Text = MessagesAPI.Text;\n  export import TextContentBlock = MessagesAPI.TextContentBlock;\n  export import TextContentBlockParam = MessagesAPI.TextContentBlockParam;\n  export import TextDelta = MessagesAPI.TextDelta;\n  export import TextDeltaBlock = MessagesAPI.TextDeltaBlock;\n  export import MessagesPage = MessagesAPI.MessagesPage;\n  export import MessageCreateParams = MessagesAPI.MessageCreateParams;\n  export import MessageUpdateParams = MessagesAPI.MessageUpdateParams;\n  export import MessageListParams = MessagesAPI.MessageListParams;\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssistantStream = void 0;\nconst Core = __importStar(require(\"openai/core\"));\nconst streaming_1 = require(\"openai/streaming\");\nconst error_1 = require(\"openai/error\");\nconst EventStream_1 = require(\"./EventStream.js\");\nclass AssistantStream extends EventStream_1.EventStream {\n    constructor() {\n        super(...arguments);\n        _AssistantStream_instances.add(this);\n        //Track all events in a single list for reference\n        _AssistantStream_events.set(this, []);\n        //Used to accumulate deltas\n        //We are accumulating many types so the value here is not strict\n        _AssistantStream_runStepSnapshots.set(this, {});\n        _AssistantStream_messageSnapshots.set(this, {});\n        _AssistantStream_messageSnapshot.set(this, void 0);\n        _AssistantStream_finalRun.set(this, void 0);\n        _AssistantStream_currentContentIndex.set(this, void 0);\n        _AssistantStream_currentContent.set(this, void 0);\n        _AssistantStream_currentToolCallIndex.set(this, void 0);\n        _AssistantStream_currentToolCall.set(this, void 0);\n        //For current snapshot methods\n        _AssistantStream_currentEvent.set(this, void 0);\n        _AssistantStream_currentRunSnapshot.set(this, void 0);\n        _AssistantStream_currentRunStepSnapshot.set(this, void 0);\n    }\n    [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        //Catch all for passing along all events\n        this.on('event', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    static fromReadableStream(stream) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        this._connected();\n        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    toReadableStream() {\n        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n    static createToolAssistantStream(threadId, runId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    async _createToolAssistantStream(run, threadId, runId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.submitToolOutputs(threadId, runId, body, {\n            ...options,\n            signal: this.controller.signal,\n        });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static createThreadAssistantStream(params, thread, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._threadAssistantStream(params, thread, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    static createAssistantStream(threadId, runs, params, options) {\n        const runner = new AssistantStream();\n        runner._run(() => runner._runAssistantStream(threadId, runs, params, {\n            ...options,\n            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n        }));\n        return runner;\n    }\n    currentEvent() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, \"f\");\n    }\n    currentRun() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, \"f\");\n    }\n    currentMessageSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\");\n    }\n    currentRunStepSnapshot() {\n        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, \"f\");\n    }\n    async finalRunSteps() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\"));\n    }\n    async finalMessages() {\n        await this.done();\n        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\"));\n    }\n    async finalRun() {\n        await this.done();\n        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n            throw Error('Final run was not received.');\n        return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n    }\n    async _createThreadAssistantStream(thread, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    async _createAssistantStream(run, threadId, params, options) {\n        const signal = options?.signal;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            signal.addEventListener('abort', () => this.controller.abort());\n        }\n        const body = { ...params, stream: true };\n        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n        this._connected();\n        for await (const event of stream) {\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_addEvent).call(this, event);\n        }\n        if (stream.controller.signal?.aborted) {\n            throw new error_1.APIUserAbortError();\n        }\n        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_endRequest).call(this));\n    }\n    static accumulateDelta(acc, delta) {\n        for (const [key, deltaValue] of Object.entries(delta)) {\n            if (!acc.hasOwnProperty(key)) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            let accValue = acc[key];\n            if (accValue === null || accValue === undefined) {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // We don't accumulate these special properties\n            if (key === 'index' || key === 'type') {\n                acc[key] = deltaValue;\n                continue;\n            }\n            // Type-specific accumulation logic\n            if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n                accValue += deltaValue;\n            }\n            else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n                accValue += deltaValue;\n            }\n            else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n                accValue = this.accumulateDelta(accValue, deltaValue);\n            }\n            else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n                if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n                    accValue.push(...deltaValue); // Use spread syntax for efficient addition\n                    continue;\n                }\n                for (const deltaEntry of deltaValue) {\n                    if (!Core.isObj(deltaEntry)) {\n                        throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n                    }\n                    const index = deltaEntry['index'];\n                    if (index == null) {\n                        console.error(deltaEntry);\n                        throw new Error('Expected array delta entry to have an `index` property');\n                    }\n                    if (typeof index !== 'number') {\n                        throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n                    }\n                    const accEntry = accValue[index];\n                    if (accEntry == null) {\n                        accValue.push(deltaEntry);\n                    }\n                    else {\n                        accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n                    }\n                }\n                continue;\n            }\n            else {\n                throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n            }\n            acc[key] = accValue;\n        }\n        return acc;\n    }\n    _addRun(run) {\n        return run;\n    }\n    async _threadAssistantStream(params, thread, options) {\n        return await this._createThreadAssistantStream(thread, params, options);\n    }\n    async _runAssistantStream(threadId, runs, params, options) {\n        return await this._createAssistantStream(runs, threadId, params, options);\n    }\n    async _runToolAssistantStream(threadId, runId, runs, params, options) {\n        return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n    }\n}\nexports.AssistantStream = AssistantStream;\n_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {\n    if (this.ended)\n        return;\n    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleEvent).call(this, event);\n    switch (event.event) {\n        case 'thread.created':\n            //No action on this event.\n            break;\n        case 'thread.run.created':\n        case 'thread.run.queued':\n        case 'thread.run.in_progress':\n        case 'thread.run.requires_action':\n        case 'thread.run.completed':\n        case 'thread.run.failed':\n        case 'thread.run.cancelling':\n        case 'thread.run.cancelled':\n        case 'thread.run.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRun).call(this, event);\n            break;\n        case 'thread.run.step.created':\n        case 'thread.run.step.in_progress':\n        case 'thread.run.step.delta':\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleRunStep).call(this, event);\n            break;\n        case 'thread.message.created':\n        case 'thread.message.in_progress':\n        case 'thread.message.delta':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_handleMessage).call(this, event);\n            break;\n        case 'error':\n            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n            throw new Error('Encountered an error event in event processing - errors should be processed earlier');\n    }\n}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {\n    if (this.ended) {\n        throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\"))\n        throw Error('Final run has not been received');\n    return __classPrivateFieldGet(this, _AssistantStream_finalRun, \"f\");\n}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {\n    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, \"f\");\n    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, \"f\")[accumulatedMessage.id] = accumulatedMessage;\n    for (const content of newContent) {\n        const snapshotContent = accumulatedMessage.content[content.index];\n        if (snapshotContent?.type == 'text') {\n            this._emit('textCreated', snapshotContent.text);\n        }\n    }\n    switch (event.event) {\n        case 'thread.message.created':\n            this._emit('messageCreated', event.data);\n            break;\n        case 'thread.message.in_progress':\n            break;\n        case 'thread.message.delta':\n            this._emit('messageDelta', event.data.delta, accumulatedMessage);\n            if (event.data.delta.content) {\n                for (const content of event.data.delta.content) {\n                    //If it is text delta, emit a text delta event\n                    if (content.type == 'text' && content.text) {\n                        let textDelta = content.text;\n                        let snapshot = accumulatedMessage.content[content.index];\n                        if (snapshot && snapshot.type == 'text') {\n                            this._emit('textDelta', textDelta, snapshot.text);\n                        }\n                        else {\n                            throw Error('The snapshot associated with this text delta is not text or missing');\n                        }\n                    }\n                    if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")) {\n                        //See if we have in progress content\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\")) {\n                            switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").type) {\n                                case 'text':\n                                    this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                                case 'image_file':\n                                    this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, \"f\").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                                    break;\n                            }\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, \"f\");\n                    }\n                    __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], \"f\");\n                }\n            }\n            break;\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //We emit the latest content we were working on on completion (including incomplete)\n            if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\") !== undefined) {\n                const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, \"f\")];\n                if (currentContent) {\n                    switch (currentContent.type) {\n                        case 'image_file':\n                            this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                        case 'text':\n                            this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\"));\n                            break;\n                    }\n                }\n            }\n            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, \"f\")) {\n                this._emit('messageDone', event.data);\n            }\n            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, \"f\");\n    }\n}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {\n    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateRunStep).call(this, event);\n    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, \"f\");\n    switch (event.event) {\n        case 'thread.run.step.created':\n            this._emit('runStepCreated', event.data);\n            break;\n        case 'thread.run.step.delta':\n            const delta = event.data.delta;\n            if (delta.step_details &&\n                delta.step_details.type == 'tool_calls' &&\n                delta.step_details.tool_calls &&\n                accumulatedRunStep.step_details.type == 'tool_calls') {\n                for (const toolCall of delta.step_details.tool_calls) {\n                    if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, \"f\")) {\n                        this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);\n                    }\n                    else {\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                            this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                        }\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, \"f\");\n                        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], \"f\");\n                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"))\n                            this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    }\n                }\n            }\n            this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n            break;\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, \"f\");\n            const details = event.data.step_details;\n            if (details.type == 'tool_calls') {\n                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                    this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                    __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n                }\n            }\n            this._emit('runStepDone', event.data, accumulatedRunStep);\n            break;\n        case 'thread.run.step.in_progress':\n            break;\n    }\n}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {\n    __classPrivateFieldGet(this, _AssistantStream_events, \"f\").push(event);\n    this._emit('event', event);\n}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {\n    switch (event.event) {\n        case 'thread.run.step.created':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            return event.data;\n        case 'thread.run.step.delta':\n            let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n            if (!snapshot) {\n                throw Error('Received a RunStepDelta before creation of a snapshot');\n            }\n            let data = event.data;\n            if (data.delta) {\n                const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);\n                __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = accumulated;\n            }\n            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n        case 'thread.run.step.completed':\n        case 'thread.run.step.failed':\n        case 'thread.run.step.cancelled':\n        case 'thread.run.step.expired':\n        case 'thread.run.step.in_progress':\n            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id] = event.data;\n            break;\n    }\n    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id])\n        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, \"f\")[event.data.id];\n    throw new Error('No snapshot available');\n}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {\n    let newContent = [];\n    switch (event.event) {\n        case 'thread.message.created':\n            //On creation the snapshot is just the initial message\n            return [event.data, newContent];\n        case 'thread.message.delta':\n            if (!snapshot) {\n                throw Error('Received a delta with no existing snapshot (there should be one from message creation)');\n            }\n            let data = event.data;\n            //If this delta does not have content, nothing to process\n            if (data.delta.content) {\n                for (const contentElement of data.delta.content) {\n                    if (contentElement.index in snapshot.content) {\n                        let currentContent = snapshot.content[contentElement.index];\n                        snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, \"m\", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);\n                    }\n                    else {\n                        snapshot.content[contentElement.index] = contentElement;\n                        // This is a new element\n                        newContent.push(contentElement);\n                    }\n                }\n            }\n            return [snapshot, newContent];\n        case 'thread.message.in_progress':\n        case 'thread.message.completed':\n        case 'thread.message.incomplete':\n            //No changes on other thread events\n            if (snapshot) {\n                return [snapshot, newContent];\n            }\n            else {\n                throw Error('Received thread message event with no existing snapshot');\n            }\n    }\n    throw Error('Tried to accumulate a non-message event');\n}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {\n    return AssistantStream.accumulateDelta(currentContent, contentElement);\n}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {\n    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, \"f\");\n    switch (event.event) {\n        case 'thread.run.created':\n            break;\n        case 'thread.run.queued':\n            break;\n        case 'thread.run.in_progress':\n            break;\n        case 'thread.run.requires_action':\n        case 'thread.run.cancelled':\n        case 'thread.run.failed':\n        case 'thread.run.completed':\n        case 'thread.run.expired':\n            __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, \"f\");\n            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\")) {\n                this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, \"f\"));\n                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, \"f\");\n            }\n            break;\n        case 'thread.run.cancelling':\n            break;\n    }\n};\n//# sourceMappingURL=AssistantStream.js.map","import {\n  TextContentBlock,\n  ImageFileContentBlock,\n  Message,\n  MessageContentDelta,\n  Text,\n  ImageFile,\n  TextDelta,\n  Messages,\n  MessageContent,\n} from \"../resources/beta/threads/messages\";\nimport * as Core from \"../core\";\nimport { RequestOptions } from \"../core\";\nimport {\n  Run,\n  RunCreateParamsBase,\n  RunCreateParamsStreaming,\n  Runs,\n  RunSubmitToolOutputsParamsBase,\n  RunSubmitToolOutputsParamsStreaming,\n} from \"../resources/beta/threads/runs/runs\";\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\nimport { APIUserAbortError, OpenAIError } from \"../error\";\nimport {\n  AssistantStreamEvent,\n  MessageStreamEvent,\n  RunStepStreamEvent,\n  RunStreamEvent,\n} from \"../resources/beta/assistants\";\nimport { RunStep, RunStepDelta, ToolCall, ToolCallDelta } from \"../resources/beta/threads/runs/steps\";\nimport { ThreadCreateAndRunParamsBase, Threads } from \"../resources/beta/threads/threads\";\nimport { BaseEvents, EventStream } from './EventStream';\nimport MessageDelta = Messages.MessageDelta;\n\nexport interface AssistantStreamEvents extends BaseEvents {\n  run: (run: Run) => void;\n\n  //New event structure\n  messageCreated: (message: Message) => void;\n  messageDelta: (message: MessageDelta, snapshot: Message) => void;\n  messageDone: (message: Message) => void;\n\n  runStepCreated: (runStep: RunStep) => void;\n  runStepDelta: (delta: RunStepDelta, snapshot: Runs.RunStep) => void;\n  runStepDone: (runStep: Runs.RunStep, snapshot: Runs.RunStep) => void;\n\n  toolCallCreated: (toolCall: ToolCall) => void;\n  toolCallDelta: (delta: ToolCallDelta, snapshot: ToolCall) => void;\n  toolCallDone: (toolCall: ToolCall) => void;\n\n  textCreated: (content: Text) => void;\n  textDelta: (delta: TextDelta, snapshot: Text) => void;\n  textDone: (content: Text, snapshot: Message) => void;\n\n  //No created or delta as this is not streamed\n  imageFileDone: (content: ImageFile, snapshot: Message) => void;\n\n  event: (event: AssistantStreamEvent) => void;\n}\n\nexport type ThreadCreateAndRunParamsBaseStream = Omit<ThreadCreateAndRunParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport type RunCreateParamsBaseStream = Omit<RunCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport type RunSubmitToolOutputsParamsStream = Omit<RunSubmitToolOutputsParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class AssistantStream\n  extends EventStream<AssistantStreamEvents>\n  implements AsyncIterable<AssistantStreamEvent>\n{\n  //Track all events in a single list for reference\n  #events: AssistantStreamEvent[] = [];\n\n  //Used to accumulate deltas\n  //We are accumulating many types so the value here is not strict\n  #runStepSnapshots: { [id: string]: Runs.RunStep } = {};\n  #messageSnapshots: { [id: string]: Message } = {};\n  #messageSnapshot: Message | undefined;\n  #finalRun: Run | undefined;\n  #currentContentIndex: number | undefined;\n  #currentContent: MessageContent | undefined;\n  #currentToolCallIndex: number | undefined;\n  #currentToolCall: ToolCall | undefined;\n\n  //For current snapshot methods\n  #currentEvent: AssistantStreamEvent | undefined;\n  #currentRunSnapshot: Run | undefined;\n  #currentRunStepSnapshot: Runs.RunStep | undefined;\n\n  [Symbol.asyncIterator](): AsyncIterator<AssistantStreamEvent> {\n    const pushQueue: AssistantStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: AssistantStreamEvent | undefined) => void;\n      reject: (err: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    //Catch all for passing along all events\n    this.on('event', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<AssistantStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<AssistantStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  static fromReadableStream(stream: ReadableStream): AssistantStream {\n    const runner = new AssistantStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this._connected();\n    const stream = Stream.fromReadableStream<AssistantStreamEvent>(readableStream, this.controller);\n    for await (const event of stream) {\n      this.#addEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addRun(this.#endRequest());\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n\n  static createToolAssistantStream(\n    threadId: string,\n    runId: string,\n    runs: Runs,\n    params: RunSubmitToolOutputsParamsStream,\n    options: RequestOptions | undefined,\n  ) {\n    const runner = new AssistantStream();\n    runner._run(() =>\n      runner._runToolAssistantStream(threadId, runId, runs, params, {\n        ...options,\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n      }),\n    );\n    return runner;\n  }\n\n  protected async _createToolAssistantStream(\n    run: Runs,\n    threadId: string,\n    runId: string,\n    params: RunSubmitToolOutputsParamsStream,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    const body: RunSubmitToolOutputsParamsStreaming = { ...params, stream: true };\n    const stream = await run.submitToolOutputs(threadId, runId, body, {\n      ...options,\n      signal: this.controller.signal,\n    });\n\n    this._connected();\n\n    for await (const event of stream) {\n      this.#addEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    return this._addRun(this.#endRequest());\n  }\n\n  static createThreadAssistantStream(\n    params: ThreadCreateAndRunParamsBaseStream,\n    thread: Threads,\n    options?: RequestOptions,\n  ) {\n    const runner = new AssistantStream();\n    runner._run(() =>\n      runner._threadAssistantStream(params, thread, {\n        ...options,\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n      }),\n    );\n    return runner;\n  }\n\n  static createAssistantStream(\n    threadId: string,\n    runs: Runs,\n    params: RunCreateParamsBaseStream,\n    options?: RequestOptions,\n  ) {\n    const runner = new AssistantStream();\n    runner._run(() =>\n      runner._runAssistantStream(threadId, runs, params, {\n        ...options,\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n      }),\n    );\n    return runner;\n  }\n\n  currentEvent(): AssistantStreamEvent | undefined {\n    return this.#currentEvent;\n  }\n\n  currentRun(): Run | undefined {\n    return this.#currentRunSnapshot;\n  }\n\n  currentMessageSnapshot(): Message | undefined {\n    return this.#messageSnapshot;\n  }\n\n  currentRunStepSnapshot(): Runs.RunStep | undefined {\n    return this.#currentRunStepSnapshot;\n  }\n\n  async finalRunSteps(): Promise<Runs.RunStep[]> {\n    await this.done();\n\n    return Object.values(this.#runStepSnapshots);\n  }\n\n  async finalMessages(): Promise<Message[]> {\n    await this.done();\n\n    return Object.values(this.#messageSnapshots);\n  }\n\n  async finalRun(): Promise<Run> {\n    await this.done();\n    if (!this.#finalRun) throw Error('Final run was not received.');\n\n    return this.#finalRun;\n  }\n\n  protected async _createThreadAssistantStream(\n    thread: Threads,\n    params: ThreadCreateAndRunParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    const body: RunCreateParamsStreaming = { ...params, stream: true };\n    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });\n\n    this._connected();\n\n    for await (const event of stream) {\n      this.#addEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    return this._addRun(this.#endRequest());\n  }\n\n  protected async _createAssistantStream(\n    run: Runs,\n    threadId: string,\n    params: RunCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n\n    const body: RunCreateParamsStreaming = { ...params, stream: true };\n    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });\n\n    this._connected();\n\n    for await (const event of stream) {\n      this.#addEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    return this._addRun(this.#endRequest());\n  }\n\n  #addEvent(event: AssistantStreamEvent) {\n    if (this.ended) return;\n\n    this.#currentEvent = event;\n\n    this.#handleEvent(event);\n\n    switch (event.event) {\n      case 'thread.created':\n        //No action on this event.\n        break;\n\n      case 'thread.run.created':\n      case 'thread.run.queued':\n      case 'thread.run.in_progress':\n      case 'thread.run.requires_action':\n      case 'thread.run.completed':\n      case 'thread.run.failed':\n      case 'thread.run.cancelling':\n      case 'thread.run.cancelled':\n      case 'thread.run.expired':\n        this.#handleRun(event);\n        break;\n\n      case 'thread.run.step.created':\n      case 'thread.run.step.in_progress':\n      case 'thread.run.step.delta':\n      case 'thread.run.step.completed':\n      case 'thread.run.step.failed':\n      case 'thread.run.step.cancelled':\n      case 'thread.run.step.expired':\n        this.#handleRunStep(event);\n        break;\n\n      case 'thread.message.created':\n      case 'thread.message.in_progress':\n      case 'thread.message.delta':\n      case 'thread.message.completed':\n      case 'thread.message.incomplete':\n        this.#handleMessage(event);\n        break;\n\n      case 'error':\n        //This is included for completeness, but errors are processed in the SSE event processing so this should not occur\n        throw new Error(\n          'Encountered an error event in event processing - errors should be processed earlier',\n        );\n    }\n  }\n\n  #endRequest(): Run {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n\n    if (!this.#finalRun) throw Error('Final run has not been received');\n\n    return this.#finalRun;\n  }\n\n  #handleMessage(this: AssistantStream, event: MessageStreamEvent) {\n    const [accumulatedMessage, newContent] = this.#accumulateMessage(event, this.#messageSnapshot);\n    this.#messageSnapshot = accumulatedMessage;\n    this.#messageSnapshots[accumulatedMessage.id] = accumulatedMessage;\n\n    for (const content of newContent) {\n      const snapshotContent = accumulatedMessage.content[content.index];\n      if (snapshotContent?.type == 'text') {\n        this._emit('textCreated', snapshotContent.text);\n      }\n    }\n\n    switch (event.event) {\n      case 'thread.message.created':\n        this._emit('messageCreated', event.data);\n        break;\n\n      case 'thread.message.in_progress':\n        break;\n\n      case 'thread.message.delta':\n        this._emit('messageDelta', event.data.delta, accumulatedMessage);\n\n        if (event.data.delta.content) {\n          for (const content of event.data.delta.content) {\n            //If it is text delta, emit a text delta event\n            if (content.type == 'text' && content.text) {\n              let textDelta = content.text;\n              let snapshot = accumulatedMessage.content[content.index];\n              if (snapshot && snapshot.type == 'text') {\n                this._emit('textDelta', textDelta, snapshot.text);\n              } else {\n                throw Error('The snapshot associated with this text delta is not text or missing');\n              }\n            }\n\n            if (content.index != this.#currentContentIndex) {\n              //See if we have in progress content\n              if (this.#currentContent) {\n                switch (this.#currentContent.type) {\n                  case 'text':\n                    this._emit('textDone', this.#currentContent.text, this.#messageSnapshot);\n                    break;\n                  case 'image_file':\n                    this._emit('imageFileDone', this.#currentContent.image_file, this.#messageSnapshot);\n                    break;\n                }\n              }\n\n              this.#currentContentIndex = content.index;\n            }\n\n            this.#currentContent = accumulatedMessage.content[content.index];\n          }\n        }\n\n        break;\n\n      case 'thread.message.completed':\n      case 'thread.message.incomplete':\n        //We emit the latest content we were working on on completion (including incomplete)\n        if (this.#currentContentIndex !== undefined) {\n          const currentContent = event.data.content[this.#currentContentIndex];\n          if (currentContent) {\n            switch (currentContent.type) {\n              case 'image_file':\n                this._emit('imageFileDone', currentContent.image_file, this.#messageSnapshot);\n                break;\n              case 'text':\n                this._emit('textDone', currentContent.text, this.#messageSnapshot);\n                break;\n            }\n          }\n        }\n\n        if (this.#messageSnapshot) {\n          this._emit('messageDone', event.data);\n        }\n\n        this.#messageSnapshot = undefined;\n    }\n  }\n\n  #handleRunStep(this: AssistantStream, event: RunStepStreamEvent) {\n    const accumulatedRunStep = this.#accumulateRunStep(event);\n    this.#currentRunStepSnapshot = accumulatedRunStep;\n\n    switch (event.event) {\n      case 'thread.run.step.created':\n        this._emit('runStepCreated', event.data);\n        break;\n      case 'thread.run.step.delta':\n        const delta = event.data.delta;\n        if (\n          delta.step_details &&\n          delta.step_details.type == 'tool_calls' &&\n          delta.step_details.tool_calls &&\n          accumulatedRunStep.step_details.type == 'tool_calls'\n        ) {\n          for (const toolCall of delta.step_details.tool_calls) {\n            if (toolCall.index == this.#currentToolCallIndex) {\n              this._emit(\n                'toolCallDelta',\n                toolCall,\n                accumulatedRunStep.step_details.tool_calls[toolCall.index] as ToolCall,\n              );\n            } else {\n              if (this.#currentToolCall) {\n                this._emit('toolCallDone', this.#currentToolCall);\n              }\n\n              this.#currentToolCallIndex = toolCall.index;\n              this.#currentToolCall = accumulatedRunStep.step_details.tool_calls[toolCall.index];\n              if (this.#currentToolCall) this._emit('toolCallCreated', this.#currentToolCall);\n            }\n          }\n        }\n\n        this._emit('runStepDelta', event.data.delta, accumulatedRunStep);\n        break;\n      case 'thread.run.step.completed':\n      case 'thread.run.step.failed':\n      case 'thread.run.step.cancelled':\n      case 'thread.run.step.expired':\n        this.#currentRunStepSnapshot = undefined;\n        const details = event.data.step_details;\n        if (details.type == 'tool_calls') {\n          if (this.#currentToolCall) {\n            this._emit('toolCallDone', this.#currentToolCall as ToolCall);\n            this.#currentToolCall = undefined;\n          }\n        }\n        this._emit('runStepDone', event.data, accumulatedRunStep);\n        break;\n      case 'thread.run.step.in_progress':\n        break;\n    }\n  }\n\n  #handleEvent(this: AssistantStream, event: AssistantStreamEvent) {\n    this.#events.push(event);\n    this._emit('event', event);\n  }\n\n  #accumulateRunStep(event: RunStepStreamEvent): Runs.RunStep {\n    switch (event.event) {\n      case 'thread.run.step.created':\n        this.#runStepSnapshots[event.data.id] = event.data;\n        return event.data;\n\n      case 'thread.run.step.delta':\n        let snapshot = this.#runStepSnapshots[event.data.id] as Runs.RunStep;\n        if (!snapshot) {\n          throw Error('Received a RunStepDelta before creation of a snapshot');\n        }\n\n        let data = event.data;\n\n        if (data.delta) {\n          const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta) as Runs.RunStep;\n          this.#runStepSnapshots[event.data.id] = accumulated;\n        }\n\n        return this.#runStepSnapshots[event.data.id] as Runs.RunStep;\n\n      case 'thread.run.step.completed':\n      case 'thread.run.step.failed':\n      case 'thread.run.step.cancelled':\n      case 'thread.run.step.expired':\n      case 'thread.run.step.in_progress':\n        this.#runStepSnapshots[event.data.id] = event.data;\n        break;\n    }\n\n    if (this.#runStepSnapshots[event.data.id]) return this.#runStepSnapshots[event.data.id] as Runs.RunStep;\n    throw new Error('No snapshot available');\n  }\n\n  #accumulateMessage(\n    event: AssistantStreamEvent,\n    snapshot: Message | undefined,\n  ): [Message, MessageContentDelta[]] {\n    let newContent: MessageContentDelta[] = [];\n\n    switch (event.event) {\n      case 'thread.message.created':\n        //On creation the snapshot is just the initial message\n        return [event.data, newContent];\n\n      case 'thread.message.delta':\n        if (!snapshot) {\n          throw Error(\n            'Received a delta with no existing snapshot (there should be one from message creation)',\n          );\n        }\n\n        let data = event.data;\n\n        //If this delta does not have content, nothing to process\n        if (data.delta.content) {\n          for (const contentElement of data.delta.content) {\n            if (contentElement.index in snapshot.content) {\n              let currentContent = snapshot.content[contentElement.index];\n              snapshot.content[contentElement.index] = this.#accumulateContent(\n                contentElement,\n                currentContent,\n              );\n            } else {\n              snapshot.content[contentElement.index] = contentElement as MessageContent;\n              // This is a new element\n              newContent.push(contentElement);\n            }\n          }\n        }\n\n        return [snapshot, newContent];\n\n      case 'thread.message.in_progress':\n      case 'thread.message.completed':\n      case 'thread.message.incomplete':\n        //No changes on other thread events\n        if (snapshot) {\n          return [snapshot, newContent];\n        } else {\n          throw Error('Received thread message event with no existing snapshot');\n        }\n    }\n    throw Error('Tried to accumulate a non-message event');\n  }\n\n  #accumulateContent(\n    contentElement: MessageContentDelta,\n    currentContent: MessageContent | undefined,\n  ): TextContentBlock | ImageFileContentBlock {\n    return AssistantStream.accumulateDelta(currentContent as unknown as Record<any, any>, contentElement) as\n      | TextContentBlock\n      | ImageFileContentBlock;\n  }\n\n  static accumulateDelta(acc: Record<string, any>, delta: Record<string, any>): Record<string, any> {\n    for (const [key, deltaValue] of Object.entries(delta)) {\n      if (!acc.hasOwnProperty(key)) {\n        acc[key] = deltaValue;\n        continue;\n      }\n\n      let accValue = acc[key];\n      if (accValue === null || accValue === undefined) {\n        acc[key] = deltaValue;\n        continue;\n      }\n\n      // We don't accumulate these special properties\n      if (key === 'index' || key === 'type') {\n        acc[key] = deltaValue;\n        continue;\n      }\n\n      // Type-specific accumulation logic\n      if (typeof accValue === 'string' && typeof deltaValue === 'string') {\n        accValue += deltaValue;\n      } else if (typeof accValue === 'number' && typeof deltaValue === 'number') {\n        accValue += deltaValue;\n      } else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {\n        accValue = this.accumulateDelta(accValue as Record<string, any>, deltaValue as Record<string, any>);\n      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {\n        if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {\n          accValue.push(...deltaValue); // Use spread syntax for efficient addition\n          continue;\n        }\n\n        for (const deltaEntry of deltaValue) {\n          if (!Core.isObj(deltaEntry)) {\n            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);\n          }\n\n          const index = deltaEntry['index'];\n          if (index == null) {\n            console.error(deltaEntry);\n            throw new Error('Expected array delta entry to have an `index` property');\n          }\n\n          if (typeof index !== 'number') {\n            throw new Error(`Expected array delta entry \\`index\\` property to be a number but got ${index}`);\n          }\n\n          const accEntry = accValue[index];\n          if (accEntry == null) {\n            accValue.push(deltaEntry);\n          } else {\n            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);\n          }\n        }\n        continue;\n      } else {\n        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);\n      }\n      acc[key] = accValue;\n    }\n\n    return acc;\n  }\n\n  #handleRun(this: AssistantStream, event: RunStreamEvent) {\n    this.#currentRunSnapshot = event.data;\n    switch (event.event) {\n      case 'thread.run.created':\n        break;\n      case 'thread.run.queued':\n        break;\n      case 'thread.run.in_progress':\n        break;\n      case 'thread.run.requires_action':\n      case 'thread.run.cancelled':\n      case 'thread.run.failed':\n      case 'thread.run.completed':\n      case 'thread.run.expired':\n        this.#finalRun = event.data;\n        if (this.#currentToolCall) {\n          this._emit('toolCallDone', this.#currentToolCall);\n          this.#currentToolCall = undefined;\n        }\n        break;\n      case 'thread.run.cancelling':\n        break;\n    }\n  }\n\n  protected _addRun(run: Run): Run {\n    return run;\n  }\n\n  protected async _threadAssistantStream(\n    params: ThreadCreateAndRunParamsBase,\n    thread: Threads,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createThreadAssistantStream(thread, params, options);\n  }\n\n  protected async _runAssistantStream(\n    threadId: string,\n    runs: Runs,\n    params: RunCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createAssistantStream(runs, threadId, params, options);\n  }\n\n  protected async _runToolAssistantStream(\n    threadId: string,\n    runId: string,\n    runs: Runs,\n    params: RunSubmitToolOutputsParamsStream,\n    options?: Core.RequestOptions,\n  ): Promise<Run> {\n    return await this._createToolAssistantStream(runs, threadId, runId, params, options);\n  }\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessagesPage = exports.Messages = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst MessagesAPI = __importStar(require(\"./messages.js\"));\nconst pagination_1 = require(\"../../../pagination.js\");\nclass Messages extends resource_1.APIResource {\n    /**\n     * Create a message.\n     */\n    create(threadId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieve a message.\n     */\n    retrieve(threadId, messageId, options) {\n        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a message.\n     */\n    update(threadId, messageId, body, options) {\n        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Deletes a message.\n     */\n    del(threadId, messageId, options) {\n        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexports.Messages = Messages;\nclass MessagesPage extends pagination_1.CursorPage {\n}\nexports.MessagesPage = MessagesPage;\n(function (Messages) {\n    Messages.MessagesPage = MessagesAPI.MessagesPage;\n})(Messages = exports.Messages || (exports.Messages = {}));\n//# sourceMappingURL=messages.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport * as Core from '../../../core';\nimport * as MessagesAPI from './messages';\nimport * as AssistantsAPI from '../assistants';\nimport { CursorPage, type CursorPageParams } from '../../../pagination';\n\nexport class Messages extends APIResource {\n  /**\n   * Create a message.\n   */\n  create(\n    threadId: string,\n    body: MessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Message> {\n    return this._client.post(`/threads/${threadId}/messages`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieve a message.\n   */\n  retrieve(threadId: string, messageId: string, options?: Core.RequestOptions): Core.APIPromise<Message> {\n    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Modifies a message.\n   */\n  update(\n    threadId: string,\n    messageId: string,\n    body: MessageUpdateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Message> {\n    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of messages for a given thread.\n   */\n  list(\n    threadId: string,\n    query?: MessageListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<MessagesPage, Message>;\n  list(threadId: string, options?: Core.RequestOptions): Core.PagePromise<MessagesPage, Message>;\n  list(\n    threadId: string,\n    query: MessageListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<MessagesPage, Message> {\n    if (isRequestOptions(query)) {\n      return this.list(threadId, {}, query);\n    }\n    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Deletes a message.\n   */\n  del(threadId: string, messageId: string, options?: Core.RequestOptions): Core.APIPromise<MessageDeleted> {\n    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n}\n\nexport class MessagesPage extends CursorPage<Message> {}\n\n/**\n * A citation within the message that points to a specific quote from a specific\n * File associated with the assistant or the message. Generated when the assistant\n * uses the \"file_search\" tool to search files.\n */\nexport type Annotation = FileCitationAnnotation | FilePathAnnotation;\n\n/**\n * A citation within the message that points to a specific quote from a specific\n * File associated with the assistant or the message. Generated when the assistant\n * uses the \"file_search\" tool to search files.\n */\nexport type AnnotationDelta = FileCitationDeltaAnnotation | FilePathDeltaAnnotation;\n\n/**\n * A citation within the message that points to a specific quote from a specific\n * File associated with the assistant or the message. Generated when the assistant\n * uses the \"file_search\" tool to search files.\n */\nexport interface FileCitationAnnotation {\n  end_index: number;\n\n  file_citation: FileCitationAnnotation.FileCitation;\n\n  start_index: number;\n\n  /**\n   * The text in the message content that needs to be replaced.\n   */\n  text: string;\n\n  /**\n   * Always `file_citation`.\n   */\n  type: 'file_citation';\n}\n\nexport namespace FileCitationAnnotation {\n  export interface FileCitation {\n    /**\n     * The ID of the specific File the citation is from.\n     */\n    file_id: string;\n  }\n}\n\n/**\n * A citation within the message that points to a specific quote from a specific\n * File associated with the assistant or the message. Generated when the assistant\n * uses the \"file_search\" tool to search files.\n */\nexport interface FileCitationDeltaAnnotation {\n  /**\n   * The index of the annotation in the text content part.\n   */\n  index: number;\n\n  /**\n   * Always `file_citation`.\n   */\n  type: 'file_citation';\n\n  end_index?: number;\n\n  file_citation?: FileCitationDeltaAnnotation.FileCitation;\n\n  start_index?: number;\n\n  /**\n   * The text in the message content that needs to be replaced.\n   */\n  text?: string;\n}\n\nexport namespace FileCitationDeltaAnnotation {\n  export interface FileCitation {\n    /**\n     * The ID of the specific File the citation is from.\n     */\n    file_id?: string;\n\n    /**\n     * The specific quote in the file.\n     */\n    quote?: string;\n  }\n}\n\n/**\n * A URL for the file that's generated when the assistant used the\n * `code_interpreter` tool to generate a file.\n */\nexport interface FilePathAnnotation {\n  end_index: number;\n\n  file_path: FilePathAnnotation.FilePath;\n\n  start_index: number;\n\n  /**\n   * The text in the message content that needs to be replaced.\n   */\n  text: string;\n\n  /**\n   * Always `file_path`.\n   */\n  type: 'file_path';\n}\n\nexport namespace FilePathAnnotation {\n  export interface FilePath {\n    /**\n     * The ID of the file that was generated.\n     */\n    file_id: string;\n  }\n}\n\n/**\n * A URL for the file that's generated when the assistant used the\n * `code_interpreter` tool to generate a file.\n */\nexport interface FilePathDeltaAnnotation {\n  /**\n   * The index of the annotation in the text content part.\n   */\n  index: number;\n\n  /**\n   * Always `file_path`.\n   */\n  type: 'file_path';\n\n  end_index?: number;\n\n  file_path?: FilePathDeltaAnnotation.FilePath;\n\n  start_index?: number;\n\n  /**\n   * The text in the message content that needs to be replaced.\n   */\n  text?: string;\n}\n\nexport namespace FilePathDeltaAnnotation {\n  export interface FilePath {\n    /**\n     * The ID of the file that was generated.\n     */\n    file_id?: string;\n  }\n}\n\nexport interface ImageFile {\n  /**\n   * The [File](https://platform.openai.com/docs/api-reference/files) ID of the image\n   * in the message content. Set `purpose=\"vision\"` when uploading the File if you\n   * need to later display the file content.\n   */\n  file_id: string;\n\n  /**\n   * Specifies the detail level of the image if specified by the user. `low` uses\n   * fewer tokens, you can opt in to high resolution using `high`.\n   */\n  detail?: 'auto' | 'low' | 'high';\n}\n\n/**\n * References an image [File](https://platform.openai.com/docs/api-reference/files)\n * in the content of a message.\n */\nexport interface ImageFileContentBlock {\n  image_file: ImageFile;\n\n  /**\n   * Always `image_file`.\n   */\n  type: 'image_file';\n}\n\nexport interface ImageFileDelta {\n  /**\n   * Specifies the detail level of the image if specified by the user. `low` uses\n   * fewer tokens, you can opt in to high resolution using `high`.\n   */\n  detail?: 'auto' | 'low' | 'high';\n\n  /**\n   * The [File](https://platform.openai.com/docs/api-reference/files) ID of the image\n   * in the message content. Set `purpose=\"vision\"` when uploading the File if you\n   * need to later display the file content.\n   */\n  file_id?: string;\n}\n\n/**\n * References an image [File](https://platform.openai.com/docs/api-reference/files)\n * in the content of a message.\n */\nexport interface ImageFileDeltaBlock {\n  /**\n   * The index of the content part in the message.\n   */\n  index: number;\n\n  /**\n   * Always `image_file`.\n   */\n  type: 'image_file';\n\n  image_file?: ImageFileDelta;\n}\n\nexport interface ImageURL {\n  /**\n   * The external URL of the image, must be a supported image types: jpeg, jpg, png,\n   * gif, webp.\n   */\n  url: string;\n\n  /**\n   * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in\n   * to high resolution using `high`. Default value is `auto`\n   */\n  detail?: 'auto' | 'low' | 'high';\n}\n\n/**\n * References an image URL in the content of a message.\n */\nexport interface ImageURLContentBlock {\n  image_url: ImageURL;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'image_url';\n}\n\nexport interface ImageURLDelta {\n  /**\n   * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in\n   * to high resolution using `high`.\n   */\n  detail?: 'auto' | 'low' | 'high';\n\n  /**\n   * The URL of the image, must be a supported image types: jpeg, jpg, png, gif,\n   * webp.\n   */\n  url?: string;\n}\n\n/**\n * References an image URL in the content of a message.\n */\nexport interface ImageURLDeltaBlock {\n  /**\n   * The index of the content part in the message.\n   */\n  index: number;\n\n  /**\n   * Always `image_url`.\n   */\n  type: 'image_url';\n\n  image_url?: ImageURLDelta;\n}\n\n/**\n * Represents a message within a\n * [thread](https://platform.openai.com/docs/api-reference/threads).\n */\nexport interface Message {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * If applicable, the ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) that\n   * authored this message.\n   */\n  assistant_id: string | null;\n\n  /**\n   * A list of files attached to the message, and the tools they were added to.\n   */\n  attachments: Array<Message.Attachment> | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the message was completed.\n   */\n  completed_at: number | null;\n\n  /**\n   * The content of the message in array of text and/or images.\n   */\n  content: Array<MessageContent>;\n\n  /**\n   * The Unix timestamp (in seconds) for when the message was created.\n   */\n  created_at: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the message was marked as incomplete.\n   */\n  incomplete_at: number | null;\n\n  /**\n   * On an incomplete message, details about why the message is incomplete.\n   */\n  incomplete_details: Message.IncompleteDetails | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * The object type, which is always `thread.message`.\n   */\n  object: 'thread.message';\n\n  /**\n   * The entity that produced the message. One of `user` or `assistant`.\n   */\n  role: 'user' | 'assistant';\n\n  /**\n   * The ID of the [run](https://platform.openai.com/docs/api-reference/runs)\n   * associated with the creation of this message. Value is `null` when messages are\n   * created manually using the create message or create thread endpoints.\n   */\n  run_id: string | null;\n\n  /**\n   * The status of the message, which can be either `in_progress`, `incomplete`, or\n   * `completed`.\n   */\n  status: 'in_progress' | 'incomplete' | 'completed';\n\n  /**\n   * The [thread](https://platform.openai.com/docs/api-reference/threads) ID that\n   * this message belongs to.\n   */\n  thread_id: string;\n}\n\nexport namespace Message {\n  export interface Attachment {\n    /**\n     * The ID of the file to attach to the message.\n     */\n    file_id?: string;\n\n    /**\n     * The tools to add this file to.\n     */\n    tools?: Array<AssistantsAPI.CodeInterpreterTool | Attachment.AssistantToolsFileSearchTypeOnly>;\n  }\n\n  export namespace Attachment {\n    export interface AssistantToolsFileSearchTypeOnly {\n      /**\n       * The type of tool being defined: `file_search`\n       */\n      type: 'file_search';\n    }\n  }\n\n  /**\n   * On an incomplete message, details about why the message is incomplete.\n   */\n  export interface IncompleteDetails {\n    /**\n     * The reason the message is incomplete.\n     */\n    reason: 'content_filter' | 'max_tokens' | 'run_cancelled' | 'run_expired' | 'run_failed';\n  }\n}\n\n/**\n * References an image [File](https://platform.openai.com/docs/api-reference/files)\n * in the content of a message.\n */\nexport type MessageContent =\n  | ImageFileContentBlock\n  | ImageURLContentBlock\n  | TextContentBlock\n  | RefusalContentBlock;\n\n/**\n * References an image [File](https://platform.openai.com/docs/api-reference/files)\n * in the content of a message.\n */\nexport type MessageContentDelta =\n  | ImageFileDeltaBlock\n  | TextDeltaBlock\n  | RefusalDeltaBlock\n  | ImageURLDeltaBlock;\n\n/**\n * References an image [File](https://platform.openai.com/docs/api-reference/files)\n * in the content of a message.\n */\nexport type MessageContentPartParam = ImageFileContentBlock | ImageURLContentBlock | TextContentBlockParam;\n\nexport interface MessageDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'thread.message.deleted';\n}\n\n/**\n * The delta containing the fields that have changed on the Message.\n */\nexport interface MessageDelta {\n  /**\n   * The content of the message in array of text and/or images.\n   */\n  content?: Array<MessageContentDelta>;\n\n  /**\n   * The entity that produced the message. One of `user` or `assistant`.\n   */\n  role?: 'user' | 'assistant';\n}\n\n/**\n * Represents a message delta i.e. any changed fields on a message during\n * streaming.\n */\nexport interface MessageDeltaEvent {\n  /**\n   * The identifier of the message, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The delta containing the fields that have changed on the Message.\n   */\n  delta: MessageDelta;\n\n  /**\n   * The object type, which is always `thread.message.delta`.\n   */\n  object: 'thread.message.delta';\n}\n\n/**\n * The refusal content generated by the assistant.\n */\nexport interface RefusalContentBlock {\n  refusal: string;\n\n  /**\n   * Always `refusal`.\n   */\n  type: 'refusal';\n}\n\n/**\n * The refusal content that is part of a message.\n */\nexport interface RefusalDeltaBlock {\n  /**\n   * The index of the refusal part in the message.\n   */\n  index: number;\n\n  /**\n   * Always `refusal`.\n   */\n  type: 'refusal';\n\n  refusal?: string;\n}\n\nexport interface Text {\n  annotations: Array<Annotation>;\n\n  /**\n   * The data that makes up the text.\n   */\n  value: string;\n}\n\n/**\n * The text content that is part of a message.\n */\nexport interface TextContentBlock {\n  text: Text;\n\n  /**\n   * Always `text`.\n   */\n  type: 'text';\n}\n\n/**\n * The text content that is part of a message.\n */\nexport interface TextContentBlockParam {\n  /**\n   * Text content to be sent to the model\n   */\n  text: string;\n\n  /**\n   * Always `text`.\n   */\n  type: 'text';\n}\n\nexport interface TextDelta {\n  annotations?: Array<AnnotationDelta>;\n\n  /**\n   * The data that makes up the text.\n   */\n  value?: string;\n}\n\n/**\n * The text content that is part of a message.\n */\nexport interface TextDeltaBlock {\n  /**\n   * The index of the content part in the message.\n   */\n  index: number;\n\n  /**\n   * Always `text`.\n   */\n  type: 'text';\n\n  text?: TextDelta;\n}\n\nexport interface MessageCreateParams {\n  /**\n   * The text contents of the message.\n   */\n  content: string | Array<MessageContentPartParam>;\n\n  /**\n   * The role of the entity that is creating the message. Allowed values include:\n   *\n   * - `user`: Indicates the message is sent by an actual user and should be used in\n   *   most cases to represent user-generated messages.\n   * - `assistant`: Indicates the message is generated by the assistant. Use this\n   *   value to insert messages from the assistant into the conversation.\n   */\n  role: 'user' | 'assistant';\n\n  /**\n   * A list of files attached to the message, and the tools they should be added to.\n   */\n  attachments?: Array<MessageCreateParams.Attachment> | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n}\n\nexport namespace MessageCreateParams {\n  export interface Attachment {\n    /**\n     * The ID of the file to attach to the message.\n     */\n    file_id?: string;\n\n    /**\n     * The tools to add this file to.\n     */\n    tools?: Array<AssistantsAPI.CodeInterpreterTool | Attachment.FileSearch>;\n  }\n\n  export namespace Attachment {\n    export interface FileSearch {\n      /**\n       * The type of tool being defined: `file_search`\n       */\n      type: 'file_search';\n    }\n  }\n}\n\nexport interface MessageUpdateParams {\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n}\n\nexport interface MessageListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n\n  /**\n   * Filter messages by the run ID that generated them.\n   */\n  run_id?: string;\n}\n\nexport namespace Messages {\n  export import Annotation = MessagesAPI.Annotation;\n  export import AnnotationDelta = MessagesAPI.AnnotationDelta;\n  export import FileCitationAnnotation = MessagesAPI.FileCitationAnnotation;\n  export import FileCitationDeltaAnnotation = MessagesAPI.FileCitationDeltaAnnotation;\n  export import FilePathAnnotation = MessagesAPI.FilePathAnnotation;\n  export import FilePathDeltaAnnotation = MessagesAPI.FilePathDeltaAnnotation;\n  export import ImageFile = MessagesAPI.ImageFile;\n  export import ImageFileContentBlock = MessagesAPI.ImageFileContentBlock;\n  export import ImageFileDelta = MessagesAPI.ImageFileDelta;\n  export import ImageFileDeltaBlock = MessagesAPI.ImageFileDeltaBlock;\n  export import ImageURL = MessagesAPI.ImageURL;\n  export import ImageURLContentBlock = MessagesAPI.ImageURLContentBlock;\n  export import ImageURLDelta = MessagesAPI.ImageURLDelta;\n  export import ImageURLDeltaBlock = MessagesAPI.ImageURLDeltaBlock;\n  export import Message = MessagesAPI.Message;\n  export import MessageContent = MessagesAPI.MessageContent;\n  export import MessageContentDelta = MessagesAPI.MessageContentDelta;\n  export import MessageContentPartParam = MessagesAPI.MessageContentPartParam;\n  export import MessageDeleted = MessagesAPI.MessageDeleted;\n  export import MessageDelta = MessagesAPI.MessageDelta;\n  export import MessageDeltaEvent = MessagesAPI.MessageDeltaEvent;\n  export import RefusalContentBlock = MessagesAPI.RefusalContentBlock;\n  export import RefusalDeltaBlock = MessagesAPI.RefusalDeltaBlock;\n  export import Text = MessagesAPI.Text;\n  export import TextContentBlock = MessagesAPI.TextContentBlock;\n  export import TextContentBlockParam = MessagesAPI.TextContentBlockParam;\n  export import TextDelta = MessagesAPI.TextDelta;\n  export import TextDeltaBlock = MessagesAPI.TextDeltaBlock;\n  export import MessagesPage = MessagesAPI.MessagesPage;\n  export import MessageCreateParams = MessagesAPI.MessageCreateParams;\n  export import MessageUpdateParams = MessagesAPI.MessageUpdateParams;\n  export import MessageListParams = MessagesAPI.MessageListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunsPage = exports.Runs = void 0;\nconst resource_1 = require(\"../../../../resource.js\");\nconst core_1 = require(\"../../../../core.js\");\nconst AssistantStream_1 = require(\"../../../../lib/AssistantStream.js\");\nconst core_2 = require(\"../../../../core.js\");\nconst RunsAPI = __importStar(require(\"./runs.js\"));\nconst StepsAPI = __importStar(require(\"./steps.js\"));\nconst pagination_1 = require(\"../../../../pagination.js\");\nclass Runs extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.steps = new StepsAPI.Steps(this._client);\n    }\n    create(threadId, params, options) {\n        const { include, ...body } = params;\n        return this._client.post(`/threads/${threadId}/runs`, {\n            query: { include },\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Retrieves a run.\n     */\n    retrieve(threadId, runId, options) {\n        return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a run.\n     */\n    update(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list(threadId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancels a run that is `in_progress`.\n     */\n    cancel(threadId, runId, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * A helper to create a run an poll for a terminal state. More information on Run\n     * lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async createAndPoll(threadId, body, options) {\n        const run = await this.create(threadId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Create a Run stream\n     *\n     * @deprecated use `stream` instead\n     */\n    createAndStream(threadId, body, options) {\n        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    /**\n     * A helper to poll a run status until it reaches a terminal state. More\n     * information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async poll(threadId, runId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: run, response } = await this.retrieve(threadId, runId, {\n                ...options,\n                headers: { ...options?.headers, ...headers },\n            }).withResponse();\n            switch (run.status) {\n                //If we are in any sort of intermediate state we poll\n                case 'queued':\n                case 'in_progress':\n                case 'cancelling':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await (0, core_2.sleep)(sleepInterval);\n                    break;\n                //We return the run in any terminal state.\n                case 'requires_action':\n                case 'incomplete':\n                case 'cancelled':\n                case 'completed':\n                case 'failed':\n                case 'expired':\n                    return run;\n            }\n        }\n    }\n    /**\n     * Create a Run stream\n     */\n    stream(threadId, body, options) {\n        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n    }\n    submitToolOutputs(threadId, runId, body, options) {\n        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * A helper to submit a tool output to a run and poll for a terminal run state.\n     * More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    async submitToolOutputsAndPoll(threadId, runId, body, options) {\n        const run = await this.submitToolOutputs(threadId, runId, body, options);\n        return await this.poll(threadId, run.id, options);\n    }\n    /**\n     * Submit the tool outputs from a previous run and stream the run to a terminal\n     * state. More information on Run lifecycles can be found here:\n     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n     */\n    submitToolOutputsStream(threadId, runId, body, options) {\n        return AssistantStream_1.AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);\n    }\n}\nexports.Runs = Runs;\nclass RunsPage extends pagination_1.CursorPage {\n}\nexports.RunsPage = RunsPage;\n(function (Runs) {\n    Runs.RunsPage = RunsAPI.RunsPage;\n    Runs.Steps = StepsAPI.Steps;\n    Runs.RunStepsPage = StepsAPI.RunStepsPage;\n})(Runs = exports.Runs || (exports.Runs = {}));\n//# sourceMappingURL=runs.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../../resource';\nimport { isRequestOptions } from '../../../../core';\nimport { APIPromise } from '../../../../core';\nimport * as Core from '../../../../core';\nimport { AssistantStream, RunCreateParamsBaseStream } from '../../../../lib/AssistantStream';\nimport { sleep } from '../../../../core';\nimport { RunSubmitToolOutputsParamsStream } from '../../../../lib/AssistantStream';\nimport * as RunsAPI from './runs';\nimport * as AssistantsAPI from '../../assistants';\nimport * as ChatAPI from '../../../chat/chat';\nimport * as MessagesAPI from '../messages';\nimport * as ThreadsAPI from '../threads';\nimport * as StepsAPI from './steps';\nimport { CursorPage, type CursorPageParams } from '../../../../pagination';\nimport { Stream } from '../../../../streaming';\n\nexport class Runs extends APIResource {\n  steps: StepsAPI.Steps = new StepsAPI.Steps(this._client);\n\n  /**\n   * Create a run.\n   */\n  create(\n    threadId: string,\n    params: RunCreateParamsNonStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Run>;\n  create(\n    threadId: string,\n    params: RunCreateParamsStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  create(\n    threadId: string,\n    params: RunCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent> | Run>;\n  create(\n    threadId: string,\n    params: RunCreateParams,\n    options?: Core.RequestOptions,\n  ): APIPromise<Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>> {\n    const { include, ...body } = params;\n    return this._client.post(`/threads/${threadId}/runs`, {\n      query: { include },\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n      stream: params.stream ?? false,\n    }) as APIPromise<Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  }\n\n  /**\n   * Retrieves a run.\n   */\n  retrieve(threadId: string, runId: string, options?: Core.RequestOptions): Core.APIPromise<Run> {\n    return this._client.get(`/threads/${threadId}/runs/${runId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Modifies a run.\n   */\n  update(\n    threadId: string,\n    runId: string,\n    body: RunUpdateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Run> {\n    return this._client.post(`/threads/${threadId}/runs/${runId}`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of runs belonging to a thread.\n   */\n  list(\n    threadId: string,\n    query?: RunListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<RunsPage, Run>;\n  list(threadId: string, options?: Core.RequestOptions): Core.PagePromise<RunsPage, Run>;\n  list(\n    threadId: string,\n    query: RunListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<RunsPage, Run> {\n    if (isRequestOptions(query)) {\n      return this.list(threadId, {}, query);\n    }\n    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Cancels a run that is `in_progress`.\n   */\n  cancel(threadId: string, runId: string, options?: Core.RequestOptions): Core.APIPromise<Run> {\n    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * A helper to create a run an poll for a terminal state. More information on Run\n   * lifecycles can be found here:\n   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n   */\n  async createAndPoll(\n    threadId: string,\n    body: RunCreateParamsNonStreaming,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<Run> {\n    const run = await this.create(threadId, body, options);\n    return await this.poll(threadId, run.id, options);\n  }\n\n  /**\n   * Create a Run stream\n   *\n   * @deprecated use `stream` instead\n   */\n  createAndStream(\n    threadId: string,\n    body: RunCreateParamsBaseStream,\n    options?: Core.RequestOptions,\n  ): AssistantStream {\n    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n  }\n\n  /**\n   * A helper to poll a run status until it reaches a terminal state. More\n   * information on Run lifecycles can be found here:\n   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n   */\n  async poll(\n    threadId: string,\n    runId: string,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<Run> {\n    const headers: { [key: string]: string } = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n\n    if (options?.pollIntervalMs) {\n      headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n    }\n\n    while (true) {\n      const { data: run, response } = await this.retrieve(threadId, runId, {\n        ...options,\n        headers: { ...options?.headers, ...headers },\n      }).withResponse();\n\n      switch (run.status) {\n        //If we are in any sort of intermediate state we poll\n        case 'queued':\n        case 'in_progress':\n        case 'cancelling':\n          let sleepInterval = 5000;\n\n          if (options?.pollIntervalMs) {\n            sleepInterval = options.pollIntervalMs;\n          } else {\n            const headerInterval = response.headers.get('openai-poll-after-ms');\n            if (headerInterval) {\n              const headerIntervalMs = parseInt(headerInterval);\n              if (!isNaN(headerIntervalMs)) {\n                sleepInterval = headerIntervalMs;\n              }\n            }\n          }\n          await sleep(sleepInterval);\n          break;\n        //We return the run in any terminal state.\n        case 'requires_action':\n        case 'incomplete':\n        case 'cancelled':\n        case 'completed':\n        case 'failed':\n        case 'expired':\n          return run;\n      }\n    }\n  }\n\n  /**\n   * Create a Run stream\n   */\n  stream(threadId: string, body: RunCreateParamsBaseStream, options?: Core.RequestOptions): AssistantStream {\n    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);\n  }\n\n  /**\n   * When a run has the `status: \"requires_action\"` and `required_action.type` is\n   * `submit_tool_outputs`, this endpoint can be used to submit the outputs from the\n   * tool calls once they're all completed. All outputs must be submitted in a single\n   * request.\n   */\n  submitToolOutputs(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParamsNonStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Run>;\n  submitToolOutputs(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParamsStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  submitToolOutputs(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParamsBase,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<AssistantsAPI.AssistantStreamEvent> | Run>;\n  submitToolOutputs(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParams,\n    options?: Core.RequestOptions,\n  ): APIPromise<Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>> {\n    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n      stream: body.stream ?? false,\n    }) as APIPromise<Run> | APIPromise<Stream<AssistantsAPI.AssistantStreamEvent>>;\n  }\n\n  /**\n   * A helper to submit a tool output to a run and poll for a terminal run state.\n   * More information on Run lifecycles can be found here:\n   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n   */\n  async submitToolOutputsAndPoll(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParamsNonStreaming,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<Run> {\n    const run = await this.submitToolOutputs(threadId, runId, body, options);\n    return await this.poll(threadId, run.id, options);\n  }\n\n  /**\n   * Submit the tool outputs from a previous run and stream the run to a terminal\n   * state. More information on Run lifecycles can be found here:\n   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps\n   */\n  submitToolOutputsStream(\n    threadId: string,\n    runId: string,\n    body: RunSubmitToolOutputsParamsStream,\n    options?: Core.RequestOptions,\n  ): AssistantStream {\n    return AssistantStream.createToolAssistantStream(\n      threadId,\n      runId,\n      this._client.beta.threads.runs,\n      body,\n      options,\n    );\n  }\n}\n\nexport class RunsPage extends CursorPage<Run> {}\n\n/**\n * Tool call objects\n */\nexport interface RequiredActionFunctionToolCall {\n  /**\n   * The ID of the tool call. This ID must be referenced when you submit the tool\n   * outputs in using the\n   * [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs)\n   * endpoint.\n   */\n  id: string;\n\n  /**\n   * The function definition.\n   */\n  function: RequiredActionFunctionToolCall.Function;\n\n  /**\n   * The type of tool call the output is required for. For now, this is always\n   * `function`.\n   */\n  type: 'function';\n}\n\nexport namespace RequiredActionFunctionToolCall {\n  /**\n   * The function definition.\n   */\n  export interface Function {\n    /**\n     * The arguments that the model expects you to pass to the function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function.\n     */\n    name: string;\n  }\n}\n\n/**\n * Represents an execution run on a\n * [thread](https://platform.openai.com/docs/api-reference/threads).\n */\nexport interface Run {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) used for\n   * execution of this run.\n   */\n  assistant_id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run was cancelled.\n   */\n  cancelled_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run was completed.\n   */\n  completed_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run was created.\n   */\n  created_at: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run will expire.\n   */\n  expires_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run failed.\n   */\n  failed_at: number | null;\n\n  /**\n   * Details on why the run is incomplete. Will be `null` if the run is not\n   * incomplete.\n   */\n  incomplete_details: Run.IncompleteDetails | null;\n\n  /**\n   * The instructions that the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) used for\n   * this run.\n   */\n  instructions: string;\n\n  /**\n   * The last error associated with this run. Will be `null` if there are no errors.\n   */\n  last_error: Run.LastError | null;\n\n  /**\n   * The maximum number of completion tokens specified to have been used over the\n   * course of the run.\n   */\n  max_completion_tokens: number | null;\n\n  /**\n   * The maximum number of prompt tokens specified to have been used over the course\n   * of the run.\n   */\n  max_prompt_tokens: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * The model that the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) used for\n   * this run.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always `thread.run`.\n   */\n  object: 'thread.run';\n\n  /**\n   * Whether to enable\n   * [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)\n   * during tool use.\n   */\n  parallel_tool_calls: boolean;\n\n  /**\n   * Details on the action required to continue the run. Will be `null` if no action\n   * is required.\n   */\n  required_action: Run.RequiredAction | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run was started.\n   */\n  started_at: number | null;\n\n  /**\n   * The status of the run, which can be either `queued`, `in_progress`,\n   * `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`,\n   * `incomplete`, or `expired`.\n   */\n  status: RunStatus;\n\n  /**\n   * The ID of the [thread](https://platform.openai.com/docs/api-reference/threads)\n   * that was executed on as a part of this run.\n   */\n  thread_id: string;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice: ThreadsAPI.AssistantToolChoiceOption | null;\n\n  /**\n   * The list of tools that the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) used for\n   * this run.\n   */\n  tools: Array<AssistantsAPI.AssistantTool>;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy: Run.TruncationStrategy | null;\n\n  /**\n   * Usage statistics related to the run. This value will be `null` if the run is not\n   * in a terminal state (i.e. `in_progress`, `queued`, etc.).\n   */\n  usage: Run.Usage | null;\n\n  /**\n   * The sampling temperature used for this run. If not set, defaults to 1.\n   */\n  temperature?: number | null;\n\n  /**\n   * The nucleus sampling value used for this run. If not set, defaults to 1.\n   */\n  top_p?: number | null;\n}\n\nexport namespace Run {\n  /**\n   * Details on why the run is incomplete. Will be `null` if the run is not\n   * incomplete.\n   */\n  export interface IncompleteDetails {\n    /**\n     * The reason why the run is incomplete. This will point to which specific token\n     * limit was reached over the course of the run.\n     */\n    reason?: 'max_completion_tokens' | 'max_prompt_tokens';\n  }\n\n  /**\n   * The last error associated with this run. Will be `null` if there are no errors.\n   */\n  export interface LastError {\n    /**\n     * One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.\n     */\n    code: 'server_error' | 'rate_limit_exceeded' | 'invalid_prompt';\n\n    /**\n     * A human-readable description of the error.\n     */\n    message: string;\n  }\n\n  /**\n   * Details on the action required to continue the run. Will be `null` if no action\n   * is required.\n   */\n  export interface RequiredAction {\n    /**\n     * Details on the tool outputs needed for this run to continue.\n     */\n    submit_tool_outputs: RequiredAction.SubmitToolOutputs;\n\n    /**\n     * For now, this is always `submit_tool_outputs`.\n     */\n    type: 'submit_tool_outputs';\n  }\n\n  export namespace RequiredAction {\n    /**\n     * Details on the tool outputs needed for this run to continue.\n     */\n    export interface SubmitToolOutputs {\n      /**\n       * A list of the relevant tool calls.\n       */\n      tool_calls: Array<RunsAPI.RequiredActionFunctionToolCall>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n\n  /**\n   * Usage statistics related to the run. This value will be `null` if the run is not\n   * in a terminal state (i.e. `in_progress`, `queued`, etc.).\n   */\n  export interface Usage {\n    /**\n     * Number of completion tokens used over the course of the run.\n     */\n    completion_tokens: number;\n\n    /**\n     * Number of prompt tokens used over the course of the run.\n     */\n    prompt_tokens: number;\n\n    /**\n     * Total number of tokens used (prompt + completion).\n     */\n    total_tokens: number;\n  }\n}\n\n/**\n * The status of the run, which can be either `queued`, `in_progress`,\n * `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`,\n * `incomplete`, or `expired`.\n */\nexport type RunStatus =\n  | 'queued'\n  | 'in_progress'\n  | 'requires_action'\n  | 'cancelling'\n  | 'cancelled'\n  | 'failed'\n  | 'completed'\n  | 'incomplete'\n  | 'expired';\n\nexport type RunCreateParams = RunCreateParamsNonStreaming | RunCreateParamsStreaming;\n\nexport interface RunCreateParamsBase {\n  /**\n   * Body param: The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Query param: A list of additional fields to include in the response. Currently\n   * the only supported value is\n   * `step_details.tool_calls[*].file_search.results[*].content` to fetch the file\n   * search result content.\n   *\n   * See the\n   * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n   * for more information.\n   */\n  include?: Array<StepsAPI.RunStepInclude>;\n\n  /**\n   * Body param: Appends additional instructions at the end of the instructions for\n   * the run. This is useful for modifying the behavior on a per-run basis without\n   * overriding other instructions.\n   */\n  additional_instructions?: string | null;\n\n  /**\n   * Body param: Adds additional messages to the thread before creating the run.\n   */\n  additional_messages?: Array<RunCreateParams.AdditionalMessage> | null;\n\n  /**\n   * Body param: Overrides the\n   * [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant)\n   * of the assistant. This is useful for modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * Body param: The maximum number of completion tokens that may be used over the\n   * course of the run. The run will make a best effort to use only the number of\n   * completion tokens specified, across multiple turns of the run. If the run\n   * exceeds the number of completion tokens specified, the run will end with status\n   * `incomplete`. See `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * Body param: The maximum number of prompt tokens that may be used over the course\n   * of the run. The run will make a best effort to use only the number of prompt\n   * tokens specified, across multiple turns of the run. If the run exceeds the\n   * number of prompt tokens specified, the run will end with status `incomplete`.\n   * See `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Body param: Set of 16 key-value pairs that can be attached to an object. This\n   * can be useful for storing additional information about the object in a\n   * structured format. Keys can be a maximum of 64 characters long and values can be\n   * a maxium of 512 characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * Body param: The ID of the\n   * [Model](https://platform.openai.com/docs/api-reference/models) to be used to\n   * execute this run. If a value is provided here, it will override the model\n   * associated with the assistant. If not, the model associated with the assistant\n   * will be used.\n   */\n  model?: (string & {}) | ChatAPI.ChatModel | null;\n\n  /**\n   * Body param: Whether to enable\n   * [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)\n   * during tool use.\n   */\n  parallel_tool_calls?: boolean;\n\n  /**\n   * Body param: Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured\n   * Outputs which ensures the model will match your supplied JSON schema. Learn more\n   * in the\n   * [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * Body param: If `true`, returns a stream of events that happen during the Run as\n   * server-sent events, terminating when the Run enters a terminal state with a\n   * `data: [DONE]` message.\n   */\n  stream?: boolean | null;\n\n  /**\n   * Body param: What sampling temperature to use, between 0 and 2. Higher values\n   * like 0.8 will make the output more random, while lower values like 0.2 will make\n   * it more focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * Body param: Controls which (if any) tool is called by the model. `none` means\n   * the model will not call any tools and instead generates a message. `auto` is the\n   * default value and means the model can pick between generating a message or\n   * calling one or more tools. `required` means the model must call one or more\n   * tools before responding to the user. Specifying a particular tool like\n   * `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: ThreadsAPI.AssistantToolChoiceOption | null;\n\n  /**\n   * Body param: Override the tools the assistant can use for this run. This is\n   * useful for modifying the behavior on a per-run basis.\n   */\n  tools?: Array<AssistantsAPI.AssistantTool> | null;\n\n  /**\n   * Body param: An alternative to sampling with temperature, called nucleus\n   * sampling, where the model considers the results of the tokens with top_p\n   * probability mass. So 0.1 means only the tokens comprising the top 10%\n   * probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Body param: Controls for how a thread will be truncated prior to the run. Use\n   * this to control the intial context window of the run.\n   */\n  truncation_strategy?: RunCreateParams.TruncationStrategy | null;\n}\n\nexport namespace RunCreateParams {\n  export interface AdditionalMessage {\n    /**\n     * The text contents of the message.\n     */\n    content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n    /**\n     * The role of the entity that is creating the message. Allowed values include:\n     *\n     * - `user`: Indicates the message is sent by an actual user and should be used in\n     *   most cases to represent user-generated messages.\n     * - `assistant`: Indicates the message is generated by the assistant. Use this\n     *   value to insert messages from the assistant into the conversation.\n     */\n    role: 'user' | 'assistant';\n\n    /**\n     * A list of files attached to the message, and the tools they should be added to.\n     */\n    attachments?: Array<AdditionalMessage.Attachment> | null;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n  }\n\n  export namespace AdditionalMessage {\n    export interface Attachment {\n      /**\n       * The ID of the file to attach to the message.\n       */\n      file_id?: string;\n\n      /**\n       * The tools to add this file to.\n       */\n      tools?: Array<AssistantsAPI.CodeInterpreterTool | Attachment.FileSearch>;\n    }\n\n    export namespace Attachment {\n      export interface FileSearch {\n        /**\n         * The type of tool being defined: `file_search`\n         */\n        type: 'file_search';\n      }\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n\n  export type RunCreateParamsNonStreaming = RunsAPI.RunCreateParamsNonStreaming;\n  export type RunCreateParamsStreaming = RunsAPI.RunCreateParamsStreaming;\n}\n\nexport interface RunCreateParamsNonStreaming extends RunCreateParamsBase {\n  /**\n   * Body param: If `true`, returns a stream of events that happen during the Run as\n   * server-sent events, terminating when the Run enters a terminal state with a\n   * `data: [DONE]` message.\n   */\n  stream?: false | null;\n}\n\nexport interface RunCreateParamsStreaming extends RunCreateParamsBase {\n  /**\n   * Body param: If `true`, returns a stream of events that happen during the Run as\n   * server-sent events, terminating when the Run enters a terminal state with a\n   * `data: [DONE]` message.\n   */\n  stream: true;\n}\n\nexport interface RunUpdateParams {\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n}\n\nexport interface RunListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport interface RunCreateAndPollParams {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Appends additional instructions at the end of the instructions for the run. This\n   * is useful for modifying the behavior on a per-run basis without overriding other\n   * instructions.\n   */\n  additional_instructions?: string | null;\n\n  /**\n   * Adds additional messages to the thread before creating the run.\n   */\n  additional_messages?: Array<RunCreateAndPollParams.AdditionalMessage> | null;\n\n  /**\n   * Overrides the\n   * [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant)\n   * of the assistant. This is useful for modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?:\n    | (string & {})\n    | 'gpt-4o'\n    | 'gpt-4o-2024-05-13'\n    | 'gpt-4-turbo'\n    | 'gpt-4-turbo-2024-04-09'\n    | 'gpt-4-0125-preview'\n    | 'gpt-4-turbo-preview'\n    | 'gpt-4-1106-preview'\n    | 'gpt-4-vision-preview'\n    | 'gpt-4'\n    | 'gpt-4-0314'\n    | 'gpt-4-0613'\n    | 'gpt-4-32k'\n    | 'gpt-4-32k-0314'\n    | 'gpt-4-32k-0613'\n    | 'gpt-3.5-turbo'\n    | 'gpt-3.5-turbo-16k'\n    | 'gpt-3.5-turbo-0613'\n    | 'gpt-3.5-turbo-1106'\n    | 'gpt-3.5-turbo-0125'\n    | 'gpt-3.5-turbo-16k-0613'\n    | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: ThreadsAPI.AssistantToolChoiceOption | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<AssistantsAPI.AssistantTool> | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: RunCreateAndPollParams.TruncationStrategy | null;\n}\n\nexport namespace RunCreateAndPollParams {\n  export interface AdditionalMessage {\n    /**\n     * The text contents of the message.\n     */\n    content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n    /**\n     * The role of the entity that is creating the message. Allowed values include:\n     *\n     * - `user`: Indicates the message is sent by an actual user and should be used in\n     *   most cases to represent user-generated messages.\n     * - `assistant`: Indicates the message is generated by the assistant. Use this\n     *   value to insert messages from the assistant into the conversation.\n     */\n    role: 'user' | 'assistant';\n\n    /**\n     * A list of files attached to the message, and the tools they should be added to.\n     */\n    attachments?: Array<AdditionalMessage.Attachment> | null;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n  }\n\n  export namespace AdditionalMessage {\n    export interface Attachment {\n      /**\n       * The ID of the file to attach to the message.\n       */\n      file_id?: string;\n\n      /**\n       * The tools to add this file to.\n       */\n      tools?: Array<AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n}\n\nexport interface RunCreateAndStreamParams {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Appends additional instructions at the end of the instructions for the run. This\n   * is useful for modifying the behavior on a per-run basis without overriding other\n   * instructions.\n   */\n  additional_instructions?: string | null;\n\n  /**\n   * Adds additional messages to the thread before creating the run.\n   */\n  additional_messages?: Array<RunCreateAndStreamParams.AdditionalMessage> | null;\n\n  /**\n   * Overrides the\n   * [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant)\n   * of the assistant. This is useful for modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?:\n    | (string & {})\n    | 'gpt-4o'\n    | 'gpt-4o-2024-05-13'\n    | 'gpt-4-turbo'\n    | 'gpt-4-turbo-2024-04-09'\n    | 'gpt-4-0125-preview'\n    | 'gpt-4-turbo-preview'\n    | 'gpt-4-1106-preview'\n    | 'gpt-4-vision-preview'\n    | 'gpt-4'\n    | 'gpt-4-0314'\n    | 'gpt-4-0613'\n    | 'gpt-4-32k'\n    | 'gpt-4-32k-0314'\n    | 'gpt-4-32k-0613'\n    | 'gpt-3.5-turbo'\n    | 'gpt-3.5-turbo-16k'\n    | 'gpt-3.5-turbo-0613'\n    | 'gpt-3.5-turbo-1106'\n    | 'gpt-3.5-turbo-0125'\n    | 'gpt-3.5-turbo-16k-0613'\n    | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: ThreadsAPI.AssistantToolChoiceOption | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<AssistantsAPI.AssistantTool> | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: RunCreateAndStreamParams.TruncationStrategy | null;\n}\n\nexport namespace RunCreateAndStreamParams {\n  export interface AdditionalMessage {\n    /**\n     * The text contents of the message.\n     */\n    content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n    /**\n     * The role of the entity that is creating the message. Allowed values include:\n     *\n     * - `user`: Indicates the message is sent by an actual user and should be used in\n     *   most cases to represent user-generated messages.\n     * - `assistant`: Indicates the message is generated by the assistant. Use this\n     *   value to insert messages from the assistant into the conversation.\n     */\n    role: 'user' | 'assistant';\n\n    /**\n     * A list of files attached to the message, and the tools they should be added to.\n     */\n    attachments?: Array<AdditionalMessage.Attachment> | null;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n  }\n\n  export namespace AdditionalMessage {\n    export interface Attachment {\n      /**\n       * The ID of the file to attach to the message.\n       */\n      file_id?: string;\n\n      /**\n       * The tools to add this file to.\n       */\n      tools?: Array<AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n}\n\nexport interface RunStreamParams {\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to\n   * execute this run.\n   */\n  assistant_id: string;\n\n  /**\n   * Appends additional instructions at the end of the instructions for the run. This\n   * is useful for modifying the behavior on a per-run basis without overriding other\n   * instructions.\n   */\n  additional_instructions?: string | null;\n\n  /**\n   * Adds additional messages to the thread before creating the run.\n   */\n  additional_messages?: Array<RunStreamParams.AdditionalMessage> | null;\n\n  /**\n   * Overrides the\n   * [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant)\n   * of the assistant. This is useful for modifying the behavior on a per-run basis.\n   */\n  instructions?: string | null;\n\n  /**\n   * The maximum number of completion tokens that may be used over the course of the\n   * run. The run will make a best effort to use only the number of completion tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * completion tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * The maximum number of prompt tokens that may be used over the course of the run.\n   * The run will make a best effort to use only the number of prompt tokens\n   * specified, across multiple turns of the run. If the run exceeds the number of\n   * prompt tokens specified, the run will end with status `incomplete`. See\n   * `incomplete_details` for more info.\n   */\n  max_prompt_tokens?: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to\n   * be used to execute this run. If a value is provided here, it will override the\n   * model associated with the assistant. If not, the model associated with the\n   * assistant will be used.\n   */\n  model?:\n    | (string & {})\n    | 'gpt-4o'\n    | 'gpt-4o-2024-05-13'\n    | 'gpt-4-turbo'\n    | 'gpt-4-turbo-2024-04-09'\n    | 'gpt-4-0125-preview'\n    | 'gpt-4-turbo-preview'\n    | 'gpt-4-1106-preview'\n    | 'gpt-4-vision-preview'\n    | 'gpt-4'\n    | 'gpt-4-0314'\n    | 'gpt-4-0613'\n    | 'gpt-4-32k'\n    | 'gpt-4-32k-0314'\n    | 'gpt-4-32k-0613'\n    | 'gpt-3.5-turbo'\n    | 'gpt-3.5-turbo-16k'\n    | 'gpt-3.5-turbo-0613'\n    | 'gpt-3.5-turbo-1106'\n    | 'gpt-3.5-turbo-0125'\n    | 'gpt-3.5-turbo-16k-0613'\n    | null;\n\n  /**\n   * Specifies the format that the model must output. Compatible with\n   * [GPT-4o](https://platform.openai.com/docs/models/gpt-4o),\n   * [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4),\n   * and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message. Without this, the model may\n   * generate an unending stream of whitespace until the generation reaches the token\n   * limit, resulting in a long-running and seemingly \"stuck\" request. Also note that\n   * the message content may be partially cut off if `finish_reason=\"length\"`, which\n   * indicates the generation exceeded `max_tokens` or the conversation exceeded the\n   * max context length.\n   */\n  response_format?: ThreadsAPI.AssistantResponseFormatOption | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   */\n  temperature?: number | null;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tools and instead generates a message. `auto` is the default value\n   * and means the model can pick between generating a message or calling one or more\n   * tools. `required` means the model must call one or more tools before responding\n   * to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   */\n  tool_choice?: ThreadsAPI.AssistantToolChoiceOption | null;\n\n  /**\n   * Override the tools the assistant can use for this run. This is useful for\n   * modifying the behavior on a per-run basis.\n   */\n  tools?: Array<AssistantsAPI.AssistantTool> | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  truncation_strategy?: RunStreamParams.TruncationStrategy | null;\n}\n\nexport namespace RunStreamParams {\n  export interface AdditionalMessage {\n    /**\n     * The text contents of the message.\n     */\n    content: string | Array<MessagesAPI.MessageContentPartParam>;\n\n    /**\n     * The role of the entity that is creating the message. Allowed values include:\n     *\n     * - `user`: Indicates the message is sent by an actual user and should be used in\n     *   most cases to represent user-generated messages.\n     * - `assistant`: Indicates the message is generated by the assistant. Use this\n     *   value to insert messages from the assistant into the conversation.\n     */\n    role: 'user' | 'assistant';\n\n    /**\n     * A list of files attached to the message, and the tools they should be added to.\n     */\n    attachments?: Array<AdditionalMessage.Attachment> | null;\n\n    /**\n     * Set of 16 key-value pairs that can be attached to an object. This can be useful\n     * for storing additional information about the object in a structured format. Keys\n     * can be a maximum of 64 characters long and values can be a maxium of 512\n     * characters long.\n     */\n    metadata?: unknown | null;\n  }\n\n  export namespace AdditionalMessage {\n    export interface Attachment {\n      /**\n       * The ID of the file to attach to the message.\n       */\n      file_id?: string;\n\n      /**\n       * The tools to add this file to.\n       */\n      tools?: Array<AssistantsAPI.CodeInterpreterTool | AssistantsAPI.FileSearchTool>;\n    }\n  }\n\n  /**\n   * Controls for how a thread will be truncated prior to the run. Use this to\n   * control the intial context window of the run.\n   */\n  export interface TruncationStrategy {\n    /**\n     * The truncation strategy to use for the thread. The default is `auto`. If set to\n     * `last_messages`, the thread will be truncated to the n most recent messages in\n     * the thread. When set to `auto`, messages in the middle of the thread will be\n     * dropped to fit the context length of the model, `max_prompt_tokens`.\n     */\n    type: 'auto' | 'last_messages';\n\n    /**\n     * The number of most recent messages from the thread when constructing the context\n     * for the run.\n     */\n    last_messages?: number | null;\n  }\n}\n\nexport type RunSubmitToolOutputsParams =\n  | RunSubmitToolOutputsParamsNonStreaming\n  | RunSubmitToolOutputsParamsStreaming;\n\nexport interface RunSubmitToolOutputsParamsBase {\n  /**\n   * A list of tools for which the outputs are being submitted.\n   */\n  tool_outputs: Array<RunSubmitToolOutputsParams.ToolOutput>;\n\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream?: boolean | null;\n}\n\nexport namespace RunSubmitToolOutputsParams {\n  export interface ToolOutput {\n    /**\n     * The output of the tool call to be submitted to continue the run.\n     */\n    output?: string;\n\n    /**\n     * The ID of the tool call in the `required_action` object within the run object\n     * the output is being submitted for.\n     */\n    tool_call_id?: string;\n  }\n\n  export type RunSubmitToolOutputsParamsNonStreaming = RunsAPI.RunSubmitToolOutputsParamsNonStreaming;\n  export type RunSubmitToolOutputsParamsStreaming = RunsAPI.RunSubmitToolOutputsParamsStreaming;\n}\n\nexport interface RunSubmitToolOutputsParamsNonStreaming extends RunSubmitToolOutputsParamsBase {\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream?: false | null;\n}\n\nexport interface RunSubmitToolOutputsParamsStreaming extends RunSubmitToolOutputsParamsBase {\n  /**\n   * If `true`, returns a stream of events that happen during the Run as server-sent\n   * events, terminating when the Run enters a terminal state with a `data: [DONE]`\n   * message.\n   */\n  stream: true;\n}\n\nexport interface RunSubmitToolOutputsAndPollParams {\n  /**\n   * A list of tools for which the outputs are being submitted.\n   */\n  tool_outputs: Array<RunSubmitToolOutputsAndPollParams.ToolOutput>;\n}\n\nexport namespace RunSubmitToolOutputsAndPollParams {\n  export interface ToolOutput {\n    /**\n     * The output of the tool call to be submitted to continue the run.\n     */\n    output?: string;\n\n    /**\n     * The ID of the tool call in the `required_action` object within the run object\n     * the output is being submitted for.\n     */\n    tool_call_id?: string;\n  }\n}\n\nexport interface RunSubmitToolOutputsStreamParams {\n  /**\n   * A list of tools for which the outputs are being submitted.\n   */\n  tool_outputs: Array<RunSubmitToolOutputsStreamParams.ToolOutput>;\n}\n\nexport namespace RunSubmitToolOutputsStreamParams {\n  export interface ToolOutput {\n    /**\n     * The output of the tool call to be submitted to continue the run.\n     */\n    output?: string;\n\n    /**\n     * The ID of the tool call in the `required_action` object within the run object\n     * the output is being submitted for.\n     */\n    tool_call_id?: string;\n  }\n}\n\nexport namespace Runs {\n  export import RequiredActionFunctionToolCall = RunsAPI.RequiredActionFunctionToolCall;\n  export import Run = RunsAPI.Run;\n  export import RunStatus = RunsAPI.RunStatus;\n  export import RunsPage = RunsAPI.RunsPage;\n  export import RunCreateParams = RunsAPI.RunCreateParams;\n  export import RunCreateParamsNonStreaming = RunsAPI.RunCreateParamsNonStreaming;\n  export import RunCreateParamsStreaming = RunsAPI.RunCreateParamsStreaming;\n  export import RunUpdateParams = RunsAPI.RunUpdateParams;\n  export import RunListParams = RunsAPI.RunListParams;\n  export import RunCreateAndPollParams = RunsAPI.RunCreateAndPollParams;\n  export import RunCreateAndStreamParams = RunsAPI.RunCreateAndStreamParams;\n  export import RunStreamParams = RunsAPI.RunStreamParams;\n  export import RunSubmitToolOutputsParams = RunsAPI.RunSubmitToolOutputsParams;\n  export import RunSubmitToolOutputsParamsNonStreaming = RunsAPI.RunSubmitToolOutputsParamsNonStreaming;\n  export import RunSubmitToolOutputsParamsStreaming = RunsAPI.RunSubmitToolOutputsParamsStreaming;\n  export import RunSubmitToolOutputsAndPollParams = RunsAPI.RunSubmitToolOutputsAndPollParams;\n  export import RunSubmitToolOutputsStreamParams = RunsAPI.RunSubmitToolOutputsStreamParams;\n  export import Steps = StepsAPI.Steps;\n  export import CodeInterpreterLogs = StepsAPI.CodeInterpreterLogs;\n  export import CodeInterpreterOutputImage = StepsAPI.CodeInterpreterOutputImage;\n  export import CodeInterpreterToolCall = StepsAPI.CodeInterpreterToolCall;\n  export import CodeInterpreterToolCallDelta = StepsAPI.CodeInterpreterToolCallDelta;\n  export import FileSearchToolCall = StepsAPI.FileSearchToolCall;\n  export import FileSearchToolCallDelta = StepsAPI.FileSearchToolCallDelta;\n  export import FunctionToolCall = StepsAPI.FunctionToolCall;\n  export import FunctionToolCallDelta = StepsAPI.FunctionToolCallDelta;\n  export import MessageCreationStepDetails = StepsAPI.MessageCreationStepDetails;\n  export import RunStep = StepsAPI.RunStep;\n  export import RunStepDelta = StepsAPI.RunStepDelta;\n  export import RunStepDeltaEvent = StepsAPI.RunStepDeltaEvent;\n  export import RunStepDeltaMessageDelta = StepsAPI.RunStepDeltaMessageDelta;\n  export import RunStepInclude = StepsAPI.RunStepInclude;\n  export import ToolCall = StepsAPI.ToolCall;\n  export import ToolCallDelta = StepsAPI.ToolCallDelta;\n  export import ToolCallDeltaObject = StepsAPI.ToolCallDeltaObject;\n  export import ToolCallsStepDetails = StepsAPI.ToolCallsStepDetails;\n  export import RunStepsPage = StepsAPI.RunStepsPage;\n  export import StepRetrieveParams = StepsAPI.StepRetrieveParams;\n  export import StepListParams = StepsAPI.StepListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunStepsPage = exports.Steps = void 0;\nconst resource_1 = require(\"../../../../resource.js\");\nconst core_1 = require(\"../../../../core.js\");\nconst StepsAPI = __importStar(require(\"./steps.js\"));\nconst pagination_1 = require(\"../../../../pagination.js\");\nclass Steps extends resource_1.APIResource {\n    retrieve(threadId, runId, stepId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.retrieve(threadId, runId, stepId, {}, query);\n        }\n        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(threadId, runId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list(threadId, runId, {}, query);\n        }\n        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexports.Steps = Steps;\nclass RunStepsPage extends pagination_1.CursorPage {\n}\nexports.RunStepsPage = RunStepsPage;\n(function (Steps) {\n    Steps.RunStepsPage = StepsAPI.RunStepsPage;\n})(Steps = exports.Steps || (exports.Steps = {}));\n//# sourceMappingURL=steps.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../../resource';\nimport { isRequestOptions } from '../../../../core';\nimport * as Core from '../../../../core';\nimport * as StepsAPI from './steps';\nimport { CursorPage, type CursorPageParams } from '../../../../pagination';\n\nexport class Steps extends APIResource {\n  /**\n   * Retrieves a run step.\n   */\n  retrieve(\n    threadId: string,\n    runId: string,\n    stepId: string,\n    query?: StepRetrieveParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<RunStep>;\n  retrieve(\n    threadId: string,\n    runId: string,\n    stepId: string,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<RunStep>;\n  retrieve(\n    threadId: string,\n    runId: string,\n    stepId: string,\n    query: StepRetrieveParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<RunStep> {\n    if (isRequestOptions(query)) {\n      return this.retrieve(threadId, runId, stepId, {}, query);\n    }\n    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of run steps belonging to a run.\n   */\n  list(\n    threadId: string,\n    runId: string,\n    query?: StepListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<RunStepsPage, RunStep>;\n  list(\n    threadId: string,\n    runId: string,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<RunStepsPage, RunStep>;\n  list(\n    threadId: string,\n    runId: string,\n    query: StepListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<RunStepsPage, RunStep> {\n    if (isRequestOptions(query)) {\n      return this.list(threadId, runId, {}, query);\n    }\n    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n}\n\nexport class RunStepsPage extends CursorPage<RunStep> {}\n\n/**\n * Text output from the Code Interpreter tool call as part of a run step.\n */\nexport interface CodeInterpreterLogs {\n  /**\n   * The index of the output in the outputs array.\n   */\n  index: number;\n\n  /**\n   * Always `logs`.\n   */\n  type: 'logs';\n\n  /**\n   * The text output from the Code Interpreter tool call.\n   */\n  logs?: string;\n}\n\nexport interface CodeInterpreterOutputImage {\n  /**\n   * The index of the output in the outputs array.\n   */\n  index: number;\n\n  /**\n   * Always `image`.\n   */\n  type: 'image';\n\n  image?: CodeInterpreterOutputImage.Image;\n}\n\nexport namespace CodeInterpreterOutputImage {\n  export interface Image {\n    /**\n     * The [file](https://platform.openai.com/docs/api-reference/files) ID of the\n     * image.\n     */\n    file_id?: string;\n  }\n}\n\n/**\n * Details of the Code Interpreter tool call the run step was involved in.\n */\nexport interface CodeInterpreterToolCall {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The Code Interpreter tool call definition.\n   */\n  code_interpreter: CodeInterpreterToolCall.CodeInterpreter;\n\n  /**\n   * The type of tool call. This is always going to be `code_interpreter` for this\n   * type of tool call.\n   */\n  type: 'code_interpreter';\n}\n\nexport namespace CodeInterpreterToolCall {\n  /**\n   * The Code Interpreter tool call definition.\n   */\n  export interface CodeInterpreter {\n    /**\n     * The input to the Code Interpreter tool call.\n     */\n    input: string;\n\n    /**\n     * The outputs from the Code Interpreter tool call. Code Interpreter can output one\n     * or more items, including text (`logs`) or images (`image`). Each of these are\n     * represented by a different object type.\n     */\n    outputs: Array<CodeInterpreter.Logs | CodeInterpreter.Image>;\n  }\n\n  export namespace CodeInterpreter {\n    /**\n     * Text output from the Code Interpreter tool call as part of a run step.\n     */\n    export interface Logs {\n      /**\n       * The text output from the Code Interpreter tool call.\n       */\n      logs: string;\n\n      /**\n       * Always `logs`.\n       */\n      type: 'logs';\n    }\n\n    export interface Image {\n      image: Image.Image;\n\n      /**\n       * Always `image`.\n       */\n      type: 'image';\n    }\n\n    export namespace Image {\n      export interface Image {\n        /**\n         * The [file](https://platform.openai.com/docs/api-reference/files) ID of the\n         * image.\n         */\n        file_id: string;\n      }\n    }\n  }\n}\n\n/**\n * Details of the Code Interpreter tool call the run step was involved in.\n */\nexport interface CodeInterpreterToolCallDelta {\n  /**\n   * The index of the tool call in the tool calls array.\n   */\n  index: number;\n\n  /**\n   * The type of tool call. This is always going to be `code_interpreter` for this\n   * type of tool call.\n   */\n  type: 'code_interpreter';\n\n  /**\n   * The ID of the tool call.\n   */\n  id?: string;\n\n  /**\n   * The Code Interpreter tool call definition.\n   */\n  code_interpreter?: CodeInterpreterToolCallDelta.CodeInterpreter;\n}\n\nexport namespace CodeInterpreterToolCallDelta {\n  /**\n   * The Code Interpreter tool call definition.\n   */\n  export interface CodeInterpreter {\n    /**\n     * The input to the Code Interpreter tool call.\n     */\n    input?: string;\n\n    /**\n     * The outputs from the Code Interpreter tool call. Code Interpreter can output one\n     * or more items, including text (`logs`) or images (`image`). Each of these are\n     * represented by a different object type.\n     */\n    outputs?: Array<StepsAPI.CodeInterpreterLogs | StepsAPI.CodeInterpreterOutputImage>;\n  }\n}\n\nexport interface FileSearchToolCall {\n  /**\n   * The ID of the tool call object.\n   */\n  id: string;\n\n  /**\n   * For now, this is always going to be an empty object.\n   */\n  file_search: FileSearchToolCall.FileSearch;\n\n  /**\n   * The type of tool call. This is always going to be `file_search` for this type of\n   * tool call.\n   */\n  type: 'file_search';\n}\n\nexport namespace FileSearchToolCall {\n  /**\n   * For now, this is always going to be an empty object.\n   */\n  export interface FileSearch {\n    /**\n     * The ranking options for the file search.\n     */\n    ranking_options?: FileSearch.RankingOptions;\n\n    /**\n     * The results of the file search.\n     */\n    results?: Array<FileSearch.Result>;\n  }\n\n  export namespace FileSearch {\n    /**\n     * The ranking options for the file search.\n     */\n    export interface RankingOptions {\n      /**\n       * The ranker used for the file search.\n       */\n      ranker: 'default_2024_08_21';\n\n      /**\n       * The score threshold for the file search. All values must be a floating point\n       * number between 0 and 1.\n       */\n      score_threshold: number;\n    }\n\n    /**\n     * A result instance of the file search.\n     */\n    export interface Result {\n      /**\n       * The ID of the file that result was found in.\n       */\n      file_id: string;\n\n      /**\n       * The name of the file that result was found in.\n       */\n      file_name: string;\n\n      /**\n       * The score of the result. All values must be a floating point number between 0\n       * and 1.\n       */\n      score: number;\n\n      /**\n       * The content of the result that was found. The content is only included if\n       * requested via the include query parameter.\n       */\n      content?: Array<Result.Content>;\n    }\n\n    export namespace Result {\n      export interface Content {\n        /**\n         * The text content of the file.\n         */\n        text?: string;\n\n        /**\n         * The type of the content.\n         */\n        type?: 'text';\n      }\n    }\n  }\n}\n\nexport interface FileSearchToolCallDelta {\n  /**\n   * For now, this is always going to be an empty object.\n   */\n  file_search: unknown;\n\n  /**\n   * The index of the tool call in the tool calls array.\n   */\n  index: number;\n\n  /**\n   * The type of tool call. This is always going to be `file_search` for this type of\n   * tool call.\n   */\n  type: 'file_search';\n\n  /**\n   * The ID of the tool call object.\n   */\n  id?: string;\n}\n\nexport interface FunctionToolCall {\n  /**\n   * The ID of the tool call object.\n   */\n  id: string;\n\n  /**\n   * The definition of the function that was called.\n   */\n  function: FunctionToolCall.Function;\n\n  /**\n   * The type of tool call. This is always going to be `function` for this type of\n   * tool call.\n   */\n  type: 'function';\n}\n\nexport namespace FunctionToolCall {\n  /**\n   * The definition of the function that was called.\n   */\n  export interface Function {\n    /**\n     * The arguments passed to the function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function.\n     */\n    name: string;\n\n    /**\n     * The output of the function. This will be `null` if the outputs have not been\n     * [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs)\n     * yet.\n     */\n    output: string | null;\n  }\n}\n\nexport interface FunctionToolCallDelta {\n  /**\n   * The index of the tool call in the tool calls array.\n   */\n  index: number;\n\n  /**\n   * The type of tool call. This is always going to be `function` for this type of\n   * tool call.\n   */\n  type: 'function';\n\n  /**\n   * The ID of the tool call object.\n   */\n  id?: string;\n\n  /**\n   * The definition of the function that was called.\n   */\n  function?: FunctionToolCallDelta.Function;\n}\n\nexport namespace FunctionToolCallDelta {\n  /**\n   * The definition of the function that was called.\n   */\n  export interface Function {\n    /**\n     * The arguments passed to the function.\n     */\n    arguments?: string;\n\n    /**\n     * The name of the function.\n     */\n    name?: string;\n\n    /**\n     * The output of the function. This will be `null` if the outputs have not been\n     * [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs)\n     * yet.\n     */\n    output?: string | null;\n  }\n}\n\n/**\n * Details of the message creation by the run step.\n */\nexport interface MessageCreationStepDetails {\n  message_creation: MessageCreationStepDetails.MessageCreation;\n\n  /**\n   * Always `message_creation`.\n   */\n  type: 'message_creation';\n}\n\nexport namespace MessageCreationStepDetails {\n  export interface MessageCreation {\n    /**\n     * The ID of the message that was created by this run step.\n     */\n    message_id: string;\n  }\n}\n\n/**\n * Represents a step in execution of a run.\n */\nexport interface RunStep {\n  /**\n   * The identifier of the run step, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The ID of the\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants)\n   * associated with the run step.\n   */\n  assistant_id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run step was cancelled.\n   */\n  cancelled_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run step completed.\n   */\n  completed_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run step was created.\n   */\n  created_at: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run step expired. A step is\n   * considered expired if the parent run is expired.\n   */\n  expired_at: number | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the run step failed.\n   */\n  failed_at: number | null;\n\n  /**\n   * The last error associated with this run step. Will be `null` if there are no\n   * errors.\n   */\n  last_error: RunStep.LastError | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * The object type, which is always `thread.run.step`.\n   */\n  object: 'thread.run.step';\n\n  /**\n   * The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that\n   * this run step is a part of.\n   */\n  run_id: string;\n\n  /**\n   * The status of the run step, which can be either `in_progress`, `cancelled`,\n   * `failed`, `completed`, or `expired`.\n   */\n  status: 'in_progress' | 'cancelled' | 'failed' | 'completed' | 'expired';\n\n  /**\n   * The details of the run step.\n   */\n  step_details: MessageCreationStepDetails | ToolCallsStepDetails;\n\n  /**\n   * The ID of the [thread](https://platform.openai.com/docs/api-reference/threads)\n   * that was run.\n   */\n  thread_id: string;\n\n  /**\n   * The type of run step, which can be either `message_creation` or `tool_calls`.\n   */\n  type: 'message_creation' | 'tool_calls';\n\n  /**\n   * Usage statistics related to the run step. This value will be `null` while the\n   * run step's status is `in_progress`.\n   */\n  usage: RunStep.Usage | null;\n}\n\nexport namespace RunStep {\n  /**\n   * The last error associated with this run step. Will be `null` if there are no\n   * errors.\n   */\n  export interface LastError {\n    /**\n     * One of `server_error` or `rate_limit_exceeded`.\n     */\n    code: 'server_error' | 'rate_limit_exceeded';\n\n    /**\n     * A human-readable description of the error.\n     */\n    message: string;\n  }\n\n  /**\n   * Usage statistics related to the run step. This value will be `null` while the\n   * run step's status is `in_progress`.\n   */\n  export interface Usage {\n    /**\n     * Number of completion tokens used over the course of the run step.\n     */\n    completion_tokens: number;\n\n    /**\n     * Number of prompt tokens used over the course of the run step.\n     */\n    prompt_tokens: number;\n\n    /**\n     * Total number of tokens used (prompt + completion).\n     */\n    total_tokens: number;\n  }\n}\n\n/**\n * The delta containing the fields that have changed on the run step.\n */\nexport interface RunStepDelta {\n  /**\n   * The details of the run step.\n   */\n  step_details?: RunStepDeltaMessageDelta | ToolCallDeltaObject;\n}\n\n/**\n * Represents a run step delta i.e. any changed fields on a run step during\n * streaming.\n */\nexport interface RunStepDeltaEvent {\n  /**\n   * The identifier of the run step, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The delta containing the fields that have changed on the run step.\n   */\n  delta: RunStepDelta;\n\n  /**\n   * The object type, which is always `thread.run.step.delta`.\n   */\n  object: 'thread.run.step.delta';\n}\n\n/**\n * Details of the message creation by the run step.\n */\nexport interface RunStepDeltaMessageDelta {\n  /**\n   * Always `message_creation`.\n   */\n  type: 'message_creation';\n\n  message_creation?: RunStepDeltaMessageDelta.MessageCreation;\n}\n\nexport namespace RunStepDeltaMessageDelta {\n  export interface MessageCreation {\n    /**\n     * The ID of the message that was created by this run step.\n     */\n    message_id?: string;\n  }\n}\n\nexport type RunStepInclude = 'step_details.tool_calls[*].file_search.results[*].content';\n\n/**\n * Details of the Code Interpreter tool call the run step was involved in.\n */\nexport type ToolCall = CodeInterpreterToolCall | FileSearchToolCall | FunctionToolCall;\n\n/**\n * Details of the Code Interpreter tool call the run step was involved in.\n */\nexport type ToolCallDelta = CodeInterpreterToolCallDelta | FileSearchToolCallDelta | FunctionToolCallDelta;\n\n/**\n * Details of the tool call.\n */\nexport interface ToolCallDeltaObject {\n  /**\n   * Always `tool_calls`.\n   */\n  type: 'tool_calls';\n\n  /**\n   * An array of tool calls the run step was involved in. These can be associated\n   * with one of three types of tools: `code_interpreter`, `file_search`, or\n   * `function`.\n   */\n  tool_calls?: Array<ToolCallDelta>;\n}\n\n/**\n * Details of the tool call.\n */\nexport interface ToolCallsStepDetails {\n  /**\n   * An array of tool calls the run step was involved in. These can be associated\n   * with one of three types of tools: `code_interpreter`, `file_search`, or\n   * `function`.\n   */\n  tool_calls: Array<ToolCall>;\n\n  /**\n   * Always `tool_calls`.\n   */\n  type: 'tool_calls';\n}\n\nexport interface StepRetrieveParams {\n  /**\n   * A list of additional fields to include in the response. Currently the only\n   * supported value is `step_details.tool_calls[*].file_search.results[*].content`\n   * to fetch the file search result content.\n   *\n   * See the\n   * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n   * for more information.\n   */\n  include?: Array<RunStepInclude>;\n}\n\nexport interface StepListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * A list of additional fields to include in the response. Currently the only\n   * supported value is `step_details.tool_calls[*].file_search.results[*].content`\n   * to fetch the file search result content.\n   *\n   * See the\n   * [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search/customizing-file-search-settings)\n   * for more information.\n   */\n  include?: Array<RunStepInclude>;\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport namespace Steps {\n  export import CodeInterpreterLogs = StepsAPI.CodeInterpreterLogs;\n  export import CodeInterpreterOutputImage = StepsAPI.CodeInterpreterOutputImage;\n  export import CodeInterpreterToolCall = StepsAPI.CodeInterpreterToolCall;\n  export import CodeInterpreterToolCallDelta = StepsAPI.CodeInterpreterToolCallDelta;\n  export import FileSearchToolCall = StepsAPI.FileSearchToolCall;\n  export import FileSearchToolCallDelta = StepsAPI.FileSearchToolCallDelta;\n  export import FunctionToolCall = StepsAPI.FunctionToolCall;\n  export import FunctionToolCallDelta = StepsAPI.FunctionToolCallDelta;\n  export import MessageCreationStepDetails = StepsAPI.MessageCreationStepDetails;\n  export import RunStep = StepsAPI.RunStep;\n  export import RunStepDelta = StepsAPI.RunStepDelta;\n  export import RunStepDeltaEvent = StepsAPI.RunStepDeltaEvent;\n  export import RunStepDeltaMessageDelta = StepsAPI.RunStepDeltaMessageDelta;\n  export import RunStepInclude = StepsAPI.RunStepInclude;\n  export import ToolCall = StepsAPI.ToolCall;\n  export import ToolCallDelta = StepsAPI.ToolCallDelta;\n  export import ToolCallDeltaObject = StepsAPI.ToolCallDeltaObject;\n  export import ToolCallsStepDetails = StepsAPI.ToolCallsStepDetails;\n  export import RunStepsPage = StepsAPI.RunStepsPage;\n  export import StepRetrieveParams = StepsAPI.StepRetrieveParams;\n  export import StepListParams = StepsAPI.StepListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorStoresPage = exports.VectorStores = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst VectorStoresAPI = __importStar(require(\"./vector-stores.js\"));\nconst FileBatchesAPI = __importStar(require(\"./file-batches.js\"));\nconst FilesAPI = __importStar(require(\"./files.js\"));\nconst pagination_1 = require(\"../../../pagination.js\");\nclass VectorStores extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.files = new FilesAPI.Files(this._client);\n        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);\n    }\n    /**\n     * Create a vector store.\n     */\n    create(body, options) {\n        return this._client.post('/vector_stores', {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store.\n     */\n    retrieve(vectorStoreId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Modifies a vector store.\n     */\n    update(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store.\n     */\n    del(vectorStoreId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n}\nexports.VectorStores = VectorStores;\nclass VectorStoresPage extends pagination_1.CursorPage {\n}\nexports.VectorStoresPage = VectorStoresPage;\n(function (VectorStores) {\n    VectorStores.VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n    VectorStores.Files = FilesAPI.Files;\n    VectorStores.VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n    VectorStores.FileBatches = FileBatchesAPI.FileBatches;\n})(VectorStores = exports.VectorStores || (exports.VectorStores = {}));\n//# sourceMappingURL=vector-stores.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport * as Core from '../../../core';\nimport * as VectorStoresAPI from './vector-stores';\nimport * as FileBatchesAPI from './file-batches';\nimport * as FilesAPI from './files';\nimport { CursorPage, type CursorPageParams } from '../../../pagination';\n\nexport class VectorStores extends APIResource {\n  files: FilesAPI.Files = new FilesAPI.Files(this._client);\n  fileBatches: FileBatchesAPI.FileBatches = new FileBatchesAPI.FileBatches(this._client);\n\n  /**\n   * Create a vector store.\n   */\n  create(body: VectorStoreCreateParams, options?: Core.RequestOptions): Core.APIPromise<VectorStore> {\n    return this._client.post('/vector_stores', {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieves a vector store.\n   */\n  retrieve(vectorStoreId: string, options?: Core.RequestOptions): Core.APIPromise<VectorStore> {\n    return this._client.get(`/vector_stores/${vectorStoreId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Modifies a vector store.\n   */\n  update(\n    vectorStoreId: string,\n    body: VectorStoreUpdateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStore> {\n    return this._client.post(`/vector_stores/${vectorStoreId}`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of vector stores.\n   */\n  list(\n    query?: VectorStoreListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoresPage, VectorStore>;\n  list(options?: Core.RequestOptions): Core.PagePromise<VectorStoresPage, VectorStore>;\n  list(\n    query: VectorStoreListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoresPage, VectorStore> {\n    if (isRequestOptions(query)) {\n      return this.list({}, query);\n    }\n    return this._client.getAPIList('/vector_stores', VectorStoresPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Delete a vector store.\n   */\n  del(vectorStoreId: string, options?: Core.RequestOptions): Core.APIPromise<VectorStoreDeleted> {\n    return this._client.delete(`/vector_stores/${vectorStoreId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n}\n\nexport class VectorStoresPage extends CursorPage<VectorStore> {}\n\n/**\n * The default strategy. This strategy currently uses a `max_chunk_size_tokens` of\n * `800` and `chunk_overlap_tokens` of `400`.\n */\nexport interface AutoFileChunkingStrategyParam {\n  /**\n   * Always `auto`.\n   */\n  type: 'auto';\n}\n\n/**\n * The strategy used to chunk the file.\n */\nexport type FileChunkingStrategy = StaticFileChunkingStrategyObject | OtherFileChunkingStrategyObject;\n\n/**\n * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n * strategy. Only applicable if `file_ids` is non-empty.\n */\nexport type FileChunkingStrategyParam = AutoFileChunkingStrategyParam | StaticFileChunkingStrategyParam;\n\n/**\n * This is returned when the chunking strategy is unknown. Typically, this is\n * because the file was indexed before the `chunking_strategy` concept was\n * introduced in the API.\n */\nexport interface OtherFileChunkingStrategyObject {\n  /**\n   * Always `other`.\n   */\n  type: 'other';\n}\n\nexport interface StaticFileChunkingStrategy {\n  /**\n   * The number of tokens that overlap between chunks. The default value is `400`.\n   *\n   * Note that the overlap must not exceed half of `max_chunk_size_tokens`.\n   */\n  chunk_overlap_tokens: number;\n\n  /**\n   * The maximum number of tokens in each chunk. The default value is `800`. The\n   * minimum value is `100` and the maximum value is `4096`.\n   */\n  max_chunk_size_tokens: number;\n}\n\nexport interface StaticFileChunkingStrategyObject {\n  static: StaticFileChunkingStrategy;\n\n  /**\n   * Always `static`.\n   */\n  type: 'static';\n}\n\nexport interface StaticFileChunkingStrategyParam {\n  static: StaticFileChunkingStrategy;\n\n  /**\n   * Always `static`.\n   */\n  type: 'static';\n}\n\n/**\n * A vector store is a collection of processed files can be used by the\n * `file_search` tool.\n */\nexport interface VectorStore {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the vector store was created.\n   */\n  created_at: number;\n\n  file_counts: VectorStore.FileCounts;\n\n  /**\n   * The Unix timestamp (in seconds) for when the vector store was last active.\n   */\n  last_active_at: number | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata: unknown | null;\n\n  /**\n   * The name of the vector store.\n   */\n  name: string;\n\n  /**\n   * The object type, which is always `vector_store`.\n   */\n  object: 'vector_store';\n\n  /**\n   * The status of the vector store, which can be either `expired`, `in_progress`, or\n   * `completed`. A status of `completed` indicates that the vector store is ready\n   * for use.\n   */\n  status: 'expired' | 'in_progress' | 'completed';\n\n  /**\n   * The total number of bytes used by the files in the vector store.\n   */\n  usage_bytes: number;\n\n  /**\n   * The expiration policy for a vector store.\n   */\n  expires_after?: VectorStore.ExpiresAfter;\n\n  /**\n   * The Unix timestamp (in seconds) for when the vector store will expire.\n   */\n  expires_at?: number | null;\n}\n\nexport namespace VectorStore {\n  export interface FileCounts {\n    /**\n     * The number of files that were cancelled.\n     */\n    cancelled: number;\n\n    /**\n     * The number of files that have been successfully processed.\n     */\n    completed: number;\n\n    /**\n     * The number of files that have failed to process.\n     */\n    failed: number;\n\n    /**\n     * The number of files that are currently being processed.\n     */\n    in_progress: number;\n\n    /**\n     * The total number of files.\n     */\n    total: number;\n  }\n\n  /**\n   * The expiration policy for a vector store.\n   */\n  export interface ExpiresAfter {\n    /**\n     * Anchor timestamp after which the expiration policy applies. Supported anchors:\n     * `last_active_at`.\n     */\n    anchor: 'last_active_at';\n\n    /**\n     * The number of days after the anchor time that the vector store will expire.\n     */\n    days: number;\n  }\n}\n\nexport interface VectorStoreDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'vector_store.deleted';\n}\n\nexport interface VectorStoreCreateParams {\n  /**\n   * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n   * strategy. Only applicable if `file_ids` is non-empty.\n   */\n  chunking_strategy?: FileChunkingStrategyParam;\n\n  /**\n   * The expiration policy for a vector store.\n   */\n  expires_after?: VectorStoreCreateParams.ExpiresAfter;\n\n  /**\n   * A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that\n   * the vector store should use. Useful for tools like `file_search` that can access\n   * files.\n   */\n  file_ids?: Array<string>;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The name of the vector store.\n   */\n  name?: string;\n}\n\nexport namespace VectorStoreCreateParams {\n  /**\n   * The expiration policy for a vector store.\n   */\n  export interface ExpiresAfter {\n    /**\n     * Anchor timestamp after which the expiration policy applies. Supported anchors:\n     * `last_active_at`.\n     */\n    anchor: 'last_active_at';\n\n    /**\n     * The number of days after the anchor time that the vector store will expire.\n     */\n    days: number;\n  }\n}\n\nexport interface VectorStoreUpdateParams {\n  /**\n   * The expiration policy for a vector store.\n   */\n  expires_after?: VectorStoreUpdateParams.ExpiresAfter | null;\n\n  /**\n   * Set of 16 key-value pairs that can be attached to an object. This can be useful\n   * for storing additional information about the object in a structured format. Keys\n   * can be a maximum of 64 characters long and values can be a maxium of 512\n   * characters long.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The name of the vector store.\n   */\n  name?: string | null;\n}\n\nexport namespace VectorStoreUpdateParams {\n  /**\n   * The expiration policy for a vector store.\n   */\n  export interface ExpiresAfter {\n    /**\n     * Anchor timestamp after which the expiration policy applies. Supported anchors:\n     * `last_active_at`.\n     */\n    anchor: 'last_active_at';\n\n    /**\n     * The number of days after the anchor time that the vector store will expire.\n     */\n    days: number;\n  }\n}\n\nexport interface VectorStoreListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport namespace VectorStores {\n  export import AutoFileChunkingStrategyParam = VectorStoresAPI.AutoFileChunkingStrategyParam;\n  export import FileChunkingStrategy = VectorStoresAPI.FileChunkingStrategy;\n  export import FileChunkingStrategyParam = VectorStoresAPI.FileChunkingStrategyParam;\n  export import OtherFileChunkingStrategyObject = VectorStoresAPI.OtherFileChunkingStrategyObject;\n  export import StaticFileChunkingStrategy = VectorStoresAPI.StaticFileChunkingStrategy;\n  export import StaticFileChunkingStrategyObject = VectorStoresAPI.StaticFileChunkingStrategyObject;\n  export import StaticFileChunkingStrategyParam = VectorStoresAPI.StaticFileChunkingStrategyParam;\n  export import VectorStore = VectorStoresAPI.VectorStore;\n  export import VectorStoreDeleted = VectorStoresAPI.VectorStoreDeleted;\n  export import VectorStoresPage = VectorStoresAPI.VectorStoresPage;\n  export import VectorStoreCreateParams = VectorStoresAPI.VectorStoreCreateParams;\n  export import VectorStoreUpdateParams = VectorStoresAPI.VectorStoreUpdateParams;\n  export import VectorStoreListParams = VectorStoresAPI.VectorStoreListParams;\n  export import Files = FilesAPI.Files;\n  export import VectorStoreFile = FilesAPI.VectorStoreFile;\n  export import VectorStoreFileDeleted = FilesAPI.VectorStoreFileDeleted;\n  export import VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n  export import FileCreateParams = FilesAPI.FileCreateParams;\n  export import FileListParams = FilesAPI.FileListParams;\n  export import FileBatches = FileBatchesAPI.FileBatches;\n  export import VectorStoreFileBatch = FileBatchesAPI.VectorStoreFileBatch;\n  export import FileBatchCreateParams = FileBatchesAPI.FileBatchCreateParams;\n  export import FileBatchListFilesParams = FileBatchesAPI.FileBatchListFilesParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorStoreFilesPage = exports.FileBatches = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst core_2 = require(\"../../../core.js\");\nconst Util_1 = require(\"../../../lib/Util.js\");\nconst files_1 = require(\"./files.js\");\nObject.defineProperty(exports, \"VectorStoreFilesPage\", { enumerable: true, get: function () { return files_1.VectorStoreFilesPage; } });\nclass FileBatches extends resource_1.APIResource {\n    /**\n     * Create a vector store file batch.\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file batch.\n     */\n    retrieve(vectorStoreId, batchId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Cancel a vector store file batch. This attempts to cancel the processing of\n     * files in this batch as soon as possible.\n     */\n    cancel(vectorStoreId, batchId, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Create a vector store batch and poll until all files have been processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const batch = await this.create(vectorStoreId, body);\n        return await this.poll(vectorStoreId, batch.id, options);\n    }\n    listFiles(vectorStoreId, batchId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.listFiles(vectorStoreId, batchId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, files_1.VectorStoreFilesPage, { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } });\n    }\n    /**\n     * Wait for the given file batch to be processed.\n     *\n     * Note: this will return even if one of the files failed to process, you need to\n     * check batch.file_counts.failed_count to handle this case.\n     */\n    async poll(vectorStoreId, batchId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n                ...options,\n                headers,\n            }).withResponse();\n            switch (batch.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await (0, core_2.sleep)(sleepInterval);\n                    break;\n                case 'failed':\n                case 'cancelled':\n                case 'completed':\n                    return batch;\n            }\n        }\n    }\n    /**\n     * Uploads the given files concurrently and then creates a vector store file batch.\n     *\n     * The concurrency limit is configurable using the `maxConcurrency` parameter.\n     */\n    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {\n        if (files == null || files.length == 0) {\n            throw new Error(`No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`);\n        }\n        const configuredConcurrency = options?.maxConcurrency ?? 5;\n        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n        const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n        const client = this._client;\n        const fileIterator = files.values();\n        const allFileIds = [...fileIds];\n        // This code is based on this design. The libraries don't accommodate our environment limits.\n        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n        async function processFiles(iterator) {\n            for (let item of iterator) {\n                const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n                allFileIds.push(fileObj.id);\n            }\n        }\n        // Start workers to process results\n        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n        // Wait for all processing to complete.\n        await (0, Util_1.allSettledWithThrow)(workers);\n        return await this.createAndPoll(vectorStoreId, {\n            file_ids: allFileIds,\n        });\n    }\n}\nexports.FileBatches = FileBatches;\n(function (FileBatches) {\n})(FileBatches = exports.FileBatches || (exports.FileBatches = {}));\n//# sourceMappingURL=file-batches.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport { sleep } from '../../../core';\nimport { Uploadable } from '../../../core';\nimport { allSettledWithThrow } from '../../../lib/Util';\nimport * as Core from '../../../core';\nimport * as FileBatchesAPI from './file-batches';\nimport * as FilesAPI from './files';\nimport { VectorStoreFilesPage } from './files';\nimport * as VectorStoresAPI from './vector-stores';\nimport { type CursorPageParams } from '../../../pagination';\n\nexport class FileBatches extends APIResource {\n  /**\n   * Create a vector store file batch.\n   */\n  create(\n    vectorStoreId: string,\n    body: FileBatchCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFileBatch> {\n    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieves a vector store file batch.\n   */\n  retrieve(\n    vectorStoreId: string,\n    batchId: string,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFileBatch> {\n    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Cancel a vector store file batch. This attempts to cancel the processing of\n   * files in this batch as soon as possible.\n   */\n  cancel(\n    vectorStoreId: string,\n    batchId: string,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFileBatch> {\n    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Create a vector store batch and poll until all files have been processed.\n   */\n  async createAndPoll(\n    vectorStoreId: string,\n    body: FileBatchCreateParams,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<VectorStoreFileBatch> {\n    const batch = await this.create(vectorStoreId, body);\n    return await this.poll(vectorStoreId, batch.id, options);\n  }\n\n  /**\n   * Returns a list of vector store files in a batch.\n   */\n  listFiles(\n    vectorStoreId: string,\n    batchId: string,\n    query?: FileBatchListFilesParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, FilesAPI.VectorStoreFile>;\n  listFiles(\n    vectorStoreId: string,\n    batchId: string,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, FilesAPI.VectorStoreFile>;\n  listFiles(\n    vectorStoreId: string,\n    batchId: string,\n    query: FileBatchListFilesParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, FilesAPI.VectorStoreFile> {\n    if (isRequestOptions(query)) {\n      return this.listFiles(vectorStoreId, batchId, {}, query);\n    }\n    return this._client.getAPIList(\n      `/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`,\n      VectorStoreFilesPage,\n      { query, ...options, headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers } },\n    );\n  }\n\n  /**\n   * Wait for the given file batch to be processed.\n   *\n   * Note: this will return even if one of the files failed to process, you need to\n   * check batch.file_counts.failed_count to handle this case.\n   */\n  async poll(\n    vectorStoreId: string,\n    batchId: string,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<VectorStoreFileBatch> {\n    const headers: { [key: string]: string } = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n    if (options?.pollIntervalMs) {\n      headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n    }\n\n    while (true) {\n      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {\n        ...options,\n        headers,\n      }).withResponse();\n\n      switch (batch.status) {\n        case 'in_progress':\n          let sleepInterval = 5000;\n\n          if (options?.pollIntervalMs) {\n            sleepInterval = options.pollIntervalMs;\n          } else {\n            const headerInterval = response.headers.get('openai-poll-after-ms');\n            if (headerInterval) {\n              const headerIntervalMs = parseInt(headerInterval);\n              if (!isNaN(headerIntervalMs)) {\n                sleepInterval = headerIntervalMs;\n              }\n            }\n          }\n          await sleep(sleepInterval);\n          break;\n        case 'failed':\n        case 'cancelled':\n        case 'completed':\n          return batch;\n      }\n    }\n  }\n\n  /**\n   * Uploads the given files concurrently and then creates a vector store file batch.\n   *\n   * The concurrency limit is configurable using the `maxConcurrency` parameter.\n   */\n  async uploadAndPoll(\n    vectorStoreId: string,\n    { files, fileIds = [] }: { files: Uploadable[]; fileIds?: string[] },\n    options?: Core.RequestOptions & { pollIntervalMs?: number; maxConcurrency?: number },\n  ): Promise<VectorStoreFileBatch> {\n    if (files == null || files.length == 0) {\n      throw new Error(\n        `No \\`files\\` provided to process. If you've already uploaded files you should use \\`.createAndPoll()\\` instead`,\n      );\n    }\n\n    const configuredConcurrency = options?.maxConcurrency ?? 5;\n\n    // We cap the number of workers at the number of files (so we don't start any unnecessary workers)\n    const concurrencyLimit = Math.min(configuredConcurrency, files.length);\n\n    const client = this._client;\n    const fileIterator = files.values();\n    const allFileIds: string[] = [...fileIds];\n\n    // This code is based on this design. The libraries don't accommodate our environment limits.\n    // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all\n    async function processFiles(iterator: IterableIterator<Uploadable>) {\n      for (let item of iterator) {\n        const fileObj = await client.files.create({ file: item, purpose: 'assistants' }, options);\n        allFileIds.push(fileObj.id);\n      }\n    }\n\n    // Start workers to process results\n    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);\n\n    // Wait for all processing to complete.\n    await allSettledWithThrow(workers);\n\n    return await this.createAndPoll(vectorStoreId, {\n      file_ids: allFileIds,\n    });\n  }\n}\n\n/**\n * A batch of files attached to a vector store.\n */\nexport interface VectorStoreFileBatch {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the vector store files batch was\n   * created.\n   */\n  created_at: number;\n\n  file_counts: VectorStoreFileBatch.FileCounts;\n\n  /**\n   * The object type, which is always `vector_store.file_batch`.\n   */\n  object: 'vector_store.files_batch';\n\n  /**\n   * The status of the vector store files batch, which can be either `in_progress`,\n   * `completed`, `cancelled` or `failed`.\n   */\n  status: 'in_progress' | 'completed' | 'cancelled' | 'failed';\n\n  /**\n   * The ID of the\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n   * that the [File](https://platform.openai.com/docs/api-reference/files) is\n   * attached to.\n   */\n  vector_store_id: string;\n}\n\nexport namespace VectorStoreFileBatch {\n  export interface FileCounts {\n    /**\n     * The number of files that where cancelled.\n     */\n    cancelled: number;\n\n    /**\n     * The number of files that have been processed.\n     */\n    completed: number;\n\n    /**\n     * The number of files that have failed to process.\n     */\n    failed: number;\n\n    /**\n     * The number of files that are currently being processed.\n     */\n    in_progress: number;\n\n    /**\n     * The total number of files.\n     */\n    total: number;\n  }\n}\n\nexport interface FileBatchCreateParams {\n  /**\n   * A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that\n   * the vector store should use. Useful for tools like `file_search` that can access\n   * files.\n   */\n  file_ids: Array<string>;\n\n  /**\n   * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n   * strategy. Only applicable if `file_ids` is non-empty.\n   */\n  chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\n}\n\nexport interface FileBatchListFilesParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.\n   */\n  filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled';\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport namespace FileBatches {\n  export import VectorStoreFileBatch = FileBatchesAPI.VectorStoreFileBatch;\n  export import FileBatchCreateParams = FileBatchesAPI.FileBatchCreateParams;\n  export import FileBatchListFilesParams = FileBatchesAPI.FileBatchListFilesParams;\n}\n\nexport { VectorStoreFilesPage };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allSettledWithThrow = void 0;\n/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */\nconst allSettledWithThrow = async (promises) => {\n    const results = await Promise.allSettled(promises);\n    const rejected = results.filter((result) => result.status === 'rejected');\n    if (rejected.length) {\n        for (const result of rejected) {\n            console.error(result.reason);\n        }\n        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n    }\n    // Note: TS was complaining about using `.filter().map()` here for some reason\n    const values = [];\n    for (const result of results) {\n        if (result.status === 'fulfilled') {\n            values.push(result.value);\n        }\n    }\n    return values;\n};\nexports.allSettledWithThrow = allSettledWithThrow;\n//# sourceMappingURL=Util.js.map","/**\n * Like `Promise.allSettled()` but throws an error if any promises are rejected.\n */\nexport const allSettledWithThrow = async <R>(promises: Promise<R>[]): Promise<R[]> => {\n  const results = await Promise.allSettled(promises);\n  const rejected = results.filter((result): result is PromiseRejectedResult => result.status === 'rejected');\n  if (rejected.length) {\n    for (const result of rejected) {\n      console.error(result.reason);\n    }\n\n    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);\n  }\n\n  // Note: TS was complaining about using `.filter().map()` here for some reason\n  const values: R[] = [];\n  for (const result of results) {\n    if (result.status === 'fulfilled') {\n      values.push(result.value);\n    }\n  }\n  return values;\n};\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorStoreFilesPage = exports.Files = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst FilesAPI = __importStar(require(\"./files.js\"));\nconst pagination_1 = require(\"../../../pagination.js\");\nclass Files extends resource_1.APIResource {\n    /**\n     * Create a vector store file by attaching a\n     * [File](https://platform.openai.com/docs/api-reference/files) to a\n     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n     */\n    create(vectorStoreId, body, options) {\n        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n            body,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Retrieves a vector store file.\n     */\n    retrieve(vectorStoreId, fileId, options) {\n        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    list(vectorStoreId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list(vectorStoreId, {}, query);\n        }\n        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n            query,\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Delete a vector store file. This will remove the file from the vector store but\n     * the file itself will not be deleted. To delete the file, use the\n     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n     * endpoint.\n     */\n    del(vectorStoreId, fileId, options) {\n        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n            ...options,\n            headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n        });\n    }\n    /**\n     * Attach a file to the given vector store and wait for it to be processed.\n     */\n    async createAndPoll(vectorStoreId, body, options) {\n        const file = await this.create(vectorStoreId, body, options);\n        return await this.poll(vectorStoreId, file.id, options);\n    }\n    /**\n     * Wait for the vector store file to finish processing.\n     *\n     * Note: this will return even if the file failed to process, you need to check\n     * file.last_error and file.status to handle these cases\n     */\n    async poll(vectorStoreId, fileId, options) {\n        const headers = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n        if (options?.pollIntervalMs) {\n            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n        }\n        while (true) {\n            const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n                ...options,\n                headers,\n            }).withResponse();\n            const file = fileResponse.data;\n            switch (file.status) {\n                case 'in_progress':\n                    let sleepInterval = 5000;\n                    if (options?.pollIntervalMs) {\n                        sleepInterval = options.pollIntervalMs;\n                    }\n                    else {\n                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n                        if (headerInterval) {\n                            const headerIntervalMs = parseInt(headerInterval);\n                            if (!isNaN(headerIntervalMs)) {\n                                sleepInterval = headerIntervalMs;\n                            }\n                        }\n                    }\n                    await (0, core_1.sleep)(sleepInterval);\n                    break;\n                case 'failed':\n                case 'completed':\n                    return file;\n            }\n        }\n    }\n    /**\n     * Upload a file to the `files` API and then attach it to the given vector store.\n     *\n     * Note the file will be asynchronously processed (you can use the alternative\n     * polling helper method to wait for processing to complete).\n     */\n    async upload(vectorStoreId, file, options) {\n        const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n    }\n    /**\n     * Add a file to a vector store and poll until processing is complete.\n     */\n    async uploadAndPoll(vectorStoreId, file, options) {\n        const fileInfo = await this.upload(vectorStoreId, file, options);\n        return await this.poll(vectorStoreId, fileInfo.id, options);\n    }\n}\nexports.Files = Files;\nclass VectorStoreFilesPage extends pagination_1.CursorPage {\n}\nexports.VectorStoreFilesPage = VectorStoreFilesPage;\n(function (Files) {\n    Files.VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n})(Files = exports.Files || (exports.Files = {}));\n//# sourceMappingURL=files.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { sleep, Uploadable, isRequestOptions } from '../../../core';\nimport * as Core from '../../../core';\nimport * as FilesAPI from './files';\nimport * as VectorStoresAPI from './vector-stores';\nimport { CursorPage, type CursorPageParams } from '../../../pagination';\n\nexport class Files extends APIResource {\n  /**\n   * Create a vector store file by attaching a\n   * [File](https://platform.openai.com/docs/api-reference/files) to a\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).\n   */\n  create(\n    vectorStoreId: string,\n    body: FileCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFile> {\n    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {\n      body,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Retrieves a vector store file.\n   */\n  retrieve(\n    vectorStoreId: string,\n    fileId: string,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFile> {\n    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Returns a list of vector store files.\n   */\n  list(\n    vectorStoreId: string,\n    query?: FileListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, VectorStoreFile>;\n  list(\n    vectorStoreId: string,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, VectorStoreFile>;\n  list(\n    vectorStoreId: string,\n    query: FileListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<VectorStoreFilesPage, VectorStoreFile> {\n    if (isRequestOptions(query)) {\n      return this.list(vectorStoreId, {}, query);\n    }\n    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {\n      query,\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Delete a vector store file. This will remove the file from the vector store but\n   * the file itself will not be deleted. To delete the file, use the\n   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)\n   * endpoint.\n   */\n  del(\n    vectorStoreId: string,\n    fileId: string,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<VectorStoreFileDeleted> {\n    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {\n      ...options,\n      headers: { 'OpenAI-Beta': 'assistants=v2', ...options?.headers },\n    });\n  }\n\n  /**\n   * Attach a file to the given vector store and wait for it to be processed.\n   */\n  async createAndPoll(\n    vectorStoreId: string,\n    body: FileCreateParams,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<VectorStoreFile> {\n    const file = await this.create(vectorStoreId, body, options);\n    return await this.poll(vectorStoreId, file.id, options);\n  }\n\n  /**\n   * Wait for the vector store file to finish processing.\n   *\n   * Note: this will return even if the file failed to process, you need to check\n   * file.last_error and file.status to handle these cases\n   */\n  async poll(\n    vectorStoreId: string,\n    fileId: string,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<VectorStoreFile> {\n    const headers: { [key: string]: string } = { ...options?.headers, 'X-Stainless-Poll-Helper': 'true' };\n    if (options?.pollIntervalMs) {\n      headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();\n    }\n    while (true) {\n      const fileResponse = await this.retrieve(vectorStoreId, fileId, {\n        ...options,\n        headers,\n      }).withResponse();\n\n      const file = fileResponse.data;\n\n      switch (file.status) {\n        case 'in_progress':\n          let sleepInterval = 5000;\n\n          if (options?.pollIntervalMs) {\n            sleepInterval = options.pollIntervalMs;\n          } else {\n            const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');\n            if (headerInterval) {\n              const headerIntervalMs = parseInt(headerInterval);\n              if (!isNaN(headerIntervalMs)) {\n                sleepInterval = headerIntervalMs;\n              }\n            }\n          }\n          await sleep(sleepInterval);\n          break;\n        case 'failed':\n        case 'completed':\n          return file;\n      }\n    }\n  }\n\n  /**\n   * Upload a file to the `files` API and then attach it to the given vector store.\n   *\n   * Note the file will be asynchronously processed (you can use the alternative\n   * polling helper method to wait for processing to complete).\n   */\n  async upload(\n    vectorStoreId: string,\n    file: Uploadable,\n    options?: Core.RequestOptions,\n  ): Promise<VectorStoreFile> {\n    const fileInfo = await this._client.files.create({ file: file, purpose: 'assistants' }, options);\n    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);\n  }\n\n  /**\n   * Add a file to a vector store and poll until processing is complete.\n   */\n  async uploadAndPoll(\n    vectorStoreId: string,\n    file: Uploadable,\n    options?: Core.RequestOptions & { pollIntervalMs?: number },\n  ): Promise<VectorStoreFile> {\n    const fileInfo = await this.upload(vectorStoreId, file, options);\n    return await this.poll(vectorStoreId, fileInfo.id, options);\n  }\n}\n\nexport class VectorStoreFilesPage extends CursorPage<VectorStoreFile> {}\n\n/**\n * A list of files attached to a vector store.\n */\nexport interface VectorStoreFile {\n  /**\n   * The identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the vector store file was created.\n   */\n  created_at: number;\n\n  /**\n   * The last error associated with this vector store file. Will be `null` if there\n   * are no errors.\n   */\n  last_error: VectorStoreFile.LastError | null;\n\n  /**\n   * The object type, which is always `vector_store.file`.\n   */\n  object: 'vector_store.file';\n\n  /**\n   * The status of the vector store file, which can be either `in_progress`,\n   * `completed`, `cancelled`, or `failed`. The status `completed` indicates that the\n   * vector store file is ready for use.\n   */\n  status: 'in_progress' | 'completed' | 'cancelled' | 'failed';\n\n  /**\n   * The total vector store usage in bytes. Note that this may be different from the\n   * original file size.\n   */\n  usage_bytes: number;\n\n  /**\n   * The ID of the\n   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object)\n   * that the [File](https://platform.openai.com/docs/api-reference/files) is\n   * attached to.\n   */\n  vector_store_id: string;\n\n  /**\n   * The strategy used to chunk the file.\n   */\n  chunking_strategy?: VectorStoresAPI.FileChunkingStrategy;\n}\n\nexport namespace VectorStoreFile {\n  /**\n   * The last error associated with this vector store file. Will be `null` if there\n   * are no errors.\n   */\n  export interface LastError {\n    /**\n     * One of `server_error` or `rate_limit_exceeded`.\n     */\n    code: 'server_error' | 'unsupported_file' | 'invalid_file';\n\n    /**\n     * A human-readable description of the error.\n     */\n    message: string;\n  }\n}\n\nexport interface VectorStoreFileDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'vector_store.file.deleted';\n}\n\nexport interface FileCreateParams {\n  /**\n   * A [File](https://platform.openai.com/docs/api-reference/files) ID that the\n   * vector store should use. Useful for tools like `file_search` that can access\n   * files.\n   */\n  file_id: string;\n\n  /**\n   * The chunking strategy used to chunk the file(s). If not set, will use the `auto`\n   * strategy. Only applicable if `file_ids` is non-empty.\n   */\n  chunking_strategy?: VectorStoresAPI.FileChunkingStrategyParam;\n}\n\nexport interface FileListParams extends CursorPageParams {\n  /**\n   * A cursor for use in pagination. `before` is an object ID that defines your place\n   * in the list. For instance, if you make a list request and receive 100 objects,\n   * ending with obj_foo, your subsequent call can include before=obj_foo in order to\n   * fetch the previous page of the list.\n   */\n  before?: string;\n\n  /**\n   * Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.\n   */\n  filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled';\n\n  /**\n   * Sort order by the `created_at` timestamp of the objects. `asc` for ascending\n   * order and `desc` for descending order.\n   */\n  order?: 'asc' | 'desc';\n}\n\nexport namespace Files {\n  export import VectorStoreFile = FilesAPI.VectorStoreFile;\n  export import VectorStoreFileDeleted = FilesAPI.VectorStoreFileDeleted;\n  export import VectorStoreFilesPage = FilesAPI.VectorStoreFilesPage;\n  export import FileCreateParams = FilesAPI.FileCreateParams;\n  export import FileListParams = FilesAPI.FileListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Completions = void 0;\nconst resource_1 = require(\"../resource.js\");\nclass Completions extends resource_1.APIResource {\n    create(body, options) {\n        return this._client.post('/completions', { body, ...options, stream: body.stream ?? false });\n    }\n}\nexports.Completions = Completions;\n(function (Completions) {\n})(Completions = exports.Completions || (exports.Completions = {}));\n//# sourceMappingURL=completions.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport { APIPromise } from '../core';\nimport * as Core from '../core';\nimport * as CompletionsAPI from './completions';\nimport * as ChatCompletionsAPI from './chat/completions';\nimport { Stream } from '../streaming';\n\nexport class Completions extends APIResource {\n  /**\n   * Creates a completion for the provided prompt and parameters.\n   */\n  create(body: CompletionCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<Completion>;\n  create(\n    body: CompletionCreateParamsStreaming,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<Completion>>;\n  create(\n    body: CompletionCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): APIPromise<Stream<Completion> | Completion>;\n  create(\n    body: CompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): APIPromise<Completion> | APIPromise<Stream<Completion>> {\n    return this._client.post('/completions', { body, ...options, stream: body.stream ?? false }) as\n      | APIPromise<Completion>\n      | APIPromise<Stream<Completion>>;\n  }\n}\n\n/**\n * Represents a completion response from the API. Note: both the streamed and\n * non-streamed response objects share the same shape (unlike the chat endpoint).\n */\nexport interface Completion {\n  /**\n   * A unique identifier for the completion.\n   */\n  id: string;\n\n  /**\n   * The list of completion choices the model generated for the input prompt.\n   */\n  choices: Array<CompletionChoice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the completion was created.\n   */\n  created: number;\n\n  /**\n   * The model used for completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"text_completion\"\n   */\n  object: 'text_completion';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n\n  /**\n   * Usage statistics for the completion request.\n   */\n  usage?: CompletionUsage;\n}\n\nexport interface CompletionChoice {\n  /**\n   * The reason the model stopped generating tokens. This will be `stop` if the model\n   * hit a natural stop point or a provided stop sequence, `length` if the maximum\n   * number of tokens specified in the request was reached, or `content_filter` if\n   * content was omitted due to a flag from our content filters.\n   */\n  finish_reason: 'stop' | 'length' | 'content_filter';\n\n  index: number;\n\n  logprobs: CompletionChoice.Logprobs | null;\n\n  text: string;\n}\n\nexport namespace CompletionChoice {\n  export interface Logprobs {\n    text_offset?: Array<number>;\n\n    token_logprobs?: Array<number>;\n\n    tokens?: Array<string>;\n\n    top_logprobs?: Array<Record<string, number>>;\n  }\n}\n\n/**\n * Usage statistics for the completion request.\n */\nexport interface CompletionUsage {\n  /**\n   * Number of tokens in the generated completion.\n   */\n  completion_tokens: number;\n\n  /**\n   * Number of tokens in the prompt.\n   */\n  prompt_tokens: number;\n\n  /**\n   * Total number of tokens used in the request (prompt + completion).\n   */\n  total_tokens: number;\n\n  /**\n   * Breakdown of tokens used in a completion.\n   */\n  completion_tokens_details?: CompletionUsage.CompletionTokensDetails;\n}\n\nexport namespace CompletionUsage {\n  /**\n   * Breakdown of tokens used in a completion.\n   */\n  export interface CompletionTokensDetails {\n    /**\n     * Tokens generated by the model for reasoning.\n     */\n    reasoning_tokens?: number;\n  }\n}\n\nexport type CompletionCreateParams = CompletionCreateParamsNonStreaming | CompletionCreateParamsStreaming;\n\nexport interface CompletionCreateParamsBase {\n  /**\n   * ID of the model to use. You can use the\n   * [List models](https://platform.openai.com/docs/api-reference/models/list) API to\n   * see all of your available models, or see our\n   * [Model overview](https://platform.openai.com/docs/models/overview) for\n   * descriptions of them.\n   */\n  model: (string & {}) | 'gpt-3.5-turbo-instruct' | 'davinci-002' | 'babbage-002';\n\n  /**\n   * The prompt(s) to generate completions for, encoded as a string, array of\n   * strings, array of tokens, or array of token arrays.\n   *\n   * Note that <|endoftext|> is the document separator that the model sees during\n   * training, so if a prompt is not specified the model will generate as if from the\n   * beginning of a new document.\n   */\n  prompt: string | Array<string> | Array<number> | Array<Array<number>> | null;\n\n  /**\n   * Generates `best_of` completions server-side and returns the \"best\" (the one with\n   * the highest log probability per token). Results cannot be streamed.\n   *\n   * When used with `n`, `best_of` controls the number of candidate completions and\n   * `n` specifies how many to return – `best_of` must be greater than `n`.\n   *\n   * **Note:** Because this parameter generates many completions, it can quickly\n   * consume your token quota. Use carefully and ensure that you have reasonable\n   * settings for `max_tokens` and `stop`.\n   */\n  best_of?: number | null;\n\n  /**\n   * Echo back the prompt in addition to the completion\n   */\n  echo?: boolean | null;\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their\n   * existing frequency in the text so far, decreasing the model's likelihood to\n   * repeat the same line verbatim.\n   *\n   * [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)\n   */\n  frequency_penalty?: number | null;\n\n  /**\n   * Modify the likelihood of specified tokens appearing in the completion.\n   *\n   * Accepts a JSON object that maps tokens (specified by their token ID in the GPT\n   * tokenizer) to an associated bias value from -100 to 100. You can use this\n   * [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs.\n   * Mathematically, the bias is added to the logits generated by the model prior to\n   * sampling. The exact effect will vary per model, but values between -1 and 1\n   * should decrease or increase likelihood of selection; values like -100 or 100\n   * should result in a ban or exclusive selection of the relevant token.\n   *\n   * As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token\n   * from being generated.\n   */\n  logit_bias?: Record<string, number> | null;\n\n  /**\n   * Include the log probabilities on the `logprobs` most likely output tokens, as\n   * well the chosen tokens. For example, if `logprobs` is 5, the API will return a\n   * list of the 5 most likely tokens. The API will always return the `logprob` of\n   * the sampled token, so there may be up to `logprobs+1` elements in the response.\n   *\n   * The maximum value for `logprobs` is 5.\n   */\n  logprobs?: number | null;\n\n  /**\n   * The maximum number of [tokens](/tokenizer) that can be generated in the\n   * completion.\n   *\n   * The token count of your prompt plus `max_tokens` cannot exceed the model's\n   * context length.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken)\n   * for counting tokens.\n   */\n  max_tokens?: number | null;\n\n  /**\n   * How many completions to generate for each prompt.\n   *\n   * **Note:** Because this parameter generates many completions, it can quickly\n   * consume your token quota. Use carefully and ensure that you have reasonable\n   * settings for `max_tokens` and `stop`.\n   */\n  n?: number | null;\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on\n   * whether they appear in the text so far, increasing the model's likelihood to\n   * talk about new topics.\n   *\n   * [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)\n   */\n  presence_penalty?: number | null;\n\n  /**\n   * If specified, our system will make a best effort to sample deterministically,\n   * such that repeated requests with the same `seed` and parameters should return\n   * the same result.\n   *\n   * Determinism is not guaranteed, and you should refer to the `system_fingerprint`\n   * response parameter to monitor changes in the backend.\n   */\n  seed?: number | null;\n\n  /**\n   * Up to 4 sequences where the API will stop generating further tokens. The\n   * returned text will not contain the stop sequence.\n   */\n  stop?: string | null | Array<string>;\n\n  /**\n   * Whether to stream back partial progress. If set, tokens will be sent as\n   * data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream?: boolean | null;\n\n  /**\n   * Options for streaming response. Only set this when you set `stream: true`.\n   */\n  stream_options?: ChatCompletionsAPI.ChatCompletionStreamOptions | null;\n\n  /**\n   * The suffix that comes after a completion of inserted text.\n   *\n   * This parameter is only supported for `gpt-3.5-turbo-instruct`.\n   */\n  suffix?: string | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic.\n   *\n   * We generally recommend altering this or `top_p` but not both.\n   */\n  temperature?: number | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered.\n   *\n   * We generally recommend altering this or `temperature` but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport namespace CompletionCreateParams {\n  export type CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\n  export type CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\n}\n\nexport interface CompletionCreateParamsNonStreaming extends CompletionCreateParamsBase {\n  /**\n   * Whether to stream back partial progress. If set, tokens will be sent as\n   * data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream?: false | null;\n}\n\nexport interface CompletionCreateParamsStreaming extends CompletionCreateParamsBase {\n  /**\n   * Whether to stream back partial progress. If set, tokens will be sent as\n   * data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n   */\n  stream: true;\n}\n\nexport namespace Completions {\n  export import Completion = CompletionsAPI.Completion;\n  export import CompletionChoice = CompletionsAPI.CompletionChoice;\n  export import CompletionUsage = CompletionsAPI.CompletionUsage;\n  export import CompletionCreateParams = CompletionsAPI.CompletionCreateParams;\n  export import CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\n  export import CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Embeddings = void 0;\nconst resource_1 = require(\"../resource.js\");\nclass Embeddings extends resource_1.APIResource {\n    /**\n     * Creates an embedding vector representing the input text.\n     */\n    create(body, options) {\n        return this._client.post('/embeddings', { body, ...options });\n    }\n}\nexports.Embeddings = Embeddings;\n(function (Embeddings) {\n})(Embeddings = exports.Embeddings || (exports.Embeddings = {}));\n//# sourceMappingURL=embeddings.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\nimport * as EmbeddingsAPI from './embeddings';\n\nexport class Embeddings extends APIResource {\n  /**\n   * Creates an embedding vector representing the input text.\n   */\n  create(\n    body: EmbeddingCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<CreateEmbeddingResponse> {\n    return this._client.post('/embeddings', { body, ...options });\n  }\n}\n\nexport interface CreateEmbeddingResponse {\n  /**\n   * The list of embeddings generated by the model.\n   */\n  data: Array<Embedding>;\n\n  /**\n   * The name of the model used to generate the embedding.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"list\".\n   */\n  object: 'list';\n\n  /**\n   * The usage information for the request.\n   */\n  usage: CreateEmbeddingResponse.Usage;\n}\n\nexport namespace CreateEmbeddingResponse {\n  /**\n   * The usage information for the request.\n   */\n  export interface Usage {\n    /**\n     * The number of tokens used by the prompt.\n     */\n    prompt_tokens: number;\n\n    /**\n     * The total number of tokens used by the request.\n     */\n    total_tokens: number;\n  }\n}\n\n/**\n * Represents an embedding vector returned by embedding endpoint.\n */\nexport interface Embedding {\n  /**\n   * The embedding vector, which is a list of floats. The length of vector depends on\n   * the model as listed in the\n   * [embedding guide](https://platform.openai.com/docs/guides/embeddings).\n   */\n  embedding: Array<number>;\n\n  /**\n   * The index of the embedding in the list of embeddings.\n   */\n  index: number;\n\n  /**\n   * The object type, which is always \"embedding\".\n   */\n  object: 'embedding';\n}\n\nexport type EmbeddingModel = 'text-embedding-ada-002' | 'text-embedding-3-small' | 'text-embedding-3-large';\n\nexport interface EmbeddingCreateParams {\n  /**\n   * Input text to embed, encoded as a string or array of tokens. To embed multiple\n   * inputs in a single request, pass an array of strings or array of token arrays.\n   * The input must not exceed the max input tokens for the model (8192 tokens for\n   * `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048\n   * dimensions or less.\n   * [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken)\n   * for counting tokens.\n   */\n  input: string | Array<string> | Array<number> | Array<Array<number>>;\n\n  /**\n   * ID of the model to use. You can use the\n   * [List models](https://platform.openai.com/docs/api-reference/models/list) API to\n   * see all of your available models, or see our\n   * [Model overview](https://platform.openai.com/docs/models/overview) for\n   * descriptions of them.\n   */\n  model: (string & {}) | EmbeddingModel;\n\n  /**\n   * The number of dimensions the resulting output embeddings should have. Only\n   * supported in `text-embedding-3` and later models.\n   */\n  dimensions?: number;\n\n  /**\n   * The format to return the embeddings in. Can be either `float` or\n   * [`base64`](https://pypi.org/project/pybase64/).\n   */\n  encoding_format?: 'float' | 'base64';\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport namespace Embeddings {\n  export import CreateEmbeddingResponse = EmbeddingsAPI.CreateEmbeddingResponse;\n  export import Embedding = EmbeddingsAPI.Embedding;\n  export import EmbeddingModel = EmbeddingsAPI.EmbeddingModel;\n  export import EmbeddingCreateParams = EmbeddingsAPI.EmbeddingCreateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileObjectsPage = exports.Files = void 0;\nconst resource_1 = require(\"../resource.js\");\nconst core_1 = require(\"../core.js\");\nconst core_2 = require(\"../core.js\");\nconst error_1 = require(\"../error.js\");\nconst Core = __importStar(require(\"../core.js\"));\nconst FilesAPI = __importStar(require(\"./files.js\"));\nconst pagination_1 = require(\"../pagination.js\");\nclass Files extends resource_1.APIResource {\n    /**\n     * Upload a file that can be used across various endpoints. Individual files can be\n     * up to 512 MB, and the size of all files uploaded by one organization can be up\n     * to 100 GB.\n     *\n     * The Assistants API supports files up to 2 million tokens and of specific file\n     * types. See the\n     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n     * details.\n     *\n     * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n     * required formats for fine-tuning\n     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n     * models.\n     *\n     * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\n     * has a specific required\n     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n     *\n     * Please [contact us](https://help.openai.com/) if you need to increase these\n     * storage limits.\n     */\n    create(body, options) {\n        return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Returns information about a specific file.\n     */\n    retrieve(fileId, options) {\n        return this._client.get(`/files/${fileId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n    }\n    /**\n     * Delete a file.\n     */\n    del(fileId, options) {\n        return this._client.delete(`/files/${fileId}`, options);\n    }\n    /**\n     * Returns the contents of the specified file.\n     */\n    content(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });\n    }\n    /**\n     * Returns the contents of the specified file.\n     *\n     * @deprecated The `.content()` method should be used instead\n     */\n    retrieveContent(fileId, options) {\n        return this._client.get(`/files/${fileId}/content`, {\n            ...options,\n            headers: { Accept: 'application/json', ...options?.headers },\n        });\n    }\n    /**\n     * Waits for the given file to be processed, default timeout is 30 mins.\n     */\n    async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {\n        const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n        const start = Date.now();\n        let file = await this.retrieve(id);\n        while (!file.status || !TERMINAL_STATES.has(file.status)) {\n            await (0, core_2.sleep)(pollInterval);\n            file = await this.retrieve(id);\n            if (Date.now() - start > maxWait) {\n                throw new error_1.APIConnectionTimeoutError({\n                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n                });\n            }\n        }\n        return file;\n    }\n}\nexports.Files = Files;\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nclass FileObjectsPage extends pagination_1.Page {\n}\nexports.FileObjectsPage = FileObjectsPage;\n(function (Files) {\n    Files.FileObjectsPage = FilesAPI.FileObjectsPage;\n})(Files = exports.Files || (exports.Files = {}));\n//# sourceMappingURL=files.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport { isRequestOptions } from '../core';\nimport { sleep } from '../core';\nimport { APIConnectionTimeoutError } from '../error';\nimport * as Core from '../core';\nimport * as FilesAPI from './files';\nimport { Page } from '../pagination';\nimport { type Response } from '../_shims/index';\n\nexport class Files extends APIResource {\n  /**\n   * Upload a file that can be used across various endpoints. Individual files can be\n   * up to 512 MB, and the size of all files uploaded by one organization can be up\n   * to 100 GB.\n   *\n   * The Assistants API supports files up to 2 million tokens and of specific file\n   * types. See the\n   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for\n   * details.\n   *\n   * The Fine-tuning API only supports `.jsonl` files. The input also has certain\n   * required formats for fine-tuning\n   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n   * models.\n   *\n   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\n   * has a specific required\n   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).\n   *\n   * Please [contact us](https://help.openai.com/) if you need to increase these\n   * storage limits.\n   */\n  create(body: FileCreateParams, options?: Core.RequestOptions): Core.APIPromise<FileObject> {\n    return this._client.post('/files', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n\n  /**\n   * Returns information about a specific file.\n   */\n  retrieve(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileObject> {\n    return this._client.get(`/files/${fileId}`, options);\n  }\n\n  /**\n   * Returns a list of files that belong to the user's organization.\n   */\n  list(query?: FileListParams, options?: Core.RequestOptions): Core.PagePromise<FileObjectsPage, FileObject>;\n  list(options?: Core.RequestOptions): Core.PagePromise<FileObjectsPage, FileObject>;\n  list(\n    query: FileListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FileObjectsPage, FileObject> {\n    if (isRequestOptions(query)) {\n      return this.list({}, query);\n    }\n    return this._client.getAPIList('/files', FileObjectsPage, { query, ...options });\n  }\n\n  /**\n   * Delete a file.\n   */\n  del(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileDeleted> {\n    return this._client.delete(`/files/${fileId}`, options);\n  }\n\n  /**\n   * Returns the contents of the specified file.\n   */\n  content(fileId: string, options?: Core.RequestOptions): Core.APIPromise<Response> {\n    return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });\n  }\n\n  /**\n   * Returns the contents of the specified file.\n   *\n   * @deprecated The `.content()` method should be used instead\n   */\n  retrieveContent(fileId: string, options?: Core.RequestOptions): Core.APIPromise<string> {\n    return this._client.get(`/files/${fileId}/content`, {\n      ...options,\n      headers: { Accept: 'application/json', ...options?.headers },\n    });\n  }\n\n  /**\n   * Waits for the given file to be processed, default timeout is 30 mins.\n   */\n  async waitForProcessing(\n    id: string,\n    { pollInterval = 5000, maxWait = 30 * 60 * 1000 }: { pollInterval?: number; maxWait?: number } = {},\n  ): Promise<FileObject> {\n    const TERMINAL_STATES = new Set(['processed', 'error', 'deleted']);\n\n    const start = Date.now();\n    let file = await this.retrieve(id);\n\n    while (!file.status || !TERMINAL_STATES.has(file.status)) {\n      await sleep(pollInterval);\n\n      file = await this.retrieve(id);\n      if (Date.now() - start > maxWait) {\n        throw new APIConnectionTimeoutError({\n          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,\n        });\n      }\n    }\n\n    return file;\n  }\n}\n\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class FileObjectsPage extends Page<FileObject> {}\n\nexport type FileContent = string;\n\nexport interface FileDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'file';\n}\n\n/**\n * The `File` object represents a document that has been uploaded to OpenAI.\n */\nexport interface FileObject {\n  /**\n   * The file identifier, which can be referenced in the API endpoints.\n   */\n  id: string;\n\n  /**\n   * The size of the file, in bytes.\n   */\n  bytes: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the file was created.\n   */\n  created_at: number;\n\n  /**\n   * The name of the file.\n   */\n  filename: string;\n\n  /**\n   * The object type, which is always `file`.\n   */\n  object: 'file';\n\n  /**\n   * The intended purpose of the file. Supported values are `assistants`,\n   * `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results`\n   * and `vision`.\n   */\n  purpose:\n    | 'assistants'\n    | 'assistants_output'\n    | 'batch'\n    | 'batch_output'\n    | 'fine-tune'\n    | 'fine-tune-results'\n    | 'vision';\n\n  /**\n   * @deprecated: Deprecated. The current status of the file, which can be either\n   * `uploaded`, `processed`, or `error`.\n   */\n  status: 'uploaded' | 'processed' | 'error';\n\n  /**\n   * @deprecated: Deprecated. For details on why a fine-tuning training file failed\n   * validation, see the `error` field on `fine_tuning.job`.\n   */\n  status_details?: string;\n}\n\n/**\n * The intended purpose of the uploaded file.\n *\n * Use \"assistants\" for\n * [Assistants](https://platform.openai.com/docs/api-reference/assistants) and\n * [Message](https://platform.openai.com/docs/api-reference/messages) files,\n * \"vision\" for Assistants image file inputs, \"batch\" for\n * [Batch API](https://platform.openai.com/docs/guides/batch), and \"fine-tune\" for\n * [Fine-tuning](https://platform.openai.com/docs/api-reference/fine-tuning).\n */\nexport type FilePurpose = 'assistants' | 'batch' | 'fine-tune' | 'vision';\n\nexport interface FileCreateParams {\n  /**\n   * The File object (not file name) to be uploaded.\n   */\n  file: Core.Uploadable;\n\n  /**\n   * The intended purpose of the uploaded file.\n   *\n   * Use \"assistants\" for\n   * [Assistants](https://platform.openai.com/docs/api-reference/assistants) and\n   * [Message](https://platform.openai.com/docs/api-reference/messages) files,\n   * \"vision\" for Assistants image file inputs, \"batch\" for\n   * [Batch API](https://platform.openai.com/docs/guides/batch), and \"fine-tune\" for\n   * [Fine-tuning](https://platform.openai.com/docs/api-reference/fine-tuning).\n   */\n  purpose: FilePurpose;\n}\n\nexport interface FileListParams {\n  /**\n   * Only return files with the given purpose.\n   */\n  purpose?: string;\n}\n\nexport namespace Files {\n  export import FileContent = FilesAPI.FileContent;\n  export import FileDeleted = FilesAPI.FileDeleted;\n  export import FileObject = FilesAPI.FileObject;\n  export import FilePurpose = FilesAPI.FilePurpose;\n  export import FileObjectsPage = FilesAPI.FileObjectsPage;\n  export import FileCreateParams = FilesAPI.FileCreateParams;\n  export import FileListParams = FilesAPI.FileListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FineTuning = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst JobsAPI = __importStar(require(\"./jobs/jobs.js\"));\nclass FineTuning extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.jobs = new JobsAPI.Jobs(this._client);\n    }\n}\nexports.FineTuning = FineTuning;\n(function (FineTuning) {\n    FineTuning.Jobs = JobsAPI.Jobs;\n    FineTuning.FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n    FineTuning.FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n})(FineTuning = exports.FineTuning || (exports.FineTuning = {}));\n//# sourceMappingURL=fine-tuning.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as JobsAPI from './jobs/jobs';\n\nexport class FineTuning extends APIResource {\n  jobs: JobsAPI.Jobs = new JobsAPI.Jobs(this._client);\n}\n\nexport namespace FineTuning {\n  export import Jobs = JobsAPI.Jobs;\n  export import FineTuningJob = JobsAPI.FineTuningJob;\n  export import FineTuningJobEvent = JobsAPI.FineTuningJobEvent;\n  export import FineTuningJobIntegration = JobsAPI.FineTuningJobIntegration;\n  export import FineTuningJobWandbIntegration = JobsAPI.FineTuningJobWandbIntegration;\n  export import FineTuningJobWandbIntegrationObject = JobsAPI.FineTuningJobWandbIntegrationObject;\n  export import FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n  export import FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n  export import JobCreateParams = JobsAPI.JobCreateParams;\n  export import JobListParams = JobsAPI.JobListParams;\n  export import JobListEventsParams = JobsAPI.JobListEventsParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FineTuningJobEventsPage = exports.FineTuningJobsPage = exports.Jobs = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst JobsAPI = __importStar(require(\"./jobs.js\"));\nconst CheckpointsAPI = __importStar(require(\"./checkpoints.js\"));\nconst pagination_1 = require(\"../../../pagination.js\");\nclass Jobs extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n    }\n    /**\n     * Creates a fine-tuning job which begins the process of creating a new model from\n     * a given dataset.\n     *\n     * Response includes details of the enqueued job including job status and the name\n     * of the fine-tuned models once complete.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */\n    create(body, options) {\n        return this._client.post('/fine_tuning/jobs', { body, ...options });\n    }\n    /**\n     * Get info about a fine-tuning job.\n     *\n     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n     */\n    retrieve(fineTuningJobId, options) {\n        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n    }\n    list(query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list({}, query);\n        }\n        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n    }\n    /**\n     * Immediately cancel a fine-tune job.\n     */\n    cancel(fineTuningJobId, options) {\n        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n    }\n    listEvents(fineTuningJobId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.listEvents(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n            query,\n            ...options,\n        });\n    }\n}\nexports.Jobs = Jobs;\nclass FineTuningJobsPage extends pagination_1.CursorPage {\n}\nexports.FineTuningJobsPage = FineTuningJobsPage;\nclass FineTuningJobEventsPage extends pagination_1.CursorPage {\n}\nexports.FineTuningJobEventsPage = FineTuningJobEventsPage;\n(function (Jobs) {\n    Jobs.FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n    Jobs.FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n    Jobs.Checkpoints = CheckpointsAPI.Checkpoints;\n    Jobs.FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n})(Jobs = exports.Jobs || (exports.Jobs = {}));\n//# sourceMappingURL=jobs.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport * as Core from '../../../core';\nimport * as JobsAPI from './jobs';\nimport * as CheckpointsAPI from './checkpoints';\nimport { CursorPage, type CursorPageParams } from '../../../pagination';\n\nexport class Jobs extends APIResource {\n  checkpoints: CheckpointsAPI.Checkpoints = new CheckpointsAPI.Checkpoints(this._client);\n\n  /**\n   * Creates a fine-tuning job which begins the process of creating a new model from\n   * a given dataset.\n   *\n   * Response includes details of the enqueued job including job status and the name\n   * of the fine-tuned models once complete.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n   */\n  create(body: JobCreateParams, options?: Core.RequestOptions): Core.APIPromise<FineTuningJob> {\n    return this._client.post('/fine_tuning/jobs', { body, ...options });\n  }\n\n  /**\n   * Get info about a fine-tuning job.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n   */\n  retrieve(fineTuningJobId: string, options?: Core.RequestOptions): Core.APIPromise<FineTuningJob> {\n    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);\n  }\n\n  /**\n   * List your organization's fine-tuning jobs\n   */\n  list(\n    query?: JobListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobsPage, FineTuningJob>;\n  list(options?: Core.RequestOptions): Core.PagePromise<FineTuningJobsPage, FineTuningJob>;\n  list(\n    query: JobListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobsPage, FineTuningJob> {\n    if (isRequestOptions(query)) {\n      return this.list({}, query);\n    }\n    return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, { query, ...options });\n  }\n\n  /**\n   * Immediately cancel a fine-tune job.\n   */\n  cancel(fineTuningJobId: string, options?: Core.RequestOptions): Core.APIPromise<FineTuningJob> {\n    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);\n  }\n\n  /**\n   * Get status updates for a fine-tuning job.\n   */\n  listEvents(\n    fineTuningJobId: string,\n    query?: JobListEventsParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobEventsPage, FineTuningJobEvent>;\n  listEvents(\n    fineTuningJobId: string,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobEventsPage, FineTuningJobEvent>;\n  listEvents(\n    fineTuningJobId: string,\n    query: JobListEventsParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobEventsPage, FineTuningJobEvent> {\n    if (isRequestOptions(query)) {\n      return this.listEvents(fineTuningJobId, {}, query);\n    }\n    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {\n      query,\n      ...options,\n    });\n  }\n}\n\nexport class FineTuningJobsPage extends CursorPage<FineTuningJob> {}\n\nexport class FineTuningJobEventsPage extends CursorPage<FineTuningJobEvent> {}\n\n/**\n * The `fine_tuning.job` object represents a fine-tuning job that has been created\n * through the API.\n */\nexport interface FineTuningJob {\n  /**\n   * The object identifier, which can be referenced in the API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the fine-tuning job was created.\n   */\n  created_at: number;\n\n  /**\n   * For fine-tuning jobs that have `failed`, this will contain more information on\n   * the cause of the failure.\n   */\n  error: FineTuningJob.Error | null;\n\n  /**\n   * The name of the fine-tuned model that is being created. The value will be null\n   * if the fine-tuning job is still running.\n   */\n  fine_tuned_model: string | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the fine-tuning job was finished. The\n   * value will be null if the fine-tuning job is still running.\n   */\n  finished_at: number | null;\n\n  /**\n   * The hyperparameters used for the fine-tuning job. See the\n   * [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for\n   * more details.\n   */\n  hyperparameters: FineTuningJob.Hyperparameters;\n\n  /**\n   * The base model that is being fine-tuned.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"fine_tuning.job\".\n   */\n  object: 'fine_tuning.job';\n\n  /**\n   * The organization that owns the fine-tuning job.\n   */\n  organization_id: string;\n\n  /**\n   * The compiled results file ID(s) for the fine-tuning job. You can retrieve the\n   * results with the\n   * [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).\n   */\n  result_files: Array<string>;\n\n  /**\n   * The seed used for the fine-tuning job.\n   */\n  seed: number;\n\n  /**\n   * The current status of the fine-tuning job, which can be either\n   * `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.\n   */\n  status: 'validating_files' | 'queued' | 'running' | 'succeeded' | 'failed' | 'cancelled';\n\n  /**\n   * The total number of billable tokens processed by this fine-tuning job. The value\n   * will be null if the fine-tuning job is still running.\n   */\n  trained_tokens: number | null;\n\n  /**\n   * The file ID used for training. You can retrieve the training data with the\n   * [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).\n   */\n  training_file: string;\n\n  /**\n   * The file ID used for validation. You can retrieve the validation results with\n   * the\n   * [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents).\n   */\n  validation_file: string | null;\n\n  /**\n   * The Unix timestamp (in seconds) for when the fine-tuning job is estimated to\n   * finish. The value will be null if the fine-tuning job is not running.\n   */\n  estimated_finish?: number | null;\n\n  /**\n   * A list of integrations to enable for this fine-tuning job.\n   */\n  integrations?: Array<FineTuningJobWandbIntegrationObject> | null;\n}\n\nexport namespace FineTuningJob {\n  /**\n   * For fine-tuning jobs that have `failed`, this will contain more information on\n   * the cause of the failure.\n   */\n  export interface Error {\n    /**\n     * A machine-readable error code.\n     */\n    code: string;\n\n    /**\n     * A human-readable error message.\n     */\n    message: string;\n\n    /**\n     * The parameter that was invalid, usually `training_file` or `validation_file`.\n     * This field will be null if the failure was not parameter-specific.\n     */\n    param: string | null;\n  }\n\n  /**\n   * The hyperparameters used for the fine-tuning job. See the\n   * [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for\n   * more details.\n   */\n  export interface Hyperparameters {\n    /**\n     * The number of epochs to train the model for. An epoch refers to one full cycle\n     * through the training dataset. \"auto\" decides the optimal number of epochs based\n     * on the size of the dataset. If setting the number manually, we support any\n     * number between 1 and 50 epochs.\n     */\n    n_epochs: 'auto' | number;\n  }\n}\n\n/**\n * Fine-tuning job event object\n */\nexport interface FineTuningJobEvent {\n  id: string;\n\n  created_at: number;\n\n  level: 'info' | 'warn' | 'error';\n\n  message: string;\n\n  object: 'fine_tuning.job.event';\n}\n\nexport type FineTuningJobIntegration = FineTuningJobWandbIntegrationObject;\n\n/**\n * The settings for your integration with Weights and Biases. This payload\n * specifies the project that metrics will be sent to. Optionally, you can set an\n * explicit display name for your run, add tags to your run, and set a default\n * entity (team, username, etc) to be associated with your run.\n */\nexport interface FineTuningJobWandbIntegration {\n  /**\n   * The name of the project that the new run will be created under.\n   */\n  project: string;\n\n  /**\n   * The entity to use for the run. This allows you to set the team or username of\n   * the WandB user that you would like associated with the run. If not set, the\n   * default entity for the registered WandB API key is used.\n   */\n  entity?: string | null;\n\n  /**\n   * A display name to set for the run. If not set, we will use the Job ID as the\n   * name.\n   */\n  name?: string | null;\n\n  /**\n   * A list of tags to be attached to the newly created run. These tags are passed\n   * through directly to WandB. Some default tags are generated by OpenAI:\n   * \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n   */\n  tags?: Array<string>;\n}\n\nexport interface FineTuningJobWandbIntegrationObject {\n  /**\n   * The type of the integration being enabled for the fine-tuning job\n   */\n  type: 'wandb';\n\n  /**\n   * The settings for your integration with Weights and Biases. This payload\n   * specifies the project that metrics will be sent to. Optionally, you can set an\n   * explicit display name for your run, add tags to your run, and set a default\n   * entity (team, username, etc) to be associated with your run.\n   */\n  wandb: FineTuningJobWandbIntegration;\n}\n\nexport interface JobCreateParams {\n  /**\n   * The name of the model to fine-tune. You can select one of the\n   * [supported models](https://platform.openai.com/docs/guides/fine-tuning/which-models-can-be-fine-tuned).\n   */\n  model: (string & {}) | 'babbage-002' | 'davinci-002' | 'gpt-3.5-turbo' | 'gpt-4o-mini';\n\n  /**\n   * The ID of an uploaded file that contains training data.\n   *\n   * See [upload file](https://platform.openai.com/docs/api-reference/files/create)\n   * for how to upload a file.\n   *\n   * Your dataset must be formatted as a JSONL file. Additionally, you must upload\n   * your file with the purpose `fine-tune`.\n   *\n   * The contents of the file should differ depending on if the model uses the\n   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or\n   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)\n   * format.\n   *\n   * See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning)\n   * for more details.\n   */\n  training_file: string;\n\n  /**\n   * The hyperparameters used for the fine-tuning job.\n   */\n  hyperparameters?: JobCreateParams.Hyperparameters;\n\n  /**\n   * A list of integrations to enable for your fine-tuning job.\n   */\n  integrations?: Array<JobCreateParams.Integration> | null;\n\n  /**\n   * The seed controls the reproducibility of the job. Passing in the same seed and\n   * job parameters should produce the same results, but may differ in rare cases. If\n   * a seed is not specified, one will be generated for you.\n   */\n  seed?: number | null;\n\n  /**\n   * A string of up to 64 characters that will be added to your fine-tuned model\n   * name.\n   *\n   * For example, a `suffix` of \"custom-model-name\" would produce a model name like\n   * `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.\n   */\n  suffix?: string | null;\n\n  /**\n   * The ID of an uploaded file that contains validation data.\n   *\n   * If you provide this file, the data is used to generate validation metrics\n   * periodically during fine-tuning. These metrics can be viewed in the fine-tuning\n   * results file. The same data should not be present in both train and validation\n   * files.\n   *\n   * Your dataset must be formatted as a JSONL file. You must upload your file with\n   * the purpose `fine-tune`.\n   *\n   * See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning)\n   * for more details.\n   */\n  validation_file?: string | null;\n}\n\nexport namespace JobCreateParams {\n  /**\n   * The hyperparameters used for the fine-tuning job.\n   */\n  export interface Hyperparameters {\n    /**\n     * Number of examples in each batch. A larger batch size means that model\n     * parameters are updated less frequently, but with lower variance.\n     */\n    batch_size?: 'auto' | number;\n\n    /**\n     * Scaling factor for the learning rate. A smaller learning rate may be useful to\n     * avoid overfitting.\n     */\n    learning_rate_multiplier?: 'auto' | number;\n\n    /**\n     * The number of epochs to train the model for. An epoch refers to one full cycle\n     * through the training dataset.\n     */\n    n_epochs?: 'auto' | number;\n  }\n\n  export interface Integration {\n    /**\n     * The type of integration to enable. Currently, only \"wandb\" (Weights and Biases)\n     * is supported.\n     */\n    type: 'wandb';\n\n    /**\n     * The settings for your integration with Weights and Biases. This payload\n     * specifies the project that metrics will be sent to. Optionally, you can set an\n     * explicit display name for your run, add tags to your run, and set a default\n     * entity (team, username, etc) to be associated with your run.\n     */\n    wandb: Integration.Wandb;\n  }\n\n  export namespace Integration {\n    /**\n     * The settings for your integration with Weights and Biases. This payload\n     * specifies the project that metrics will be sent to. Optionally, you can set an\n     * explicit display name for your run, add tags to your run, and set a default\n     * entity (team, username, etc) to be associated with your run.\n     */\n    export interface Wandb {\n      /**\n       * The name of the project that the new run will be created under.\n       */\n      project: string;\n\n      /**\n       * The entity to use for the run. This allows you to set the team or username of\n       * the WandB user that you would like associated with the run. If not set, the\n       * default entity for the registered WandB API key is used.\n       */\n      entity?: string | null;\n\n      /**\n       * A display name to set for the run. If not set, we will use the Job ID as the\n       * name.\n       */\n      name?: string | null;\n\n      /**\n       * A list of tags to be attached to the newly created run. These tags are passed\n       * through directly to WandB. Some default tags are generated by OpenAI:\n       * \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n       */\n      tags?: Array<string>;\n    }\n  }\n}\n\nexport interface JobListParams extends CursorPageParams {}\n\nexport interface JobListEventsParams extends CursorPageParams {}\n\nexport namespace Jobs {\n  export import FineTuningJob = JobsAPI.FineTuningJob;\n  export import FineTuningJobEvent = JobsAPI.FineTuningJobEvent;\n  export import FineTuningJobIntegration = JobsAPI.FineTuningJobIntegration;\n  export import FineTuningJobWandbIntegration = JobsAPI.FineTuningJobWandbIntegration;\n  export import FineTuningJobWandbIntegrationObject = JobsAPI.FineTuningJobWandbIntegrationObject;\n  export import FineTuningJobsPage = JobsAPI.FineTuningJobsPage;\n  export import FineTuningJobEventsPage = JobsAPI.FineTuningJobEventsPage;\n  export import JobCreateParams = JobsAPI.JobCreateParams;\n  export import JobListParams = JobsAPI.JobListParams;\n  export import JobListEventsParams = JobsAPI.JobListEventsParams;\n  export import Checkpoints = CheckpointsAPI.Checkpoints;\n  export import FineTuningJobCheckpoint = CheckpointsAPI.FineTuningJobCheckpoint;\n  export import FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n  export import CheckpointListParams = CheckpointsAPI.CheckpointListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FineTuningJobCheckpointsPage = exports.Checkpoints = void 0;\nconst resource_1 = require(\"../../../resource.js\");\nconst core_1 = require(\"../../../core.js\");\nconst CheckpointsAPI = __importStar(require(\"./checkpoints.js\"));\nconst pagination_1 = require(\"../../../pagination.js\");\nclass Checkpoints extends resource_1.APIResource {\n    list(fineTuningJobId, query = {}, options) {\n        if ((0, core_1.isRequestOptions)(query)) {\n            return this.list(fineTuningJobId, {}, query);\n        }\n        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });\n    }\n}\nexports.Checkpoints = Checkpoints;\nclass FineTuningJobCheckpointsPage extends pagination_1.CursorPage {\n}\nexports.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;\n(function (Checkpoints) {\n    Checkpoints.FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n})(Checkpoints = exports.Checkpoints || (exports.Checkpoints = {}));\n//# sourceMappingURL=checkpoints.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../../resource';\nimport { isRequestOptions } from '../../../core';\nimport * as Core from '../../../core';\nimport * as CheckpointsAPI from './checkpoints';\nimport { CursorPage, type CursorPageParams } from '../../../pagination';\n\nexport class Checkpoints extends APIResource {\n  /**\n   * List checkpoints for a fine-tuning job.\n   */\n  list(\n    fineTuningJobId: string,\n    query?: CheckpointListParams,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobCheckpointsPage, FineTuningJobCheckpoint>;\n  list(\n    fineTuningJobId: string,\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobCheckpointsPage, FineTuningJobCheckpoint>;\n  list(\n    fineTuningJobId: string,\n    query: CheckpointListParams | Core.RequestOptions = {},\n    options?: Core.RequestOptions,\n  ): Core.PagePromise<FineTuningJobCheckpointsPage, FineTuningJobCheckpoint> {\n    if (isRequestOptions(query)) {\n      return this.list(fineTuningJobId, {}, query);\n    }\n    return this._client.getAPIList(\n      `/fine_tuning/jobs/${fineTuningJobId}/checkpoints`,\n      FineTuningJobCheckpointsPage,\n      { query, ...options },\n    );\n  }\n}\n\nexport class FineTuningJobCheckpointsPage extends CursorPage<FineTuningJobCheckpoint> {}\n\n/**\n * The `fine_tuning.job.checkpoint` object represents a model checkpoint for a\n * fine-tuning job that is ready to use.\n */\nexport interface FineTuningJobCheckpoint {\n  /**\n   * The checkpoint identifier, which can be referenced in the API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the checkpoint was created.\n   */\n  created_at: number;\n\n  /**\n   * The name of the fine-tuned checkpoint model that is created.\n   */\n  fine_tuned_model_checkpoint: string;\n\n  /**\n   * The name of the fine-tuning job that this checkpoint was created from.\n   */\n  fine_tuning_job_id: string;\n\n  /**\n   * Metrics at the step number during the fine-tuning job.\n   */\n  metrics: FineTuningJobCheckpoint.Metrics;\n\n  /**\n   * The object type, which is always \"fine_tuning.job.checkpoint\".\n   */\n  object: 'fine_tuning.job.checkpoint';\n\n  /**\n   * The step number that the checkpoint was created at.\n   */\n  step_number: number;\n}\n\nexport namespace FineTuningJobCheckpoint {\n  /**\n   * Metrics at the step number during the fine-tuning job.\n   */\n  export interface Metrics {\n    full_valid_loss?: number;\n\n    full_valid_mean_token_accuracy?: number;\n\n    step?: number;\n\n    train_loss?: number;\n\n    train_mean_token_accuracy?: number;\n\n    valid_loss?: number;\n\n    valid_mean_token_accuracy?: number;\n  }\n}\n\nexport interface CheckpointListParams extends CursorPageParams {}\n\nexport namespace Checkpoints {\n  export import FineTuningJobCheckpoint = CheckpointsAPI.FineTuningJobCheckpoint;\n  export import FineTuningJobCheckpointsPage = CheckpointsAPI.FineTuningJobCheckpointsPage;\n  export import CheckpointListParams = CheckpointsAPI.CheckpointListParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Images = void 0;\nconst resource_1 = require(\"../resource.js\");\nconst Core = __importStar(require(\"../core.js\"));\nclass Images extends resource_1.APIResource {\n    /**\n     * Creates a variation of a given image.\n     */\n    createVariation(body, options) {\n        return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an edited or extended image given an original image and a prompt.\n     */\n    edit(body, options) {\n        return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n    }\n    /**\n     * Creates an image given a prompt.\n     */\n    generate(body, options) {\n        return this._client.post('/images/generations', { body, ...options });\n    }\n}\nexports.Images = Images;\n(function (Images) {\n})(Images = exports.Images || (exports.Images = {}));\n//# sourceMappingURL=images.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\nimport * as ImagesAPI from './images';\n\nexport class Images extends APIResource {\n  /**\n   * Creates a variation of a given image.\n   */\n  createVariation(\n    body: ImageCreateVariationParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<ImagesResponse> {\n    return this._client.post('/images/variations', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n\n  /**\n   * Creates an edited or extended image given an original image and a prompt.\n   */\n  edit(body: ImageEditParams, options?: Core.RequestOptions): Core.APIPromise<ImagesResponse> {\n    return this._client.post('/images/edits', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n\n  /**\n   * Creates an image given a prompt.\n   */\n  generate(body: ImageGenerateParams, options?: Core.RequestOptions): Core.APIPromise<ImagesResponse> {\n    return this._client.post('/images/generations', { body, ...options });\n  }\n}\n\n/**\n * Represents the url or the content of an image generated by the OpenAI API.\n */\nexport interface Image {\n  /**\n   * The base64-encoded JSON of the generated image, if `response_format` is\n   * `b64_json`.\n   */\n  b64_json?: string;\n\n  /**\n   * The prompt that was used to generate the image, if there was any revision to the\n   * prompt.\n   */\n  revised_prompt?: string;\n\n  /**\n   * The URL of the generated image, if `response_format` is `url` (default).\n   */\n  url?: string;\n}\n\nexport type ImageModel = 'dall-e-2' | 'dall-e-3';\n\nexport interface ImagesResponse {\n  created: number;\n\n  data: Array<Image>;\n}\n\nexport interface ImageCreateVariationParams {\n  /**\n   * The image to use as the basis for the variation(s). Must be a valid PNG file,\n   * less than 4MB, and square.\n   */\n  image: Core.Uploadable;\n\n  /**\n   * The model to use for image generation. Only `dall-e-2` is supported at this\n   * time.\n   */\n  model?: (string & {}) | ImageModel | null;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only\n   * `n=1` is supported.\n   */\n  n?: number | null;\n\n  /**\n   * The format in which the generated images are returned. Must be one of `url` or\n   * `b64_json`. URLs are only valid for 60 minutes after the image has been\n   * generated.\n   */\n  response_format?: 'url' | 'b64_json' | null;\n\n  /**\n   * The size of the generated images. Must be one of `256x256`, `512x512`, or\n   * `1024x1024`.\n   */\n  size?: '256x256' | '512x512' | '1024x1024' | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport interface ImageEditParams {\n  /**\n   * The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask\n   * is not provided, image must have transparency, which will be used as the mask.\n   */\n  image: Core.Uploadable;\n\n  /**\n   * A text description of the desired image(s). The maximum length is 1000\n   * characters.\n   */\n  prompt: string;\n\n  /**\n   * An additional image whose fully transparent areas (e.g. where alpha is zero)\n   * indicate where `image` should be edited. Must be a valid PNG file, less than\n   * 4MB, and have the same dimensions as `image`.\n   */\n  mask?: Core.Uploadable;\n\n  /**\n   * The model to use for image generation. Only `dall-e-2` is supported at this\n   * time.\n   */\n  model?: (string & {}) | ImageModel | null;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10.\n   */\n  n?: number | null;\n\n  /**\n   * The format in which the generated images are returned. Must be one of `url` or\n   * `b64_json`. URLs are only valid for 60 minutes after the image has been\n   * generated.\n   */\n  response_format?: 'url' | 'b64_json' | null;\n\n  /**\n   * The size of the generated images. Must be one of `256x256`, `512x512`, or\n   * `1024x1024`.\n   */\n  size?: '256x256' | '512x512' | '1024x1024' | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport interface ImageGenerateParams {\n  /**\n   * A text description of the desired image(s). The maximum length is 1000\n   * characters for `dall-e-2` and 4000 characters for `dall-e-3`.\n   */\n  prompt: string;\n\n  /**\n   * The model to use for image generation.\n   */\n  model?: (string & {}) | ImageModel | null;\n\n  /**\n   * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only\n   * `n=1` is supported.\n   */\n  n?: number | null;\n\n  /**\n   * The quality of the image that will be generated. `hd` creates images with finer\n   * details and greater consistency across the image. This param is only supported\n   * for `dall-e-3`.\n   */\n  quality?: 'standard' | 'hd';\n\n  /**\n   * The format in which the generated images are returned. Must be one of `url` or\n   * `b64_json`. URLs are only valid for 60 minutes after the image has been\n   * generated.\n   */\n  response_format?: 'url' | 'b64_json' | null;\n\n  /**\n   * The size of the generated images. Must be one of `256x256`, `512x512`, or\n   * `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or\n   * `1024x1792` for `dall-e-3` models.\n   */\n  size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792' | null;\n\n  /**\n   * The style of the generated images. Must be one of `vivid` or `natural`. Vivid\n   * causes the model to lean towards generating hyper-real and dramatic images.\n   * Natural causes the model to produce more natural, less hyper-real looking\n   * images. This param is only supported for `dall-e-3`.\n   */\n  style?: 'vivid' | 'natural' | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help OpenAI to monitor\n   * and detect abuse.\n   * [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).\n   */\n  user?: string;\n}\n\nexport namespace Images {\n  export import Image = ImagesAPI.Image;\n  export import ImageModel = ImagesAPI.ImageModel;\n  export import ImagesResponse = ImagesAPI.ImagesResponse;\n  export import ImageCreateVariationParams = ImagesAPI.ImageCreateVariationParams;\n  export import ImageEditParams = ImagesAPI.ImageEditParams;\n  export import ImageGenerateParams = ImagesAPI.ImageGenerateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ModelsPage = exports.Models = void 0;\nconst resource_1 = require(\"../resource.js\");\nconst ModelsAPI = __importStar(require(\"./models.js\"));\nconst pagination_1 = require(\"../pagination.js\");\nclass Models extends resource_1.APIResource {\n    /**\n     * Retrieves a model instance, providing basic information about the model such as\n     * the owner and permissioning.\n     */\n    retrieve(model, options) {\n        return this._client.get(`/models/${model}`, options);\n    }\n    /**\n     * Lists the currently available models, and provides basic information about each\n     * one such as the owner and availability.\n     */\n    list(options) {\n        return this._client.getAPIList('/models', ModelsPage, options);\n    }\n    /**\n     * Delete a fine-tuned model. You must have the Owner role in your organization to\n     * delete a model.\n     */\n    del(model, options) {\n        return this._client.delete(`/models/${model}`, options);\n    }\n}\nexports.Models = Models;\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nclass ModelsPage extends pagination_1.Page {\n}\nexports.ModelsPage = ModelsPage;\n(function (Models) {\n    Models.ModelsPage = ModelsAPI.ModelsPage;\n})(Models = exports.Models || (exports.Models = {}));\n//# sourceMappingURL=models.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\nimport * as ModelsAPI from './models';\nimport { Page } from '../pagination';\n\nexport class Models extends APIResource {\n  /**\n   * Retrieves a model instance, providing basic information about the model such as\n   * the owner and permissioning.\n   */\n  retrieve(model: string, options?: Core.RequestOptions): Core.APIPromise<Model> {\n    return this._client.get(`/models/${model}`, options);\n  }\n\n  /**\n   * Lists the currently available models, and provides basic information about each\n   * one such as the owner and availability.\n   */\n  list(options?: Core.RequestOptions): Core.PagePromise<ModelsPage, Model> {\n    return this._client.getAPIList('/models', ModelsPage, options);\n  }\n\n  /**\n   * Delete a fine-tuned model. You must have the Owner role in your organization to\n   * delete a model.\n   */\n  del(model: string, options?: Core.RequestOptions): Core.APIPromise<ModelDeleted> {\n    return this._client.delete(`/models/${model}`, options);\n  }\n}\n\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class ModelsPage extends Page<Model> {}\n\n/**\n * Describes an OpenAI model offering that can be used with the API.\n */\nexport interface Model {\n  /**\n   * The model identifier, which can be referenced in the API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) when the model was created.\n   */\n  created: number;\n\n  /**\n   * The object type, which is always \"model\".\n   */\n  object: 'model';\n\n  /**\n   * The organization that owns the model.\n   */\n  owned_by: string;\n}\n\nexport interface ModelDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: string;\n}\n\nexport namespace Models {\n  export import Model = ModelsAPI.Model;\n  export import ModelDeleted = ModelsAPI.ModelDeleted;\n  export import ModelsPage = ModelsAPI.ModelsPage;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Moderations = void 0;\nconst resource_1 = require(\"../resource.js\");\nclass Moderations extends resource_1.APIResource {\n    /**\n     * Classifies if text and/or image inputs are potentially harmful. Learn more in\n     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n     */\n    create(body, options) {\n        return this._client.post('/moderations', { body, ...options });\n    }\n}\nexports.Moderations = Moderations;\n(function (Moderations) {\n})(Moderations = exports.Moderations || (exports.Moderations = {}));\n//# sourceMappingURL=moderations.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\nimport * as ModerationsAPI from './moderations';\n\nexport class Moderations extends APIResource {\n  /**\n   * Classifies if text and/or image inputs are potentially harmful. Learn more in\n   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).\n   */\n  create(\n    body: ModerationCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<ModerationCreateResponse> {\n    return this._client.post('/moderations', { body, ...options });\n  }\n}\n\nexport interface Moderation {\n  /**\n   * A list of the categories, and whether they are flagged or not.\n   */\n  categories: Moderation.Categories;\n\n  /**\n   * A list of the categories along with the input type(s) that the score applies to.\n   */\n  category_applied_input_types: Moderation.CategoryAppliedInputTypes;\n\n  /**\n   * A list of the categories along with their scores as predicted by model.\n   */\n  category_scores: Moderation.CategoryScores;\n\n  /**\n   * Whether any of the below categories are flagged.\n   */\n  flagged: boolean;\n}\n\nexport namespace Moderation {\n  /**\n   * A list of the categories, and whether they are flagged or not.\n   */\n  export interface Categories {\n    /**\n     * Content that expresses, incites, or promotes harassing language towards any\n     * target.\n     */\n    harassment: boolean;\n\n    /**\n     * Harassment content that also includes violence or serious harm towards any\n     * target.\n     */\n    'harassment/threatening': boolean;\n\n    /**\n     * Content that expresses, incites, or promotes hate based on race, gender,\n     * ethnicity, religion, nationality, sexual orientation, disability status, or\n     * caste. Hateful content aimed at non-protected groups (e.g., chess players) is\n     * harassment.\n     */\n    hate: boolean;\n\n    /**\n     * Hateful content that also includes violence or serious harm towards the targeted\n     * group based on race, gender, ethnicity, religion, nationality, sexual\n     * orientation, disability status, or caste.\n     */\n    'hate/threatening': boolean;\n\n    /**\n     * Content that includes instructions or advice that facilitate the planning or\n     * execution of wrongdoing, or that gives advice or instruction on how to commit\n     * illicit acts. For example, \"how to shoplift\" would fit this category.\n     */\n    illicit: boolean;\n\n    /**\n     * Content that includes instructions or advice that facilitate the planning or\n     * execution of wrongdoing that also includes violence, or that gives advice or\n     * instruction on the procurement of any weapon.\n     */\n    'illicit/violent': boolean;\n\n    /**\n     * Content that promotes, encourages, or depicts acts of self-harm, such as\n     * suicide, cutting, and eating disorders.\n     */\n    'self-harm': boolean;\n\n    /**\n     * Content that encourages performing acts of self-harm, such as suicide, cutting,\n     * and eating disorders, or that gives instructions or advice on how to commit such\n     * acts.\n     */\n    'self-harm/instructions': boolean;\n\n    /**\n     * Content where the speaker expresses that they are engaging or intend to engage\n     * in acts of self-harm, such as suicide, cutting, and eating disorders.\n     */\n    'self-harm/intent': boolean;\n\n    /**\n     * Content meant to arouse sexual excitement, such as the description of sexual\n     * activity, or that promotes sexual services (excluding sex education and\n     * wellness).\n     */\n    sexual: boolean;\n\n    /**\n     * Sexual content that includes an individual who is under 18 years old.\n     */\n    'sexual/minors': boolean;\n\n    /**\n     * Content that depicts death, violence, or physical injury.\n     */\n    violence: boolean;\n\n    /**\n     * Content that depicts death, violence, or physical injury in graphic detail.\n     */\n    'violence/graphic': boolean;\n  }\n\n  /**\n   * A list of the categories along with the input type(s) that the score applies to.\n   */\n  export interface CategoryAppliedInputTypes {\n    /**\n     * The applied input type(s) for the category 'harassment'.\n     */\n    harassment: Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'harassment/threatening'.\n     */\n    'harassment/threatening': Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'hate'.\n     */\n    hate: Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'hate/threatening'.\n     */\n    'hate/threatening': Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'illicit'.\n     */\n    illicit: Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'illicit/violent'.\n     */\n    'illicit/violent': Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'self-harm'.\n     */\n    'self-harm': Array<'text' | 'image'>;\n\n    /**\n     * The applied input type(s) for the category 'self-harm/instructions'.\n     */\n    'self-harm/instructions': Array<'text' | 'image'>;\n\n    /**\n     * The applied input type(s) for the category 'self-harm/intent'.\n     */\n    'self-harm/intent': Array<'text' | 'image'>;\n\n    /**\n     * The applied input type(s) for the category 'sexual'.\n     */\n    sexual: Array<'text' | 'image'>;\n\n    /**\n     * The applied input type(s) for the category 'sexual/minors'.\n     */\n    'sexual/minors': Array<'text'>;\n\n    /**\n     * The applied input type(s) for the category 'violence'.\n     */\n    violence: Array<'text' | 'image'>;\n\n    /**\n     * The applied input type(s) for the category 'violence/graphic'.\n     */\n    'violence/graphic': Array<'text' | 'image'>;\n  }\n\n  /**\n   * A list of the categories along with their scores as predicted by model.\n   */\n  export interface CategoryScores {\n    /**\n     * The score for the category 'harassment'.\n     */\n    harassment: number;\n\n    /**\n     * The score for the category 'harassment/threatening'.\n     */\n    'harassment/threatening': number;\n\n    /**\n     * The score for the category 'hate'.\n     */\n    hate: number;\n\n    /**\n     * The score for the category 'hate/threatening'.\n     */\n    'hate/threatening': number;\n\n    /**\n     * The score for the category 'illicit'.\n     */\n    illicit: number;\n\n    /**\n     * The score for the category 'illicit/violent'.\n     */\n    'illicit/violent': number;\n\n    /**\n     * The score for the category 'self-harm'.\n     */\n    'self-harm': number;\n\n    /**\n     * The score for the category 'self-harm/instructions'.\n     */\n    'self-harm/instructions': number;\n\n    /**\n     * The score for the category 'self-harm/intent'.\n     */\n    'self-harm/intent': number;\n\n    /**\n     * The score for the category 'sexual'.\n     */\n    sexual: number;\n\n    /**\n     * The score for the category 'sexual/minors'.\n     */\n    'sexual/minors': number;\n\n    /**\n     * The score for the category 'violence'.\n     */\n    violence: number;\n\n    /**\n     * The score for the category 'violence/graphic'.\n     */\n    'violence/graphic': number;\n  }\n}\n\n/**\n * An object describing an image to classify.\n */\nexport interface ModerationImageURLInput {\n  /**\n   * Contains either an image URL or a data URL for a base64 encoded image.\n   */\n  image_url: ModerationImageURLInput.ImageURL;\n\n  /**\n   * Always `image_url`.\n   */\n  type: 'image_url';\n}\n\nexport namespace ModerationImageURLInput {\n  /**\n   * Contains either an image URL or a data URL for a base64 encoded image.\n   */\n  export interface ImageURL {\n    /**\n     * Either a URL of the image or the base64 encoded image data.\n     */\n    url: string;\n  }\n}\n\nexport type ModerationModel =\n  | 'omni-moderation-latest'\n  | 'omni-moderation-2024-09-26'\n  | 'text-moderation-latest'\n  | 'text-moderation-stable';\n\n/**\n * An object describing an image to classify.\n */\nexport type ModerationMultiModalInput = ModerationImageURLInput | ModerationTextInput;\n\n/**\n * An object describing text to classify.\n */\nexport interface ModerationTextInput {\n  /**\n   * A string of text to classify.\n   */\n  text: string;\n\n  /**\n   * Always `text`.\n   */\n  type: 'text';\n}\n\n/**\n * Represents if a given text input is potentially harmful.\n */\nexport interface ModerationCreateResponse {\n  /**\n   * The unique identifier for the moderation request.\n   */\n  id: string;\n\n  /**\n   * The model used to generate the moderation results.\n   */\n  model: string;\n\n  /**\n   * A list of moderation objects.\n   */\n  results: Array<Moderation>;\n}\n\nexport interface ModerationCreateParams {\n  /**\n   * Input (or inputs) to classify. Can be a single string, an array of strings, or\n   * an array of multi-modal input objects similar to other models.\n   */\n  input: string | Array<string> | Array<ModerationMultiModalInput>;\n\n  /**\n   * The content moderation model you would like to use. Learn more in\n   * [the moderation guide](https://platform.openai.com/docs/guides/moderation), and\n   * learn about available models\n   * [here](https://platform.openai.com/docs/models/moderation).\n   */\n  model?: (string & {}) | ModerationModel;\n}\n\nexport namespace Moderations {\n  export import Moderation = ModerationsAPI.Moderation;\n  export import ModerationImageURLInput = ModerationsAPI.ModerationImageURLInput;\n  export import ModerationModel = ModerationsAPI.ModerationModel;\n  export import ModerationMultiModalInput = ModerationsAPI.ModerationMultiModalInput;\n  export import ModerationTextInput = ModerationsAPI.ModerationTextInput;\n  export import ModerationCreateResponse = ModerationsAPI.ModerationCreateResponse;\n  export import ModerationCreateParams = ModerationsAPI.ModerationCreateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Uploads = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst PartsAPI = __importStar(require(\"./parts.js\"));\nclass Uploads extends resource_1.APIResource {\n    constructor() {\n        super(...arguments);\n        this.parts = new PartsAPI.Parts(this._client);\n    }\n    /**\n     * Creates an intermediate\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n     * that you can add\n     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n     * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n     * after you create it.\n     *\n     * Once you complete the Upload, we will create a\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * contains all the parts you uploaded. This File is usable in the rest of our\n     * platform as a regular File object.\n     *\n     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer\n     * to documentation for the supported MIME types for your use case:\n     *\n     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)\n     *\n     * For guidance on the proper filename extensions for each purpose, please follow\n     * the documentation on\n     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n     */\n    create(body, options) {\n        return this._client.post('/uploads', { body, ...options });\n    }\n    /**\n     * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n     */\n    cancel(uploadId, options) {\n        return this._client.post(`/uploads/${uploadId}/cancel`, options);\n    }\n    /**\n     * Completes the\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n     *\n     * Within the returned Upload object, there is a nested\n     * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n     * is ready to use in the rest of the platform.\n     *\n     * You can specify the order of the Parts by passing in an ordered list of the Part\n     * IDs.\n     *\n     * The number of bytes uploaded upon completion must match the number of bytes\n     * initially specified when creating the Upload object. No Parts may be added after\n     * an Upload is completed.\n     */\n    complete(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n    }\n}\nexports.Uploads = Uploads;\n(function (Uploads) {\n    Uploads.Parts = PartsAPI.Parts;\n})(Uploads = exports.Uploads || (exports.Uploads = {}));\n//# sourceMappingURL=uploads.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as UploadsAPI from './uploads';\nimport * as FilesAPI from '../files';\nimport * as PartsAPI from './parts';\n\nexport class Uploads extends APIResource {\n  parts: PartsAPI.Parts = new PartsAPI.Parts(this._client);\n\n  /**\n   * Creates an intermediate\n   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object\n   * that you can add\n   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.\n   * Currently, an Upload can accept at most 8 GB in total and expires after an hour\n   * after you create it.\n   *\n   * Once you complete the Upload, we will create a\n   * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n   * contains all the parts you uploaded. This File is usable in the rest of our\n   * platform as a regular File object.\n   *\n   * For certain `purpose`s, the correct `mime_type` must be specified. Please refer\n   * to documentation for the supported MIME types for your use case:\n   *\n   * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)\n   *\n   * For guidance on the proper filename extensions for each purpose, please follow\n   * the documentation on\n   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).\n   */\n  create(body: UploadCreateParams, options?: Core.RequestOptions): Core.APIPromise<Upload> {\n    return this._client.post('/uploads', { body, ...options });\n  }\n\n  /**\n   * Cancels the Upload. No Parts may be added after an Upload is cancelled.\n   */\n  cancel(uploadId: string, options?: Core.RequestOptions): Core.APIPromise<Upload> {\n    return this._client.post(`/uploads/${uploadId}/cancel`, options);\n  }\n\n  /**\n   * Completes the\n   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).\n   *\n   * Within the returned Upload object, there is a nested\n   * [File](https://platform.openai.com/docs/api-reference/files/object) object that\n   * is ready to use in the rest of the platform.\n   *\n   * You can specify the order of the Parts by passing in an ordered list of the Part\n   * IDs.\n   *\n   * The number of bytes uploaded upon completion must match the number of bytes\n   * initially specified when creating the Upload object. No Parts may be added after\n   * an Upload is completed.\n   */\n  complete(\n    uploadId: string,\n    body: UploadCompleteParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Upload> {\n    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });\n  }\n}\n\n/**\n * The Upload object can accept byte chunks in the form of Parts.\n */\nexport interface Upload {\n  /**\n   * The Upload unique identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The intended number of bytes to be uploaded.\n   */\n  bytes: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the Upload was created.\n   */\n  created_at: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the Upload was created.\n   */\n  expires_at: number;\n\n  /**\n   * The name of the file to be uploaded.\n   */\n  filename: string;\n\n  /**\n   * The object type, which is always \"upload\".\n   */\n  object: 'upload';\n\n  /**\n   * The intended purpose of the file.\n   * [Please refer here](https://platform.openai.com/docs/api-reference/files/object#files/object-purpose)\n   * for acceptable values.\n   */\n  purpose: string;\n\n  /**\n   * The status of the Upload.\n   */\n  status: 'pending' | 'completed' | 'cancelled' | 'expired';\n\n  /**\n   * The ready File object after the Upload is completed.\n   */\n  file?: FilesAPI.FileObject | null;\n}\n\nexport interface UploadCreateParams {\n  /**\n   * The number of bytes in the file you are uploading.\n   */\n  bytes: number;\n\n  /**\n   * The name of the file to upload.\n   */\n  filename: string;\n\n  /**\n   * The MIME type of the file.\n   *\n   * This must fall within the supported MIME types for your file purpose. See the\n   * supported MIME types for assistants and vision.\n   */\n  mime_type: string;\n\n  /**\n   * The intended purpose of the uploaded file.\n   *\n   * See the\n   * [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n   */\n  purpose: FilesAPI.FilePurpose;\n}\n\nexport interface UploadCompleteParams {\n  /**\n   * The ordered list of Part IDs.\n   */\n  part_ids: Array<string>;\n\n  /**\n   * The optional md5 checksum for the file contents to verify if the bytes uploaded\n   * matches what you expect.\n   */\n  md5?: string;\n}\n\nexport namespace Uploads {\n  export import Upload = UploadsAPI.Upload;\n  export import UploadCreateParams = UploadsAPI.UploadCreateParams;\n  export import UploadCompleteParams = UploadsAPI.UploadCompleteParams;\n  export import Parts = PartsAPI.Parts;\n  export import UploadPart = PartsAPI.UploadPart;\n  export import PartCreateParams = PartsAPI.PartCreateParams;\n}\n","\"use strict\";\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parts = void 0;\nconst resource_1 = require(\"../../resource.js\");\nconst Core = __importStar(require(\"../../core.js\"));\nclass Parts extends resource_1.APIResource {\n    /**\n     * Adds a\n     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n     * A Part represents a chunk of bytes from the file you are trying to upload.\n     *\n     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n     * maximum of 8 GB.\n     *\n     * It is possible to add multiple Parts in parallel. You can decide the intended\n     * order of the Parts when you\n     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n     */\n    create(uploadId, body, options) {\n        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({ body, ...options }));\n    }\n}\nexports.Parts = Parts;\n(function (Parts) {\n})(Parts = exports.Parts || (exports.Parts = {}));\n//# sourceMappingURL=parts.js.map","// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as PartsAPI from './parts';\n\nexport class Parts extends APIResource {\n  /**\n   * Adds a\n   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an\n   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.\n   * A Part represents a chunk of bytes from the file you are trying to upload.\n   *\n   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload\n   * maximum of 8 GB.\n   *\n   * It is possible to add multiple Parts in parallel. You can decide the intended\n   * order of the Parts when you\n   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).\n   */\n  create(\n    uploadId: string,\n    body: PartCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<UploadPart> {\n    return this._client.post(\n      `/uploads/${uploadId}/parts`,\n      Core.multipartFormRequestOptions({ body, ...options }),\n    );\n  }\n}\n\n/**\n * The upload Part represents a chunk of bytes we can add to an Upload object.\n */\nexport interface UploadPart {\n  /**\n   * The upload Part unique identifier, which can be referenced in API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the Part was created.\n   */\n  created_at: number;\n\n  /**\n   * The object type, which is always `upload.part`.\n   */\n  object: 'upload.part';\n\n  /**\n   * The ID of the Upload object that this Part was added to.\n   */\n  upload_id: string;\n}\n\nexport interface PartCreateParams {\n  /**\n   * The chunk of bytes for this Part.\n   */\n  data: Core.Uploadable;\n}\n\nexport namespace Parts {\n  export import UploadPart = PartsAPI.UploadPart;\n  export import PartCreateParams = PartsAPI.PartCreateParams;\n}\n","\"use strict\";\r\n//setup\r\nconst debug = true;\r\nlet wordNum = 0;\r\nimport { getSentence, getCorrections } from \"./chat.js\";\r\n\r\n//event listeners\r\ndocument.querySelector(\"#enter-words\").addEventListener(\"click\", enterWord);\r\ndocument\r\n  .querySelector(\"#enter-attempt\")\r\n  .addEventListener(\"click\", checkAttempt);\r\ndocument.querySelector(\"#clear-words\").addEventListener(\"click\", clearWords);\r\n\r\n//main functions\r\n\r\n//generates a new prompt\r\nasync function enterWord() {\r\n  //edge case: words contains only whitespace\r\n  if (document.querySelector(\"#words\").value.trim().length === 0) {\r\n    console.log(\"Cannot get sentence: words is empty\");\r\n    return;\r\n  }\r\n\r\n  //debug messages\r\n  if (debug) {\r\n    wordNum++;\r\n    console.log(\"\\n\\nWord #\" + wordNum);\r\n  }\r\n\r\n  //input\r\n  const apiKey = document.querySelector(\"#api-key\").value;\r\n  const languageCode = document.querySelector(\"#language-code\").value;\r\n  if (\r\n    document.querySelector(\"#words\").value.length < 6 ||\r\n    document.querySelector(\"#words\").value.slice(0, 6) !== \"\\n\\n\\n\\n\\n\\n\"\r\n  )\r\n    document.querySelector(\"#words\").value =\r\n      \"\\n\\n\\n\\n\\n\\n\" + document.querySelector(\"#words\").value;\r\n  const words = document.querySelector(\"#words\").value.split(\"\\n\");\r\n  let word = words[Math.floor(Math.random() * words.length)];\r\n  while (word === \"\") word = words[Math.floor(Math.random() * words.length)];\r\n  const notes = document.querySelector(\"#notes\").value;\r\n  const query = {\r\n    languageCode,\r\n    word,\r\n    notes,\r\n  };\r\n\r\n  //output\r\n  const response = JSON.parse(await getSentence(query, apiKey));\r\n  document.querySelector(\"#en\").textContent = response.en;\r\n  document.querySelector(\"#target-label\").textContent = response.targetLanguage;\r\n\r\n  //debug messages\r\n  if (debug) {\r\n    console.log(`script.js sent:`);\r\n    console.log(query);\r\n    console.log(\"script.js received:\");\r\n    console.log(response);\r\n  }\r\n}\r\n\r\n//grades attempt\r\nasync function checkAttempt() {\r\n  //debug messages\r\n  if (debug) console.log(\"\\n\\nAttempt #\" + wordNum);\r\n\r\n  //input\r\n  const apiKey = document.querySelector(\"#api-key\").value;\r\n  const targetLanguage = document.querySelector(\"#language-code\").value;\r\n  const originalSentence = document.querySelector(\"#en\").textContent;\r\n  const attempt = document.querySelector(\"#attempt-input\").value;\r\n  document.querySelector(\"#attempt-input\").value = \"\";\r\n  const query = {\r\n    targetLanguage,\r\n    originalSentence,\r\n    attempt,\r\n  };\r\n\r\n  //output\r\n  const response = JSON.parse(await getCorrections(query, apiKey));\r\n  document.querySelector(\"#attempt-display\").textContent = response.attempt;\r\n  document.querySelector(\"#corrected-attempt-display\").textContent =\r\n    response.correctedAttempt;\r\n  let correctionsStr = \"\";\r\n  for ([i, correction] of response.corrections.entries())\r\n    correctionsStr += `${i + 1}. ${correction}\\n\\n`;\r\n  document.querySelector(\"#corrections-display\").textContent = correctionsStr;\r\n\r\n  //debug messages\r\n  if (debug) {\r\n    console.log(\"script.js sent: \");\r\n    console.log(query);\r\n    console.log(\"script.js received: \");\r\n    console.log(response);\r\n  }\r\n}\r\n\r\n//clears words in the textarea\r\nfunction clearWords() {\r\n  document.querySelector(\"#words\").value = \"\";\r\n}\r\n","\"use strict\";\r\n//setup\r\nimport { OpenAI } from \"openai\";\r\n\r\n//functions\r\n\r\n//generic call to API\r\nexport async function call(messages, apiKey) {\r\n  const openai = new OpenAI({\r\n    apiKey,\r\n    dangerouslyAllowBrowser: true,\r\n  });\r\n\r\n  const completion = await openai.chat.completions.create({\r\n    model: \"gpt-4o-mini\",\r\n    messages,\r\n  });\r\n\r\n  return completion.choices[0].message.content;\r\n}\r\n\r\n//generates a prompt sentence\r\nexport async function getSentence(query, apiKey) {\r\n  const messages = [\r\n    {\r\n      role: \"user\",\r\n      content:\r\n        \"Give me a plain text JSON with a simple  English sentence featuring this word. Also tell me the target language with this code. Obey all notes.\",\r\n    },\r\n    {\r\n      role: \"user\",\r\n      content:\r\n        '{\"languageCode\": \"zh\", \"word\": \"fruit\", \"difficulty\": \"beginner\", \"notes\": \"ask a question\"}',\r\n    },\r\n    {\r\n      role: \"assistant\",\r\n      content:\r\n        '{\"targetLanguage\": \"Chinese\", \"en\": \"What is your favorite fruit to eat?\"}',\r\n    },\r\n    {\r\n      role: \"user\",\r\n      content: JSON.stringify(query),\r\n    },\r\n  ];\r\n  return await call(messages, apiKey);\r\n}\r\n\r\n//generates feedback\r\nexport async function getCorrections(query, apiKey) {\r\n  const messages = [\r\n    {\r\n      role: \"user\",\r\n      content:\r\n        \"Give a JSON with my translation attempt and corrections on my attempt. If my attempt is perfect, leave the corrections array empty. Include transliterations if applicable.\",\r\n    },\r\n    {\r\n      role: \"user\",\r\n      content:\r\n        '{\"targetLanguage\": \"zh\", \"originalSentence\": \"This dog has brown fur.\", \"attempt\": \"这个狗有棕色毛发\"}',\r\n    },\r\n    {\r\n      role: \"assistant\",\r\n      content: `{\"attempt\": \"这个狗有棕色毛发 (zhège gǒu yǒu zōngsè máofà)\", \"correctedAttempt\": \"这只狗有棕色的毛发。(zhèzhī gǒu yǒu zōngsède máofà.)\", \"corrections\": [\"Use \\\\\"只 (zhī)\\\\\" instead of \\\\\"个 (ge)\\\\\" because \\\\\"只\\\\\" is the measure word for animals.\", \"Insert \\\\\"的 (de)\\\\\" into \\\\\"棕色的毛发 (zōngsède máofà)\\\\\" to connect the adjective to the noun.]}`,\r\n    },\r\n    { role: \"user\", content: JSON.stringify(query) },\r\n  ];\r\n  return await call(messages, apiKey);\r\n}\r\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","OpenAI","_a","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","__setModuleDefault","value","__importStar","mod","result","prototype","hasOwnProperty","AzureOpenAI","fileFromPath","toFile","UnprocessableEntityError","PermissionDeniedError","InternalServerError","AuthenticationError","BadRequestError","RateLimitError","ConflictError","NotFoundError","APIUserAbortError","APIConnectionTimeoutError","APIConnectionError","APIError","OpenAIError","Errors","Uploads","qs","Core","Pagination","API","APIClient","constructor","baseURL","readEnv","apiKey","organization","project","opts","options","dangerouslyAllowBrowser","isRunningInBrowser","timeout","httpAgent","maxRetries","fetch","completions","Completions","chat","Chat","embeddings","Embeddings","files","Files","images","Images","audio","Audio","moderations","Moderations","models","Models","fineTuning","FineTuning","beta","Beta","batches","Batches","uploads","_options","defaultQuery","defaultHeaders","authHeaders","Authorization","stringifyQuery","query","stringify","arrayFormat","DEFAULT_TIMEOUT","Page","CursorPage","FileObjectsPage","ModelsPage","BatchesPage","apiVersion","endpoint","deployment","azureADTokenProvider","API_KEY_SENTINEL","_azureADTokenProvider","_deployment","buildRequest","_deployments_endpoints","has","path","method","body","isObj","model","includes","_getAzureADToken","token","prepareOptions","headers","Set","default","ContentFilterFinishReasonError","LengthFinishReasonError","$9xH07","$d06e149166359a9e$var$OpenAIError","$d06e149166359a9e$var$APIError","status","error","message","makeMessage","request_id","param","type","msg","JSON","generate","errorResponse","$d06e149166359a9e$var$APIConnectionError","cause","castToError","$d06e149166359a9e$var$BadRequestError","$d06e149166359a9e$var$AuthenticationError","$d06e149166359a9e$var$PermissionDeniedError","$d06e149166359a9e$var$NotFoundError","$d06e149166359a9e$var$ConflictError","$d06e149166359a9e$var$UnprocessableEntityError","$d06e149166359a9e$var$RateLimitError","$d06e149166359a9e$var$InternalServerError","arguments","$6f288d3a82088e8b$var$_platformHeaders","$6f288d3a82088e8b$var$_AbstractPage_client","$6f288d3a82088e8b$require$Buffer","$6ZWSX","Buffer","$hPtJY","$6f288d3a82088e8b$var$__classPrivateFieldSet","__classPrivateFieldSet","receiver","state","kind","f","TypeError","$6f288d3a82088e8b$var$__classPrivateFieldGet","__classPrivateFieldGet","toBase64","getHeader","getRequiredHeader","isHeadersProtocol","debug","hasOwn","isEmptyObj","maybeCoerceBoolean","maybeCoerceFloat","maybeCoerceInteger","coerceBoolean","coerceFloat","coerceInteger","ensurePresent","sleep","safeJSON","isRequestOptions","createResponseHeaders","PagePromise","AbstractPage","APIPromise","createForm","multipartFormRequestOptions","maybeMultipartFormRequestOptions","$bNSG8","$9Dbsu","$hTt11","$dJFm5","$laDyk","$6f288d3a82088e8b$var$defaultParseResponse","props","response","stream","$6f288d3a82088e8b$var$debug","url","__streamClass","fromSSEResponse","controller","Stream","__binaryResponse","contentType","json","$6f288d3a82088e8b$var$_addRequestID","text","Array","isArray","$6f288d3a82088e8b$var$APIPromise","Promise","responsePromise","parseResponse","resolve","_thenUnwrap","transform","asResponse","then","p","withResponse","data","all","parse","parsedPromise","onfulfilled","onrejected","catch","finally","onfinally","overridenFetch","$6f288d3a82088e8b$var$validatePositiveInteger","Accept","getUserAgent","$6f288d3a82088e8b$var$getPlatformHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","$6f288d3a82088e8b$var$uuid4","methodRequest","post","patch","put","delete","request","isBlobLike","DataView","arrayBuffer","ArrayBuffer","isView","buffer","getAPIList","requestAPIList","calculateContentLength","byteLength","toString","TextEncoder","encoded","encoder","encode","length","retryCount","__binaryRequest","isMultipartBody","contentLength","buildURL","getDefaultAgent","minAgentTimeout","idempotencyHeader","idempotencyKey","reqHeaders","buildHeaders","req","agent","signal","$6f288d3a82088e8b$var$applyHeadersMut","String","prepareRequest","parseHeaders","Symbol","iterator","fromEntries","from","map","header","makeStatusError","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","AbortController","fetchWithTimeout","retryRequest","name","responseHeaders","ok","shouldRetry","retryMessage","errText","errJSON","errMessage","$6f288d3a82088e8b$var$PagePromise","URL","$6f288d3a82088e8b$var$isAbsoluteURL","endsWith","startsWith","slice","$6f288d3a82088e8b$var$isEmptyObj","search","entries","filter","_","key","encodeURIComponent","join","ms","addEventListener","abort","setTimeout","getRequestClient","clearTimeout","shouldRetryHeader","timeoutMillis","retryAfterMillisHeader","timeoutMs","parseFloat","Number","isNaN","retryAfterHeader","timeoutSeconds","Date","now","calculateDefaultRetryTimeoutMillis","sleepSeconds","Math","min","initialRetryDelay","pow","random","VERSION","$6f288d3a82088e8b$var$AbstractPage","client","hasNextPage","items","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","iterPages","page","WeakMap","asyncIterator","item","Proxy","target","toLowerCase","$6f288d3a82088e8b$var$requestOptionsKeys","obj","keys","every","$6f288d3a82088e8b$var$hasOwn","$6f288d3a82088e8b$var$getPlatformProperties","Deno","build","$6f288d3a82088e8b$var$normalizePlatform","os","$6f288d3a82088e8b$var$normalizeArch","arch","version","deno","EdgeRuntime","platform","browserInfo","$6f288d3a82088e8b$var$getBrowserInfo","navigator","pattern","match","exec","userAgent","major","minor","browser","$6f288d3a82088e8b$var$startsWithSchemeRegexp","RegExp","test","isInteger","_k","targetHeaders","newHeaders","lowerKey","val","action","args","env","console","log","trim","round","parseInt","Boolean","replace","c","r","window","document","foundHeader","lowerCasedHeader","intercapsHeader","toUpperCase","substring","_m","g1","g2","warn","str","btoa","$51861dfc7ca9d588$export$a143d493d941bafc","$51861dfc7ca9d588$export$f99ded8fe4b79145","$kuxul","$9NvM5","$51861dfc7ca9d588$var$customInspectSymbol","$51861dfc7ca9d588$var$createBuffer","RangeError","buf","Uint8Array","setPrototypeOf","$51861dfc7ca9d588$var$Buffer","arg","encodingOrOffset","$51861dfc7ca9d588$var$allocUnsafe","$51861dfc7ca9d588$var$from","$51861dfc7ca9d588$var$fromString","string","encoding","isEncoding","$51861dfc7ca9d588$var$byteLength","actual","write","$51861dfc7ca9d588$var$fromArrayView","arrayView","$51861dfc7ca9d588$var$isInstance","copy","$51861dfc7ca9d588$var$fromArrayBuffer","byteOffset","$51861dfc7ca9d588$var$fromArrayLike","SharedArrayBuffer","valueOf","b","$51861dfc7ca9d588$var$fromObject","isBuffer","len","$51861dfc7ca9d588$var$checked","toPrimitive","$51861dfc7ca9d588$var$assertSize","size","array","i","mustMatch","loweredCase","$51861dfc7ca9d588$var$utf8ToBytes","$51861dfc7ca9d588$var$base64ToBytes","$51861dfc7ca9d588$var$slowToString","start","end","$51861dfc7ca9d588$var$hexSlice","out","$51861dfc7ca9d588$var$hexSliceLookupTable","$51861dfc7ca9d588$var$utf8Slice","$51861dfc7ca9d588$var$asciiSlice","ret","fromCharCode","$51861dfc7ca9d588$var$latin1Slice","fromByteArray","$51861dfc7ca9d588$var$utf16leSlice","bytes","res","$51861dfc7ca9d588$var$swap","$51861dfc7ca9d588$var$bidirectionalIndexOf","dir","$51861dfc7ca9d588$var$arrayIndexOf","indexOf","lastIndexOf","arr","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","$51861dfc7ca9d588$var$decodeCodePointsArray","codePoints","apply","$51861dfc7ca9d588$var$checkOffset","offset","ext","$51861dfc7ca9d588$var$checkInt","max","$51861dfc7ca9d588$var$wrtBigUInt64LE","$51861dfc7ca9d588$var$checkIntBI","lo","BigInt","hi","$51861dfc7ca9d588$var$wrtBigUInt64BE","$51861dfc7ca9d588$var$checkIEEE754","$51861dfc7ca9d588$var$writeFloat","littleEndian","noAssert","$51861dfc7ca9d588$var$writeDouble","TYPED_ARRAY_SUPPORT","$51861dfc7ca9d588$var$typedArraySupport","proto","foo","poolSize","alloc","fill","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","isFinite","remaining","$51861dfc7ca9d588$var$hexWrite","strLen","parsed","substr","$51861dfc7ca9d588$var$blitBuffer","$51861dfc7ca9d588$var$asciiToBytes","byteArray","charCodeAt","$51861dfc7ca9d588$var$utf16leToBytes","units","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$51861dfc7ca9d588$var$defineBigIntMethod","$51861dfc7ca9d588$var$validateNumber","first","last","$51861dfc7ca9d588$var$boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$51861dfc7ca9d588$var$errors","$51861dfc7ca9d588$var$E","sym","getMessage","Base","stack","$51861dfc7ca9d588$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","received","abs","$51861dfc7ca9d588$var$INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","$51861dfc7ca9d588$var$base64clean","split","src","dst","alphabet","table","i16","fn","$51861dfc7ca9d588$var$BufferBigIntNotDefined","$eeb0961446aae8e3$export$d622b2ad8d90c771","$eeb0961446aae8e3$export$6100ba28696e12de","b64","tmp","lens","$eeb0961446aae8e3$var$getLens","validLen","placeHoldersLen","$eeb0961446aae8e3$var$Arr","curByte","$eeb0961446aae8e3$var$revLookup","uint8","extraBytes","parts","len2","$eeb0961446aae8e3$var$encodeChunk","output","$eeb0961446aae8e3$var$lookup","num","$eeb0961446aae8e3$var$code","$eeb0961446aae8e3$var$i","$eeb0961446aae8e3$var$len","$7221566bd4d49f44$export$aafa59e2e03f2942","$7221566bd4d49f44$export$68d8715fc104d294","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","NaN","rt","LN2","$cfae44f0dfdf62c0$var$cachedSetTimeout","$cfae44f0dfdf62c0$var$cachedClearTimeout","$cfae44f0dfdf62c0$var$currentQueue","$cfae44f0dfdf62c0$var$process","$cfae44f0dfdf62c0$var$defaultSetTimout","$cfae44f0dfdf62c0$var$defaultClearTimeout","$cfae44f0dfdf62c0$var$runTimeout","fun","$cfae44f0dfdf62c0$var$queue","$cfae44f0dfdf62c0$var$draining","$cfae44f0dfdf62c0$var$queueIndex","$cfae44f0dfdf62c0$var$cleanUpNextTick","$cfae44f0dfdf62c0$var$drainQueue","run","$cfae44f0dfdf62c0$var$runClearTimeout","marker","$cfae44f0dfdf62c0$var$Item","$cfae44f0dfdf62c0$var$noop","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","$7030a4fbf7735146$require$Buffer","readableStreamAsyncIterable","_decodeChunks","_iterSSEMessages","$7030a4fbf7735146$var$Stream","consumed","done","sse","$7030a4fbf7735146$var$_iterSSEMessages","event","raw","fromReadableStream","readableStream","iterLines","lineDecoder","$7030a4fbf7735146$var$LineDecoder","chunk","$7030a4fbf7735146$var$readableStreamAsyncIterable","line","decode","flush","tee","left","right","teeIterator","queue","next","shift","toReadableStream","iter","self","ReadableStream","pull","ctrl","close","enqueue","cancel","return","sseDecoder","$7030a4fbf7735146$var$SSEDecoder","sseChunk","$7030a4fbf7735146$var$iterSSEChunks","patternIndex","binaryChunk","newData","$7030a4fbf7735146$var$findDoubleNewlineIndex","chunks","fieldname","$7030a4fbf7735146$var$partition","delimiter","index","trailingCR","decodeText","trailingNewline","NEWLINE_CHARS","lines","NEWLINE_REGEXP","pop","TextDecoder","textDecoder","reader","getReader","releaseLock","cancelPromise","decoder","$gnmoI","$7XsUa","property","setShims","getRuntime","auto","isFsReadStream","getMultipartRequestOptions","File","Blob","FormData","Headers","Response","Request","shims","$5cb476ff57f7ce12$var$__createBinding","$5cb476ff57f7ce12$var$__exportStar","__exportStar","exports1","$h7UJD","manuallyImported","_fetch","_Request","_Response","_Headers","recommendation","form","MultipartBody","$c77f1980f472f1fb$var$MultipartBody","toStringTag","$f6993680408976e3$require$Buffer","isUploadable","isFileLike","isResponseLike","$f6993680408976e3$var$toFile","blob","pathname","bits","$f6993680408976e3$var$getBytes","$f6993680408976e3$var$getName","$f6993680408976e3$var$getStringFromMaybeBuffer","filename","$f6993680408976e3$var$isAsyncIterableIterator","$f6993680408976e3$var$propsForError","getOwnPropertyNames","lastModified","$f6993680408976e3$var$maybeMultipartFormRequestOptions","$f6993680408976e3$var$hasUploadableValue","$f6993680408976e3$var$multipartFormRequestOptions","$f6993680408976e3$var$createForm","$f6993680408976e3$var$addFormValue","some","append","file","entry","prop","formats","$324yj","$83e49f994ad17dad$var$formats","formatters","RFC1738","RFC3986","default_format","$ckmPh","$3JE24","$8f990f113c373965$var$has","$8f990f113c373965$var$array_prefix_generators","brackets","prefix","comma","indices","repeat","$8f990f113c373965$var$is_array","$8f990f113c373965$var$push","$8f990f113c373965$var$push_to_array","value_or_array","$8f990f113c373965$var$to_ISO","toISOString","$8f990f113c373965$var$defaults","addQueryPrefix","allowDots","allowEmptyArrays","charset","charsetSentinel","encodeDotInKeys","encodeValuesOnly","format","formatter","serializeDate","date","skipNulls","strictNullHandling","$8f990f113c373965$var$sentinel","object","obj_keys","$8f990f113c373965$var$normalize_stringify_options","commaRoundTrip","sort","generateArrayPrefix","sideChannel","$8f990f113c373965$var$inner_stringify","tmp_sc","step","find_flag","maybe_map","$8f990f113c373965$var$is_non_nullish_primitive","is_buffer","key_value","values","encoded_prefix","adjusted_prefix","encoded_key","key_prefix","valueSideChannel","joined","combine","is_regexp","compact","assign_single_source","merge","$2b84a0a7ef9203e1$var$has","$2b84a0a7ef9203e1$var$is_array","$2b84a0a7ef9203e1$var$hex_table","$2b84a0a7ef9203e1$var$merge","source","plainObjects","allowPrototypes","mergeTarget","$2b84a0a7ef9203e1$var$array_to_object","forEach","targetItem","reduce","acc","strWithoutPlus","unescape","decodeURIComponent","_defaultEncoder","_kind","escape","$0","segment","charAt","refs","$2b84a0a7ef9203e1$var$compact_queue","compacted","mapped","$463e8316d2b1d31a$var$Page","nextPageParams","$463e8316d2b1d31a$var$CursorPage","info","after","$16bf1c80b358adfa$var$__createBinding","$16bf1c80b358adfa$var$__exportStar","$ciH5k","$g4W1Q","$aWvNl","$kSU3b","$fowbp","$beenb","$aDo8r","$8tzbZ","$aROqG","$iSJzc","$eAdos","$fwzPu","$9dwab","$andP1","$b4d5a3246a53a142$var$Completions","APIResource","_client","$6b5e46ec8b6e8e3e$var$__createBinding","$6b5e46ec8b6e8e3e$var$__setModuleDefault","$6b5e46ec8b6e8e3e$var$__importStar","$6b5e46ec8b6e8e3e$var$CompletionsAPI","$6b5e46ec8b6e8e3e$var$Chat","$8f48963ca32ef6bd$var$__createBinding","$8f48963ca32ef6bd$var$__setModuleDefault","$8f48963ca32ef6bd$var$__importStar","$8f48963ca32ef6bd$var$SpeechAPI","$8f48963ca32ef6bd$var$TranscriptionsAPI","$8f48963ca32ef6bd$var$TranslationsAPI","$8f48963ca32ef6bd$var$Audio","transcriptions","Transcriptions","translations","Translations","speech","Speech","$410edb05c3c553e7$var$Speech","$58943df33a812568$var$__createBinding","$58943df33a812568$var$__setModuleDefault","$58943df33a812568$var$__importStar","$58943df33a812568$var$Core","$58943df33a812568$var$Transcriptions","$ee45990c8945fa08$var$__createBinding","$ee45990c8945fa08$var$__setModuleDefault","$ee45990c8945fa08$var$__importStar","$ee45990c8945fa08$var$Core","$ee45990c8945fa08$var$Translations","$bb4a085d0b01c5ea$var$__createBinding","$bb4a085d0b01c5ea$var$__setModuleDefault","$bb4a085d0b01c5ea$var$__importStar","$bb4a085d0b01c5ea$var$BatchesAPI","$61UiY","$bb4a085d0b01c5ea$var$Batches","retrieve","batchId","$bb4a085d0b01c5ea$var$BatchesPage","$7f77fbfb5659c119$var$__createBinding","$7f77fbfb5659c119$var$__setModuleDefault","$7f77fbfb5659c119$var$__importStar","$7f77fbfb5659c119$var$AssistantsAPI","$7f77fbfb5659c119$var$ChatAPI","$7f77fbfb5659c119$var$ThreadsAPI","$7f77fbfb5659c119$var$VectorStoresAPI","$7f77fbfb5659c119$var$Beta","vectorStores","VectorStores","assistants","Assistants","threads","Threads","VectorStoresPage","AssistantsPage","$a7fdd4d1c5f6a35c$var$__createBinding","$a7fdd4d1c5f6a35c$var$__setModuleDefault","$a7fdd4d1c5f6a35c$var$__importStar","$a7fdd4d1c5f6a35c$var$AssistantsAPI","$a7fdd4d1c5f6a35c$var$Assistants","assistantId","update","$a7fdd4d1c5f6a35c$var$AssistantsPage","del","$50781fe4b0b1f3c9$var$__createBinding","$50781fe4b0b1f3c9$var$__setModuleDefault","$50781fe4b0b1f3c9$var$__importStar","$50781fe4b0b1f3c9$var$CompletionsAPI","$50781fe4b0b1f3c9$var$Chat","ChatCompletionStream","ParsingToolFunction","ParsingFunction","ChatCompletionStreamingRunner","ChatCompletionRunner","$i4Djk","$6tV2R","$ioyPV","$2ArjU","$8TnOx","$6a1955b736a9e272$var$Completions","validateInputTools","tools","completion","parseChatCompletion","runFunctions","runTools","createChatCompletion","$dLYfX","$lV4f5","$d28718067f0bfb8e$var$ChatCompletionRunner","AbstractChatCompletionRunner","runner","_run","_runFunctions","_runTools","_addMessage","isAssistantMessage","content","_emit","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_instances","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalContent","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalMessage","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCall","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_getFinalFunctionCallResult","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_calculateTotalUsage","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_validateParams","$a06e67d568f03f7e$var$_AbstractChatCompletionRunner_stringifyFunctionCallResult","$a06e67d568f03f7e$var$__classPrivateFieldGet","$aE86S","$a06e67d568f03f7e$var$AbstractChatCompletionRunner","EventStream","add","_chatCompletions","messages","_addChatCompletion","chatCompletion","choices","isFunctionMessage","isToolMessage","function_call","tool_calls","tool_call","function","finalChatCompletion","finalContent","finalMessage","finalFunctionCall","finalFunctionCallResult","totalUsage","allChatCompletions","_emitFinal","usage","_createChatCompletion","_connected","_runChatCompletion","role","restParams","singleFunctionToCall","maxChatCompletions","functionsByName","functions","parameters","description","isRunnableFunctionWithParse","rawContent","tool_choice","inputTools","tool","isAutoParsableTool","$callback","$parseRaw","strict","t","tool_call_id","WeakSet","rest","refusal","at","total","completion_tokens","prompt_tokens","total_tokens","isPresent","$7c03ee430b911abc$var$_EventStream_instances","$7c03ee430b911abc$var$_EventStream_connectedPromise","$7c03ee430b911abc$var$_EventStream_resolveConnectedPromise","$7c03ee430b911abc$var$_EventStream_rejectConnectedPromise","$7c03ee430b911abc$var$_EventStream_endPromise","$7c03ee430b911abc$var$_EventStream_resolveEndPromise","$7c03ee430b911abc$var$_EventStream_rejectEndPromise","$7c03ee430b911abc$var$_EventStream_listeners","$7c03ee430b911abc$var$_EventStream_ended","$7c03ee430b911abc$var$_EventStream_errored","$7c03ee430b911abc$var$_EventStream_aborted","$7c03ee430b911abc$var$_EventStream_catchingPromiseCreated","$7c03ee430b911abc$var$_EventStream_handleError","$7c03ee430b911abc$var$__classPrivateFieldSet","$7c03ee430b911abc$var$__classPrivateFieldGet","reject","executor","bind","ended","errored","listener","findIndex","l","splice","emitted","openAIError","hasAutoParseableInput","shouldParseToolCall","maybeParseChatCompletion","makeParseableTool","isAutoParsableResponseFormat","makeParseableResponseFormat","$6795eec1c548472d$var$isAutoParsableResponseFormat","response_format","$6795eec1c548472d$var$isAutoParsableTool","$6795eec1c548472d$var$parseChatCompletion","choice","finish_reason","toolCall","$6795eec1c548472d$var$parseToolCall","inputTool","find","parsed_arguments","$6795eec1c548472d$var$hasAutoParseableInput","parser","defineProperties","$brand","callback","$4b81b37d4a971c7e$var$ChatCompletionStreamingRunner","_fromReadableStream","$1e2422cab6410049$var$_ChatCompletionStream_instances","$1e2422cab6410049$var$_ChatCompletionStream_params","$1e2422cab6410049$var$_ChatCompletionStream_choiceEventStates","$1e2422cab6410049$var$_ChatCompletionStream_currentChatCompletionSnapshot","$1e2422cab6410049$var$_ChatCompletionStream_beginRequest","$1e2422cab6410049$var$_ChatCompletionStream_getChoiceEventState","$1e2422cab6410049$var$_ChatCompletionStream_addChunk","$1e2422cab6410049$var$_ChatCompletionStream_emitToolCallDoneEvent","$1e2422cab6410049$var$_ChatCompletionStream_emitContentDoneEvents","$1e2422cab6410049$var$_ChatCompletionStream_endRequest","$1e2422cab6410049$var$_ChatCompletionStream_getAutoParseableResponseFormat","$1e2422cab6410049$var$_ChatCompletionStream_accumulateChatCompletion","$1e2422cab6410049$var$__classPrivateFieldSet","$1e2422cab6410049$var$__classPrivateFieldGet","$llclb","$1e2422cab6410049$var$ChatCompletionStream","currentChatCompletionSnapshot","chatId","content_done","refusal_done","logprobs_content_done","logprobs_refusal_done","done_tool_calls","current_tool_call_index","choiceSnapshot","delta","snapshot","logprobs","toolCallDelta","toolCallSnapshot","arguments_delta","toolCallIndex","responseFormat","$1e2422cab6410049$var$finalizeChatCompletion","created","system_fingerprint","choiceRest","messageRest","toolRest","fnRest","$1e2422cab6410049$var$str","_b","_c","_d","other","assign","partialParse","pushQueue","readQueue","MalformedJSON","PartialJSON","$f89521b6a1d718ec$var$Allow","STR","NUM","ARR","OBJ","NULL","BOOL","NAN","INFINITY","MINUS_INFINITY","ALL","$f89521b6a1d718ec$var$ATOM","$f89521b6a1d718ec$var$PartialJSON","$f89521b6a1d718ec$var$MalformedJSON","$f89521b6a1d718ec$var$_parseJSON","jsonString","allow","markPartialJSON","throwMalformedError","parseAny","skipBlank","parseStr","parseObj","parseArr","parseNum","$f89521b6a1d718ec$var$parseJSON","allowPartial","$035d0bb2680a6aee$var$__createBinding","$035d0bb2680a6aee$var$__setModuleDefault","$035d0bb2680a6aee$var$__importStar","$bbMZx","$035d0bb2680a6aee$var$MessagesAPI","$035d0bb2680a6aee$var$RunsAPI","$035d0bb2680a6aee$var$Threads","runs","Runs","Messages","threadId","createAndRun","createAndRunPoll","poll","thread_id","createAndRunStream","AssistantStream","createThreadAssistantStream","RunsPage","MessagesPage","$8256b977bba312d2$var$_AssistantStream_instances","$8256b977bba312d2$var$_AssistantStream_events","$8256b977bba312d2$var$_AssistantStream_runStepSnapshots","$8256b977bba312d2$var$_AssistantStream_messageSnapshots","$8256b977bba312d2$var$_AssistantStream_messageSnapshot","$8256b977bba312d2$var$_AssistantStream_finalRun","$8256b977bba312d2$var$_AssistantStream_currentContentIndex","$8256b977bba312d2$var$_AssistantStream_currentContent","$8256b977bba312d2$var$_AssistantStream_currentToolCallIndex","$8256b977bba312d2$var$_AssistantStream_currentToolCall","$8256b977bba312d2$var$_AssistantStream_currentEvent","$8256b977bba312d2$var$_AssistantStream_currentRunSnapshot","$8256b977bba312d2$var$_AssistantStream_currentRunStepSnapshot","$8256b977bba312d2$var$_AssistantStream_addEvent","$8256b977bba312d2$var$_AssistantStream_endRequest","$8256b977bba312d2$var$_AssistantStream_handleMessage","$8256b977bba312d2$var$_AssistantStream_handleRunStep","$8256b977bba312d2$var$_AssistantStream_handleEvent","$8256b977bba312d2$var$_AssistantStream_accumulateRunStep","$8256b977bba312d2$var$_AssistantStream_accumulateMessage","$8256b977bba312d2$var$_AssistantStream_accumulateContent","$8256b977bba312d2$var$_AssistantStream_handleRun","$8256b977bba312d2$var$__createBinding","$8256b977bba312d2$var$__setModuleDefault","$8256b977bba312d2$var$__importStar","$8256b977bba312d2$var$__classPrivateFieldGet","$8256b977bba312d2$var$__classPrivateFieldSet","$8256b977bba312d2$var$Core","$8256b977bba312d2$var$AssistantStream","_addRun","createToolAssistantStream","runId","_runToolAssistantStream","_createToolAssistantStream","submitToolOutputs","thread","_threadAssistantStream","createAssistantStream","_runAssistantStream","currentEvent","currentRun","currentMessageSnapshot","currentRunStepSnapshot","finalRunSteps","finalMessages","finalRun","_createThreadAssistantStream","_createAssistantStream","accumulateDelta","deltaValue","accValue","deltaEntry","accEntry","accumulatedMessage","newContent","snapshotContent","textDelta","image_file","currentContent","accumulatedRunStep","step_details","details","accumulated","contentElement","$c33b83ee882b6150$var$__createBinding","$c33b83ee882b6150$var$__setModuleDefault","$c33b83ee882b6150$var$__importStar","$c33b83ee882b6150$var$MessagesAPI","$c33b83ee882b6150$var$Messages","messageId","$c33b83ee882b6150$var$MessagesPage","$91007f8527922aa3$var$__createBinding","$91007f8527922aa3$var$__setModuleDefault","$91007f8527922aa3$var$__importStar","$91007f8527922aa3$var$RunsAPI","$91007f8527922aa3$var$StepsAPI","$91007f8527922aa3$var$Runs","steps","Steps","include","$91007f8527922aa3$var$RunsPage","createAndPoll","createAndStream","pollIntervalMs","sleepInterval","headerInterval","headerIntervalMs","submitToolOutputsAndPoll","submitToolOutputsStream","RunStepsPage","$0ad51b82eb11d956$var$__createBinding","$0ad51b82eb11d956$var$__setModuleDefault","$0ad51b82eb11d956$var$__importStar","$0ad51b82eb11d956$var$StepsAPI","$0ad51b82eb11d956$var$Steps","stepId","$0ad51b82eb11d956$var$RunStepsPage","$abf51e7c56408b48$var$__createBinding","$abf51e7c56408b48$var$__setModuleDefault","$abf51e7c56408b48$var$__importStar","$abf51e7c56408b48$var$VectorStoresAPI","$abf51e7c56408b48$var$FileBatchesAPI","$abf51e7c56408b48$var$FilesAPI","$abf51e7c56408b48$var$VectorStores","fileBatches","FileBatches","vectorStoreId","$abf51e7c56408b48$var$VectorStoresPage","VectorStoreFilesPage","$l1v1T","$lGdWS","$8293a0b364b2ed94$var$FileBatches","batch","listFiles","uploadAndPoll","fileIds","concurrencyLimit","maxConcurrency","fileIterator","allFileIds","processFiles","fileObj","purpose","workers","allSettledWithThrow","file_ids","$f4e1c2cf3a635e16$var$allSettledWithThrow","promises","results","allSettled","rejected","reason","$fc885726193f9a8d$var$__createBinding","$fc885726193f9a8d$var$__setModuleDefault","$fc885726193f9a8d$var$__importStar","$fc885726193f9a8d$var$FilesAPI","$fc885726193f9a8d$var$Files","fileId","$fc885726193f9a8d$var$VectorStoreFilesPage","fileResponse","upload","fileInfo","file_id","$f344543d16f2a799$var$Completions","$b3520fc5ae7a5eb7$var$Embeddings","$82cc26a881878841$var$__createBinding","$82cc26a881878841$var$__setModuleDefault","$82cc26a881878841$var$__importStar","$82cc26a881878841$var$Core","$82cc26a881878841$var$FilesAPI","$82cc26a881878841$var$Files","$82cc26a881878841$var$FileObjectsPage","retrieveContent","waitForProcessing","pollInterval","maxWait","TERMINAL_STATES","$7be0449f6c209c8e$var$__createBinding","$7be0449f6c209c8e$var$__setModuleDefault","$7be0449f6c209c8e$var$__importStar","$7be0449f6c209c8e$var$JobsAPI","$7be0449f6c209c8e$var$FineTuning","jobs","Jobs","FineTuningJobsPage","FineTuningJobEventsPage","$00260ff2d618b7cf$var$__createBinding","$00260ff2d618b7cf$var$__setModuleDefault","$00260ff2d618b7cf$var$__importStar","$00260ff2d618b7cf$var$JobsAPI","$00260ff2d618b7cf$var$CheckpointsAPI","$00260ff2d618b7cf$var$Jobs","checkpoints","Checkpoints","fineTuningJobId","$00260ff2d618b7cf$var$FineTuningJobsPage","listEvents","$00260ff2d618b7cf$var$FineTuningJobEventsPage","FineTuningJobCheckpointsPage","$522a77619cda4c6e$var$__createBinding","$522a77619cda4c6e$var$__setModuleDefault","$522a77619cda4c6e$var$__importStar","$522a77619cda4c6e$var$CheckpointsAPI","$522a77619cda4c6e$var$Checkpoints","$522a77619cda4c6e$var$FineTuningJobCheckpointsPage","$62bc54a5a5a16142$var$__createBinding","$62bc54a5a5a16142$var$__setModuleDefault","$62bc54a5a5a16142$var$__importStar","$62bc54a5a5a16142$var$Core","$62bc54a5a5a16142$var$Images","createVariation","edit","$7e95f8de20eb6a16$var$__createBinding","$7e95f8de20eb6a16$var$__setModuleDefault","$7e95f8de20eb6a16$var$__importStar","$7e95f8de20eb6a16$var$ModelsAPI","$7e95f8de20eb6a16$var$Models","$7e95f8de20eb6a16$var$ModelsPage","$dbf09dc36a05d37e$var$Moderations","$a9ded12b19f645b4$var$__createBinding","$a9ded12b19f645b4$var$__setModuleDefault","$a9ded12b19f645b4$var$__importStar","$a9ded12b19f645b4$var$PartsAPI","$a9ded12b19f645b4$var$Uploads","Parts","uploadId","complete","$060f5101d7f064a7$var$__createBinding","$060f5101d7f064a7$var$__setModuleDefault","$060f5101d7f064a7$var$__importStar","$060f5101d7f064a7$var$Core","$060f5101d7f064a7$var$Parts","$cM6Z0","$79440f4aa71907b8$export$848feb93d8f32b9b","openai","$79440f4aa71907b8$export$49af0b5dadf7ec11","$79440f4aa71907b8$export$9d45e7b0edf3c455","$c1ce9d969bfa6909$var$wordNum","$c1ce9d969bfa6909$var$enterWord","querySelector","languageCode","words","word","notes","textContent","en","targetLanguage","$c1ce9d969bfa6909$var$checkAttempt","originalSentence","attempt","correctedAttempt","correctionsStr","correction","corrections"],"version":3,"file":"index.aed3a654.js.map"}